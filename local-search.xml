<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>九月合集</title>
    <link href="/2025/10/05/%E4%B9%9D%E6%9C%88%E5%90%88%E9%9B%86/"/>
    <url>/2025/10/05/%E4%B9%9D%E6%9C%88%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="codeforces-round-1048div.-2">2139. <a href="https://codeforces.com/contest/2139">CodeForces Round 1048（Div. 2）</a></h3><p><strong>过题：</strong> 3/7 <strong>排名：</strong> 3750 <strong>上分：</strong> -（unr）</p><p>被出题人的疏忽拯救的一场。如果题面没锅不unr得掉大分了。戏剧性的是室友和队友这场打得都非常强势，得知unr后都相当愤怒。</p><h4 id="a.-maple-and-multiplication">A. Maple and Multiplication</h4><p>如果 <span class="math inline"><em>a</em> = <em>b</em></span>，不用操作。如果 <span class="math inline"><em>a</em> ∣ <em>b</em></span> 或 <span class="math inline"><em>b</em> ∣ <em>a</em></span>，操作一次。否则先 <span class="math inline"><em>a</em> → <em>a</em><em>b</em></span>，再 <span class="math inline"><em>b</em> → <em>a</em><em>b</em></span>，操作两次。 <a href="https://codeforces.com/contest/2139/submission/337556954">Code</a>.</p><h4 id="b.-cake-collection">B. Cake Collection</h4><p>可以注意到，累积过程不因中途的取走操作而改变。因此每个烤箱至多只取一次。</p><p>越早取，该烤箱最终累积没取的蛋糕会越多。可以这样考虑：对于一个每秒生产 <span class="math inline"><em>x</em></span> 个蛋糕的烤箱而言，早取一秒就使总数亏损 <span class="math inline"><em>x</em></span>。于是我们给出贪心的方案：按 <span class="math inline"><em>x</em></span> 排序，<span class="math inline"><em>x</em></span> 越大的越靠后取。</p><p>时间复杂度 <span class="math inline">𝒪(<em>n</em>log <em>n</em>)</span>，<a href="https://codeforces.com/contest/2139/submission/337577025">Code</a>.</p><h4 id="c.-cake-assignment">C. Cake Assignment</h4><p>是一道似曾相识的找规律题（好像在牛客多校做过）。</p><p>下面记 <span class="math inline"><em>K</em> = 2<sup><em>k</em></sup></span> 。</p><p>一次操作后 Chocola 的值为 <span class="math inline">2<sup><em>k</em> − 1</sup></span>（执行操作一）或 <span class="math inline">3 × 2<sup><em>k</em> − 1</sup></span> （执行操作二）。</p><p>两次操作后为 <span class="math inline">2<sup><em>k</em> − 2</sup>, 5 × 2<sup><em>k</em> − 2</sup>, 3 × 2<sup><em>k</em> − 2</sup></span> 或 <span class="math inline">7 × 2<sup><em>k</em> − 2</sup></span>。以此类推。</p><p>所以根据 <span class="math inline"><em>x</em></span> 因子中 <span class="math inline">2</span> 的次数就可以判断操作次数。至于操作序列，依次模一个每次自乘 <span class="math inline">2</span> 的 <span class="math inline">2</span> 的幂次。如果余数小于模数的一半，计 <span class="math inline">1</span>（操作为 Chocola 送出蛋糕），反之计 <span class="math inline">2</span>（操作为 Chocola 收到蛋糕）。</p><p>然后挨个输出即可。时间复杂度 <span class="math inline">𝒪(<em>k</em>)</span>。<a href="https://codeforces.com/contest/2139/submission/337602145">Code</a>.</p><h4 id="d.-antiamuny-wants-to-learn-swap">D. Antiamuny Wants to Learn Swap</h4><blockquote><p>此题原题面与 std 做法不符，出题组赛时对题面进行了修改，导致整场比赛UNR。区别在于能否多次执行操作二。</p><p>能多次执行的原题面我暂时没有想到解决方案。也许是不可做题。此处只讨论修改后的题面。</p></blockquote><p>先考虑什么时候操作二能减少总操作次数。</p><p>首先联想到冒泡排序。本质上交换次数就是原序列中逆序对的数量，每次交换可以减少一个逆序对。</p><p>仔细分析：长度为三的序列中逆序对的数量为 <span class="math inline">0 ∼ 3</span> 。操作二若减少不少于两个逆序对，则原序列中逆序对数为二或三。</p><ul><li><p>若为二，则交换后变为零。交换后的序列为正序。因而反推知原序列为倒序，逆序对数应为三。与假设矛盾。</p></li><li><p>若为三，原序列为倒序。交换后为正序，逆序对数为零。当次交换减少了三个逆序对，优于操作一。符合要求。</p></li></ul><p>因此如果存在 <span class="math inline"><em>a</em><sub><em>i</em></sub> &gt; <em>a</em><sub><em>i</em> + 1</sub> &gt; <em>a</em><sub><em>i</em> + 2</sub>(1 ≤ <em>i</em> ≤ <em>n</em> − 2)</span> ，则 <span class="math inline"><em>f</em>(<em>b</em>) ≠ <em>g</em>(<em>b</em>)</span>。</p><p>再发现只要存在 <span class="math inline">1 ≤ <em>i</em> &lt; <em>j</em> &lt; <em>k</em> ≤ <em>n</em></span> ，使得 <span class="math inline"><em>a</em><sub><em>i</em></sub> &gt; <em>a</em><sub><em>j</em></sub> &gt; <em>a</em><sub><em>k</em></sub></span>，就可以通过几次相邻逆序对间的交换，化为上面的情况。（之所以强调逆序对间的交换是因为：如果交换了非逆序对就必须再花一次换回来，使最终代价加二，这在只允许一次操作二的前提下是不可接受的）</p><p><strong>证明显然</strong>：如果存在 <span class="math inline"><em>i</em> &lt; <em>l</em><sub>1</sub> &lt; <em>l</em><sub>2</sub> &lt; … &lt; <em>l</em><sub><em>N</em></sub> &lt; <em>j</em></span> ，且 <span class="math inline"><em>a</em><sub><em>l</em><sub><em>i</em></sub></sub> &lt; <em>a</em><sub><em>j</em></sub>(1 ≤ <em>i</em> ≤ <em>N</em>)</span>，则总可以每次从中找到一个最小的往前做逆序对交换（选择了最小的所以前面的一定比他大），直到 <span class="math inline"><em>j</em></span> 就是 <span class="math inline"><em>i</em></span> 右侧第一个满足 <span class="math inline"><em>a</em><sub><em>j</em></sub> &lt; <em>a</em><sub><em>i</em></sub></span> 的。此时就可以将 <span class="math inline"><em>j</em></span> 往前做逆序对交换了，最终交换到原 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 右侧紧邻的位置。同理可以把 <span class="math inline"><em>k</em></span> 也换过来。</p><p>因此问题转化成了：</p><p><span class="math inline"><em>Q</em></span> 次形如 <span class="math inline">[<em>l</em>, <em>r</em>]</span> 的询问，回答是否存在 <span class="math inline"><em>l</em> ≤ <em>i</em> &lt; <em>j</em> &lt; <em>k</em> ≤ <em>r</em></span> ，使得 <span class="math inline"><em>a</em><sub><em>i</em></sub> &gt; <em>a</em><sub><em>j</em></sub> &gt; <em>a</em><sub><em>k</em></sub></span>。</p><p>这一问题做法众多，线性的，带 <span class="math inline">log </span> 的，在线的，离线的，都有。此处介绍笔者的高码量低效率做法。</p><p>总体思路是对于每个 <span class="math inline"><em>i</em></span> ，预处理出其对应的 <span class="math inline"><em>k</em></span> 的最小值。然后就是简单的 RMQ 问题了——如果询问区间内的 <span class="math inline"><em>k</em><sub>min</sub> ≤ <em>r</em></span>，证明能找到三元递减子列，输出 <code>NO</code>。否则输出 <code>YES</code>。</p><p>预处理的过程如下：首先用单调栈预处理出每个数右边离其最近的小于其的数，记为 <span class="math inline"><em>b</em><sub><em>i</em></sub></span>。然后从右往左依次往权值线段树中加点 <span class="math inline">(<em>a</em><sub><em>i</em></sub>, <em>b</em><sub><em>i</em></sub>)</span>，并询问当前 <span class="math inline">1 ∼ <em>a</em><sub><em>i</em></sub> − 1</span> 中最小的 <span class="math inline"><em>b</em></span> 值，存下来作为预处理的结果。</p><p>总时间复杂度 <span class="math inline">𝒪(<em>n</em>log <em>n</em> + <em>Q</em>)</span>。Code.（链接以后再加）</p><h3 id="codeforces-round-1049div.-2">2140. <a href="https://codeforces.com/contest/2140">CodeForces Round 1049（Div. 2）</a></h3><p><strong>过题：</strong> 2/7 <strong>排名：</strong> 6256 <strong>上分：</strong> -95（1625）</p><p>纯菜。C 这种萌萌题都写不出还能说什么呢。</p><h4 id="a.-shift-sort">A. Shift Sort</h4><p>每次操作可以把一个 <span class="math inline">0</span> 归位。统计有几个没归位的 <span class="math inline">0</span> 即可。</p><p>时间复杂度 <span class="math inline">𝒪(<em>n</em>)</span>。<a href="https://codeforces.com/contest/2140/submission/337772533">Code</a>.</p><h4 id="b.-another-divisibility-problem">B. Another Divisibility Problem</h4><p>输出 <span class="math inline"><em>y</em> = 2<em>x</em></span> 即可。因为 <span class="math inline">$\overline{xy}=(10^k+2)x$</span> 有因子 <span class="math inline">3<em>x</em></span> ，而 <span class="math inline"><em>x</em> + <em>y</em> = 3<em>x</em></span>。所以 <span class="math inline">$\overline{xy}\mid x+y$</span>。</p><p>同理输出 <span class="math inline">8<em>x</em></span> 也可以。<a href="https://codeforces.com/contest/2140/submission/337800301">Code</a>.</p><h4 id="c.-ultimate-value">C. Ultimate Value</h4><p>首先注意到轮到 B 操作时，B一定直接结束游戏。因为不管 B 怎么操作，A 只需做逆操作复原即可，而这个过程中 <span class="math inline"><em>c</em><em>o</em><em>s</em><em>t</em></span> 值正在增长，这是不利于 B 的。（如果拖到第 <span class="math inline">10<sup>100</sup></span> 轮，当然 A 已经没有机会做逆操作了，但 B 在这一轮创造的收益一定是无法抵消前 <span class="math inline">10<sup>100</sup> − 1</span> 个回合累积的 <span class="math inline"><em>c</em><em>o</em><em>s</em><em>t</em></span> 的）</p><p>因此我们只需判断 A 是否操作。如果操作，怎么操作。</p><p>首先记所有操作前的 <span class="math inline"><em>f</em></span> 值为 <span class="math inline"><em>s</em><em>u</em><em>m</em></span>。</p><p>如果不进行奇偶位之间的交换，最优的操作为交换最左和最右奇数位上的数。若 <span class="math inline"><em>n</em></span> 为奇数，答案为 <span class="math inline"><em>s</em><em>u</em><em>m</em> + <em>n</em> − 1</span>，否则为 <span class="math inline"><em>s</em><em>u</em><em>m</em> + <em>n</em> − 2</span>。</p><p>如果进行奇偶位之间的交换，设选择的是 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 和 <span class="math inline"><em>a</em><sub><em>j</em></sub></span>，其中 <span class="math inline"><em>i</em></span> 为奇数，<span class="math inline"><em>j</em></span> 为偶数。则答案为 <span class="math inline"><em>s</em><em>u</em><em>m</em> − 2<em>a</em><sub><em>i</em></sub> + 2<em>a</em><sub><em>j</em></sub> + |<em>i</em> − <em>j</em>|</span>。考虑分类讨论去掉绝对值。</p><ul><li><span class="math inline"><em>i</em> &lt; <em>j</em></span> ，式子为 <span class="math inline"><em>s</em><em>u</em><em>m</em> + (2<em>a</em><sub><em>j</em></sub> + <em>j</em>) − (2<em>a</em><sub><em>i</em></sub> + <em>i</em>)</span>；</li><li><span class="math inline"><em>i</em> &gt; <em>j</em></span>， 式子为 <span class="math inline"><em>s</em><em>u</em><em>m</em> + (2<em>a</em><sub><em>j</em></sub> − <em>j</em>) − (2<em>a</em><sub><em>i</em></sub> − <em>i</em>)</span>。</li></ul><p>我们考虑预处理 <span class="math inline">{2<em>a</em><sub><em>i</em></sub> + <em>i</em>}</span> 的前缀最小值和 <span class="math inline">{2<em>a</em><sub><em>i</em></sub> − <em>i</em>}</span> 的后缀最小值。然后依次枚举 <span class="math inline"><em>j</em></span> 计算。</p><p>对得到的所有答案取最大值即可。</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 建站记录</title>
    <link href="/2025/10/05/Hexo%20%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/10/05/Hexo%20%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>近来想给自己的 Blog 换个好记的域名和主题风格，研究了一会发现好像必须开个新仓库从头再来。于是我写下这篇，给将来可能还要重建的自己做参考。</p><hr /><h4 id="准备工作">准备工作</h4><p>首先确认电脑中安装了 <a href="https://git-scm.com/">Git</a> 和较高版本的 <a href="https://nodejs.org/en/">Node.js</a> 。</p><p>然后用以下命令安装 <code>Hexo</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>然后查看 <code>Hexo</code> 的版本，检查是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo -v<br></code></pre></td></tr></table></figure><p>如果能输出正确的版本信息，则说明成功安装。否则说明各模块版本间可能存在兼容问题。建议询问大模型以获得解决方案。</p><p>比如此处我遭遇的问题是最新版本的 <code>Hexo 8.0.0</code> 并未完全适配其依赖包 <code>strip-ansi@7</code>。我的选择是将 <code>Hexo</code> 退回适配做得更好的 <code>7.3.0</code> 版本。</p><p>此外，还需要安装 Hexo 的 Git 部署插件，用于将静态文件推送到 Github：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>至此大体上准备工作就完成了，我们可以着手于建站了。</p><hr /><h4 id="初步建站">初步建站</h4><p>首先在本地创建一个空白文件夹。然后在文件夹内右键选择 <code>Open Git Bash Here</code> 并输入如下命令，完成初始化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init<br></code></pre></td></tr></table></figure><p>此时我们输入以下命令就可以在本地预览博客的样式了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo s<br></code></pre></td></tr></table></figure><p>当然，官方提供的默认主题还是过于朴实了。这里推荐大家选择一些用户开发的主题，最有名的大概是 <a href="https://github.com/theme-next/hexo-theme-next">NexT</a> 和 <a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a> 这两个。由于用户多，这两款主题的更新维护是较为及时的。</p><p>我的旧博客选择的是早已停止维护的 <a href="https://github.com/saicaca/hexo-theme-vivia">vivia</a> ，当前博客则是 <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a>。</p><p>现在以 <code>Fluid</code> 主题为例，介绍一下主题的配置过程：</p><p>首先在根目录 <code>Git Bash</code> 中输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>在根目录新建 <code>_config.fluid.yml</code>，将主题的 <code>_config.yml</code> 内容复制进去。</p><p>然后在目录中找到 <code>_config.yml</code> 文件，对 <code>theme</code> 和 <code>language</code> 属性进行修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br></code></pre></td></tr></table></figure><p>修改主题后，同样可以用 <code>hexo s</code> 命令在本地预览。</p><p>至于更进一步的配置，官方提供了详细的<a href="https://hexo.fluid-dev.com/docs/">用户文档</a>，可以用来参考。以后我可能也会单出一篇文章记录我的美化过程。</p><hr /><h4 id="基本命令">基本命令</h4><p>下面介绍一些常用的命令。</p><ul><li><p>创建一篇新文章（比如文章的标题为“八月合集”）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new post 八月合集<br></code></pre></td></tr></table></figure><p>执行此命令后，<code>_post</code> 文件夹会出现一个 <code>八月合集.md</code> 文件。我们可以对其进行编辑，完成我们的创作。</p></li><li><p>清除原有的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br></code></pre></td></tr></table></figure></li><li><p>生成静态文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g<br></code></pre></td></tr></table></figure><p>为所有 Blog 文件生成静态文件。为后续的 <code>deploy</code> 等操作做准备。</p></li><li><p>本地预览：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo s<br></code></pre></td></tr></table></figure><p>启动服务器，默认的访问网址为：<code>http://localhost:4000/</code>。一般 <code>Git Bash</code> 窗口里会直接出现这个链接。我们可以 <code>Ctrl</code> 键左击链接的 <code>4000</code> 处直接访问。</p></li><li><p>部署网站</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo d<br></code></pre></td></tr></table></figure><p>将项目推至云端。前置操作会在接下来的章节内详细说明。</p></li></ul><hr /><h4 id="部署-github-page">部署 Github Page</h4><p>为了让别人看到我们的 Blog，我们需要一个大家都可以访问的域名。通用的办法是将 Blog 直接部署在我们的 Github Page 上。网址为 ``。操作流程如下：</p><ul><li><p>首先我们在 Github 上创建一个名为 <code>username.github.io</code> 的仓库。其中 <code>username</code> 用你的用户名替换。</p></li><li><p>然后我们打开根目录中的 <code>-config.yml</code> 文件，找到 <code>deploy</code> 部分进行修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/你的GitHub用户名/你的仓库名.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br>  <span class="hljs-attr">message:</span> <span class="hljs-string">&quot;部署 Hexo 博客，更新于 $(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;)&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>然后我们就可以通过 <code>hexo d</code> 命令将本地的静态文件部署到 Github Page 上了。首次部署一般需要输入 Github 的账号密码。</p></li></ul><hr /><h4 id="让-blog-支持-latex">让 Blog 支持 latex</h4><p>由于 <code>Hexo</code> 原生的 <code>Markdown</code> 渲染器不支持复杂的公式渲染，所以需要我们手动更换渲染器。</p><p>首先删除 <code>hexo-math</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm un hexo-math<br></code></pre></td></tr></table></figure><p>替换渲染器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm un hexo-render-marked<br>$ npm i hexo-renderer-pandoc<br></code></pre></td></tr></table></figure><p>在 <code>_config.yml</code> 中加入这样一段代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># MathJax</span><br><span class="hljs-attr">math:</span><br>  <span class="hljs-attr">engine:</span> <span class="hljs-string">&#x27;mathjax&#x27;</span> <span class="hljs-comment"># or &#x27;katex&#x27;</span><br>  <span class="hljs-attr">mathjax:</span><br>    <span class="hljs-comment"># src: custom_mathjax_source</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-comment"># MathJax config</span><br><span class="hljs-attr">pandoc:</span><br>  <span class="hljs-attr">mathEngine:</span> <span class="hljs-string">mathjax</span><br>  <span class="hljs-attr">extra:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">--from=markdown+tex_math_dollars+raw_tex+escaped_line_breaks+pipe_tables+table_captions-implicit_figures</span><br>  <span class="hljs-attr">mathjax:</span><br>    <span class="hljs-comment"># 可以指定 MathJax 的 URL，也可以使用默认 CDN</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js</span><br></code></pre></td></tr></table></figure><p>并在主题文件中也做相应的修改。比如 <code>fluid</code> 主题中有关数学公式渲染的部分是这样的。其余主题可以参考官方文档自行配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">math:</span><br>    <span class="hljs-comment"># 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `math: true`</span><br>    <span class="hljs-comment"># If you want to use math on the custom page, you need to set `math: true` in Front-matter</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>    <span class="hljs-comment"># 开启后，只有在文章 Front-matter 里指定 `math: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度</span><br>    <span class="hljs-comment"># If true, only set `math: true` in Front-matter will enable math, to load faster when the page does not contain math</span><br>    <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br><br>    <span class="hljs-comment"># Options: mathjax | katex</span><br>    <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暑训7&amp;8 补题</title>
    <link href="/2025/08/08/%E6%9A%91%E8%AE%AD7&amp;8%20%E8%A1%A5%E9%A2%98/"/>
    <url>/2025/08/08/%E6%9A%91%E8%AE%AD7&amp;8%20%E8%A1%A5%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>两场全部打的依托……虽说早已出线无望，但越打状态越差还是很失望的。</p><h1 id="a">7A</h1><p><strong>题目大意：</strong></p><p>给定 <span class="math inline">100</span> 套玩具，每套 <span class="math inline">10</span> 个，每个都是 <span class="math inline">10 × 10</span> 的矩阵。初始时矩阵均为顺序排列，总共对这些矩阵进行了 <span class="math inline">10<sup>6</sup></span> 次 <span class="math inline">4 × 4</span> 范围内的顺时针旋转操作。最后选取 <span class="math inline">50</span> 套玩具，将套中的每个玩具替换成随机矩阵。请找出这 <span class="math inline">50</span> 套玩具，要求达到 <span class="math inline">90%</span> 的正确率。</p><p><strong>知识点：</strong> 置换、逆序对</p><p>经过大量的旋转，看单个数字最终所在位置已经没有意义。赛时打表得知每个数出现在各位置的几率几乎完全相等。因此不能孤立地考虑某一个数，而要关注整体的性质。</p><p>赛时我们一直在试图寻找，却没能找到的不变量，其实就是逆序对数。证明如下：</p><p>将矩阵展开为一行序列，可以看出每次旋转操作相当于进行了三次长度为 <span class="math inline">12</span> 的轮换和一次长度为 <span class="math inline">4</span> 的轮换。又注意到进行偶数次轮换不改变序列中的逆序对数，因此由旋转生成的玩具中逆序对一定为偶数。</p><p>而随机矩阵逆序对数为偶数的可能性只有一半，因此若一套中 <span class="math inline">10</span> 个玩具的逆序对数均为偶数，其极大概率由旋转生成。</p><p>时间复杂度由计算逆序对的过程决定。此题暴力计数亦可通过。</p><p>更多关于置换与逆序对的例题，可以参考我的另一篇笔记。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; id &gt;&gt; m &gt;&gt; k &gt;&gt; n;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, m) &#123;<br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">FOR</span>(j, <span class="hljs-number">1</span>, k) &#123;<br>            <span class="hljs-built_in">FOR</span>(l, <span class="hljs-number">1</span>, n * n) cin &gt;&gt; a[l];<br>            <span class="hljs-type">int</span> rev = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">FOR</span>(l, <span class="hljs-number">1</span>, n * n - <span class="hljs-number">1</span>) <span class="hljs-built_in">FOR</span>(u, l + <span class="hljs-number">1</span>, n * n)<br>                <span class="hljs-keyword">if</span> (a[l] &gt; a[u]) rev++;<br>            <span class="hljs-keyword">if</span> (rev &amp; <span class="hljs-number">1</span>) flag = <span class="hljs-number">1</span>;<br>        &#125;<br>        cout &lt;&lt; flag;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="d">7D</h1><p><strong>题目大意：</strong></p><p>给定一张有向图，找到所有从 <span class="math inline">1 → <em>n</em></span> 的路径中方差的下确界（边可以重复走）。其中点数 <span class="math inline"><em>n</em> ≤ 30</span> ，边数 <span class="math inline"><em>m</em> ≤ 200</span> ，边权 <span class="math inline"><em>w</em><sub><em>i</em></sub> ≤ 20</span>。</p><p><strong>知识点：</strong> dp</p><p>把方差的式子拆开。可以发现求路径方差的最小值，可以转化成固定路径内边的个数和总长度后最小化边的平方和： <span class="math display">$$D=\frac{1}{l}\sum_{i = 1}^{l}(w_i - \overline{w})^2=\frac{1}{l}\sum_{i = 1}^{l}w_i^2 - (\frac{1}{l}\sum_{i=1}^{l}{w})^2$$</span> 先考虑图中没有环时怎么做。</p><p>由于本题数据范围很小，这一过程支持高维dp处理。具体来说，设 <span class="math inline"><em>d</em><em>p</em><sub><em>i</em>, <em>j</em>, <em>l</em>, <em>w</em></sub></span> 表示 <span class="math inline"><em>i</em> → <em>j</em></span> 的所有路径中，经过 <span class="math inline"><em>l</em></span> 条边，总长度为 <span class="math inline"><em>w</em></span> 的情况下，边长平方和的最小值。转移只需枚举 <span class="math inline"><em>j</em></span> 上的出边。不妨设有一条从 <span class="math inline"><em>j</em></span> 指向 <span class="math inline"><em>k</em></span> ，边长为 <span class="math inline"><em>w</em><sub><em>i</em></sub></span> 的边，便有如下转移： <span class="math display"><em>d</em><em>p</em><sub><em>i</em>, <em>j</em>, <em>l</em>, <em>w</em></sub> + <em>w</em><sub><em>i</em></sub><sup>2</sup> → <em>d</em><em>p</em><sub><em>i</em>, <em>k</em>, <em>l</em> + 1, <em>w</em> + <em>w</em><sub><em>i</em></sub></sub></span> 注意到所有边数为 <span class="math inline"><em>l</em></span> 的状态必然由边数为 <span class="math inline"><em>l</em> − 1</span> 的状态转移而来。因此我们可以先枚举 <span class="math inline"><em>l</em></span> ，即可将这一维滚掉。时间复杂度 <span class="math inline">𝒪(<em>n</em><sup>3</sup><em>m</em><em>w</em>)</span> ，空间复杂度 <span class="math inline">𝒪(<em>n</em><sup>3</sup><em>w</em>)</span>，均在可接受范围内。</p><p>加入环之后，意味着我们可以在环上绕无数次，无限稀释路径上其他边的作用，让最终的答案等于环上的方差。</p><p>路径上的环要么不走，要么走无数次。不严谨的证明如下：</p><ul><li>如果环的方差大于等于原路径，多在环上走一圈不会使答案更优。</li><li>如果环的方差小于原路径，在环上走有限圈的方案的方差一定大于环的方差，而走无限圈的方差等于环的方差。因此走无限圈最优。</li></ul><p>因此答案只需对无环路径方差最小值，以及能从 <span class="math inline">1</span> 到达并能到达 <span class="math inline"><em>n</em></span> 的环方差最小值取 <span class="math inline">min </span> 。</p><p>环本质上是从某节点开始和结束的路径，因此环方差也可在 <span class="math inline"><em>d</em><em>p</em></span> 时算出。至于 ” 能从 <span class="math inline">1</span> 到达并能到达 <span class="math inline"><em>n</em></span> “ 这件事，可以通过类似 Floyd 算法的流程进行预处理。这样就做完了这道题。</p><p><strong>Code: </strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOR(i,j,k) for (int i = j; i &lt;= k; i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int, int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-title">dbmin</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">double</span> x, <span class="hljs-type">long</span> <span class="hljs-type">double</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x &lt; y ? x : y;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">31</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> W = <span class="hljs-number">21</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">1e9</span>;<br><br><span class="hljs-type">int</span> T;<br><br><span class="hljs-type">int</span> n, m, k;<br><br><span class="hljs-type">bool</span> ava[N][N];<br><span class="hljs-type">int</span> dp[N][N][N * W][<span class="hljs-number">2</span>];<br><br>vector&lt;pii&gt; e[N];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, m) &#123;<br>        <span class="hljs-type">int</span> x, y, w; cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;<br>        ava[x][y] = <span class="hljs-literal">true</span>;<br>        e[x].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">FOR</span>(j, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">FOR</span>(w, <span class="hljs-number">0</span>, N * W - <span class="hljs-number">1</span>) dp[i][j][w][<span class="hljs-number">0</span>] = dp[i][j][w][<span class="hljs-number">1</span>] = INF;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) dp[i][i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, ava[i][i] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">FOR</span>(j, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">FOR</span>(k, <span class="hljs-number">1</span>, n)<br>        <span class="hljs-keyword">if</span> (ava[j][i] &amp;&amp; ava[i][k]) ava[j][k] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (!ava[<span class="hljs-number">1</span>][n]) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br>    <span class="hljs-type">double</span> ans = INF;<br>    <span class="hljs-built_in">FOR</span>(l, <span class="hljs-number">1</span>, n) &#123;<br>        <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">FOR</span>(j, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">FOR</span>(w, <span class="hljs-number">0</span>, l * W) dp[i][j][w][l &amp; <span class="hljs-number">1</span>] = INF;<br>        <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">FOR</span>(j, <span class="hljs-number">1</span>, n) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> u : e[j]) &#123;<br>            <span class="hljs-type">int</span> k = u.first, wg = u.second;<br>            <span class="hljs-built_in">FOR</span>(w, wg, l * W) <br>                dp[i][k][w][l &amp; <span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i][k][w][l &amp; <span class="hljs-number">1</span>], dp[i][j][w - wg][(l &amp; <span class="hljs-number">1</span>) ^ <span class="hljs-number">1</span>] + wg * wg);<br>        &#125;<br>        <span class="hljs-built_in">FOR</span>(w, <span class="hljs-number">0</span>, l * W) <span class="hljs-keyword">if</span> (dp[<span class="hljs-number">1</span>][n][w][l &amp; <span class="hljs-number">1</span>] != INF) &#123;<br>            ans = <span class="hljs-built_in">dbmin</span>(ans, dp[<span class="hljs-number">1</span>][n][w][l &amp; <span class="hljs-number">1</span>] * <span class="hljs-number">1.0</span> / l - w * w * <span class="hljs-number">1.0</span> / (l * l));<br>        &#125;<br>        <span class="hljs-built_in">FOR</span>(w, <span class="hljs-number">0</span>, l * W) <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>            <span class="hljs-keyword">if</span> (dp[i][i][w][l &amp; <span class="hljs-number">1</span>] != INF &amp;&amp; ava[<span class="hljs-number">1</span>][i] &amp;&amp; ava[i][n]) &#123;<br>                ans = <span class="hljs-built_in">dbmin</span>(ans, dp[i][i][w][l &amp; <span class="hljs-number">1</span>] * <span class="hljs-number">1.0</span> / l - w * w * <span class="hljs-number">1.0</span> / (l * l));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.12lf\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>25暑训</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八月合集</title>
    <link href="/2025/08/01/%E5%85%AB%E6%9C%88%E5%90%88%E9%9B%86/"/>
    <url>/2025/08/01/%E5%85%AB%E6%9C%88%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="codeforces-round-1040div.-2">2130. <a href="https://codeforces.com/contest/2130">CodeForces Round 1040（Div. 2）</a></h3><p><strong>过题：</strong> 3/8 <strong>排名：</strong> 6015 <strong>上分：</strong> - 81 (1564)</p><p>状态奇差的一场，每一步都做了错误的选择。</p><p>A 没仔细写，WA了之后没有查哪里错了就慌着去开 B ，结果 B 看漏了零一二都有的条件，写了半天讨论。D 题也拿着假结论写了半天，发现样例都过不了，哈哈破防了。</p><h4 id="a.-submission-is-all-you-need">A. Submission is All You Need</h4><p>手玩发现只有选 <span class="math inline">{0}</span> 和 <span class="math inline">{0, 1}</span> 时操作二更有收益。因此统计 <span class="math inline">0</span> 的个数就行了。</p><p>时间复杂度 <span class="math inline">𝒪(<em>n</em>)</span> 。<a href="https://codeforces.com/contest/2130/problem/A">Code</a>.</p><h4 id="b.-pathless">B. Pathless</h4><p>注意到 <span class="math inline">0</span> 和 <span class="math inline">1</span> 不能相邻放。不然可以在这两格间随便刷。</p><p>因此如果有答案，答案应该是 <code>00..022..21..11</code> 形式（将 <span class="math inline">2</span> 放在 <span class="math inline">0</span> 或 <span class="math inline">1</span> 中不会带来本质不同的相邻组合）。接着判断是否有答案。</p><p>设 <span class="math inline">$\delta = s - \sum_{i = 1}^{n}a_i$</span> 。</p><ul><li>若 <span class="math inline"><em>δ</em> &lt; 0</span> ，随便放。</li><li>若 <span class="math inline"><em>δ</em> = 0</span> ，无解。</li><li>若 <span class="math inline"><em>δ</em> = 1</span> ，按照上述方法放就行。</li><li>若 <span class="math inline"><em>δ</em> ≥ 2</span> ，总能通过在 <code>02</code> 或者 <code>21</code> 之间多刷出 $$。所以无解。</li></ul><p>被自己的读题习惯害惨了。赛时没看见零一二都有，讨论了好多。</p><p>时间复杂度 <span class="math inline">𝒪(<em>n</em>)</span>。<a href="https://codeforces.com/contest/2130/submission/331807681">Code</a>.</p><h4 id="c.-double-perspective">C. Double Perspective</h4><p>首先发现，如果 <span class="math inline"><em>a</em> &lt; <em>b</em> &lt; <em>c</em></span> ，现有 $(a, c) $ 和 <span class="math inline">(<em>b</em>, <em>c</em>)</span> ，那么删去后者不改变 <span class="math inline"><em>f</em></span> 值且有可能使 <span class="math inline"><em>g</em></span> 值减小。因此删去它一定不劣于保留它。所以我们对每个数都只保留以它为右端点的线段中最长的一个。</p><p>然后发现这样的取舍方式下，图中根本就没有环了，即 <span class="math inline"><em>g</em> = 0</span> 。同时 <span class="math inline"><em>f</em></span> 值没有改变。这就是最优方案。</p><p>时间复杂度视实现为 <span class="math inline">𝒪(<em>n</em>)</span> 或 <span class="math inline">𝒪(<em>n</em>log <em>n</em>)</span> 。笔者的实现为后者。<a href="https://codeforces.com/contest/2130/submission/331827187">Code</a>.</p><h4 id="d.-stay-or-mirror">D. Stay or Mirror</h4><hr /><h3 id="codeforces-round-1042div.-3">2131. <a href="https://codeforces.com/contest/2131">CodeForces Round 1042（Div. 3）</a></h3><p><strong>过题：</strong> 5/8 <strong>排名：</strong> 1396 <strong>上分：</strong> + 41 (1605)</p><p>状态依旧很差，F 和 G 本应都做出来，结果双双弃掉。</p><h4 id="a.-lever">A. Lever</h4><p>显然操作是随机序还是按照顺序并不影响答案。直接线性扫一遍，统计操作 <span class="math inline">1</span> 进行的次数即可。</p><p>时间复杂度 <span class="math inline">𝒪(<em>n</em>)</span>。<a href="https://codeforces.com/contest/2131/submission/333292159">Code</a>.</p><h4 id="b.-alternating-series">B. Alternating Series</h4><p>负数小于等于 <span class="math inline"> − 1</span> ，因此被夹在两负数间的正数至少为 <span class="math inline">3</span>，两端的正数至少为 <span class="math inline">2</span> 。</p><p>要使绝对值序列字典序最小，答案一定是 <code>-1 3 -1 ... 3 -1（奇数）</code> 或 <code>-1 3 -1 ... 3 -1 2（偶数）</code> 的形式。</p><p>时间复杂度 <span class="math inline">𝒪(<em>n</em>)</span>。<a href="https://codeforces.com/contest/2131/submission/333300394">Code</a>.</p><h4 id="c.-make-it-equal">C. Make it Equal</h4><p>观察易知，<span class="math inline"><em>a</em></span> 能转化到 <span class="math inline"><em>b</em></span> 的条件是：$abk $ ，或者 <span class="math inline"><em>a</em> + <em>b</em> ≡ 0 (mod  <em>k</em>)</span> 。</p><p>考虑用 <code>map</code> 记录模意义下各数对应的原数数量，挨个检查即可。</p><p>时间复杂度 <span class="math inline">𝒪(<em>n</em>log <em>n</em>)</span>。<a href="https://codeforces.com/contest/2131/submission/333312540">Code</a>.</p><h4 id="d.-arboris-contractio">D. Arboris Contractio</h4><p>一般来说，菊花图一定有且仅有一个花心，考虑这个花心是谁。</p><p>先假定我们已确定了这个花心。那么最优的操作流程即：每次令该花心为路径一端，再依次选择初始度为 <span class="math inline">1</span> 的所有结点为路径另一端（若初始距离即为 <span class="math inline">1</span> ，可跳过该步）。</p><p>设初始度为 <span class="math inline">1</span> 的结点数量为 <span class="math inline"><em>n</em><sub>0</sub></span>，其中与花心距离为 <span class="math inline">1</span> 的结点数量为 <span class="math inline"><em>n</em><sub>1</sub></span> 。则答案为：<span class="math inline">min {<em>n</em><sub>0</sub> − <em>n</em><sub>1</sub>} = <em>n</em><sub>0</sub> − max <em>n</em><sub>1</sub></span> . 统计每个结点的 <span class="math inline"><em>n</em><sub>1</sub></span> 取 <span class="math inline">max </span> 即可。</p><p>此外，注意特判仅两个结点的 Corner Case。</p><p>时间复杂度 <span class="math inline">𝒪(<em>n</em>)</span>。<a href="https://codeforces.com/contest/2131/submission/333312540">Code</a>.</p><h4 id="e.-adjacent-xor">E. Adjacent XOR</h4><p>首先，由于每个数只能操作一次，变了之后不能恢复。因此每个数最多 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 和 <span class="math inline"><em>b</em><sub><em>i</em></sub></span> 两种形态。</p><p>先趁右侧的数还未改变，按顺序将能修改的 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 都进行修改。然后再倒序操作，在右侧的数已改变的情形下尝试修改。一旦存在修改不成的情况，判断为 <code>NO</code>，否则为 <code>YES</code>。</p><p>时间复杂度 <span class="math inline">𝒪(<em>n</em>)</span>。<a href="https://codeforces.com/contest/2131/submission/333379567">Code</a>.</p><p>题外话，一开始以为这题每个数可以进行多次操作。好像比原题更有说法一些。</p><h4 id="f.-unjust-binary-life">*F. Unjust Binary Life</h4><p>如果存在一条从 <span class="math inline">(1, 1) → (<em>x</em>, <em>y</em>)</span> 的全 <span class="math inline">0</span> 路径，则必然产生一系列连等关系最终推得 <span class="math inline"><em>a</em><sub>1</sub>...<em>a</em><sub><em>x</em></sub>, <em>b</em><sub>1</sub>...<em>b</em><sub><em>y</em></sub></span> 全部相等。比如下图中 <span class="math inline"><em>a</em><sub>1</sub> ⊕ <em>b</em><sub>1</sub> = <em>a</em><sub>2</sub> ⊕ <em>b</em><sub>1</sub> = <em>a</em><sub>2</sub> ⊕ <em>b</em><sub>2</sub> = 0</span> 可以推得：<span class="math inline"><em>a</em><sub>1</sub> = <em>b</em><sub>1</sub> = <em>a</em><sub>2</sub> = <em>b</em><sub>2</sub> = …</span> 。</p><p><img src="CF合集\pic1.png" /></p><p>所以可以得出： <span class="math display">$$f(x, y)=\min\{\sum_{i = 1}^x a_i +\sum_{i = 1}^y b_i,\quad x + y -(\sum_{i = 1}^x a_i + \sum_{i = 1}^y b_i)\}$$</span> 假定有： <span class="math display">$$\sum_{i = 1}^x a_i +\sum_{i = 1}^y b_i\leq x + y -(\sum_{i = 1}^x a_i + \sum_{i = 1}^y b_i)$$</span> 分离变量可以得到： <span class="math display">$$2\sum_{i = 1}^x a_i - x\leq y - 2\sum_{i = 1}^y b_i$$</span> 固定 <span class="math inline"><em>x</em></span>，枚举 <span class="math inline"><em>y</em></span> 。上式符合时， <span class="math inline">(<em>x</em>, <em>y</em>)</span> 对答案的贡献是 <span class="math inline">$\sum_{i = 1}^x a_i +\sum_{i = 1}^y b_i$</span> ，否则为 <span class="math inline">$x + y -(\sum_{i = 1}^x a_i + \sum_{i = 1}^y b_i)$</span>.</p><p>因此我们将所有 <span class="math inline"><em>y</em></span> 按照 <span class="math inline">$y - 2\sum_{i = 1}^y b_i$</span> 排序，对排序后的两种贡献分别做前缀和。这样在枚举 <span class="math inline"><em>x</em></span> 时便可以二分找到分界点，根据前缀和快速得到这一行对答案的总贡献。</p><p>时间复杂度 <span class="math inline">𝒪(<em>n</em>log <em>n</em>)</span>。<a href="https://codeforces.com/contest/2131/submission/334801885">Code</a>.</p><hr /><h3 id="codeforces-round-1043div.-3">2132. <a href="https://codeforces.com/contest/2132">CodeForces Round 1043（Div. 3）</a></h3><p><strong>过题：</strong> 4/8 <strong>排名：</strong> 3736 <strong>上分：</strong> –</p><p>下次碰到这种C1C2，还是先把两者的区别看清楚再决定先写哪个……</p><h4 id="a.-homework">A. Homework</h4><p>利用 <code>string</code> 可以加减的特性，直接写。<a href="https://codeforces.com/contest/2132/submission/334811830">Code</a>.</p><h4 id="b.-the-secret-number">B. The Secret Number</h4><p>直接枚举范围内的 <span class="math inline">10<sup><em>k</em></sup> + 1</span> ，找到其中是 <span class="math inline"><em>n</em></span> 因子的，那么 <span class="math inline">$\frac{n}{10^k+1}$</span> 就是一个答案。<a href="https://codeforces.com/contest/2132/submission/334827583">Code</a>.</p><h4 id="c1.-the-cunning-seller-easy-version">C1. The Cunning Seller (easy version)</h4><p>由于要求交易次数最少，对 <span class="math inline"><em>n</em></span> 进行三进制分解即可。<a href="https://codeforces.com/contest/2132/submission/334848096">Code</a>.</p><h4 id="c2.-the-cunning-seller-hard-version">C2. The Cunning Seller (hard version)</h4><p>困难版本不再要求交易次数最少，而是给定了一个上限。这意味着我们获得了一定的操作空间。</p><p>直接购买 <span class="math inline">3<sup><em>x</em></sup></span> 个的代价是 <span class="math inline">3<sup><em>x</em> + 1</sup> + <em>x</em> ⋅ 3<sup><em>x</em> − 1</sup></span>，而进行 <span class="math inline">3</span> 次购买 <span class="math inline">3<sup><em>x</em> − 1</sup></span> 个的交易的代价是 <span class="math inline">3(3<sup><em>x</em></sup> + (<em>x</em> − 1)3<sup><em>x</em> − 2</sup>)</span> ，也就是 <span class="math inline">3<sup><em>x</em> + 1</sup> + (<em>x</em> − 1)3<sup><em>x</em> − 1</sup></span> 。比直接购买所需代价少 <span class="math inline">3<sup><em>x</em> − 1</sup></span>。</p><hr /><h3 id="codeforces-round-1044div.-2">2133. <a href="https://codeforces.com/contest/2133">CodeForces Round 1044（Div. 2）</a></h3><p><strong>过题：</strong> 4/8 <strong>排名：</strong> 1139 <strong>上分：</strong> + 70 (1675)</p><p>前半程直呼从未有过如此美妙的开局，丝滑地开完了ABCD。然而D瞬间WA#2，临近尾声才发现是交错代码了，太变态了。如果正常交上去了这把能上很多分。</p><h4 id="a.-redstone">A. Redstone?</h4><p>除了头尾的数都会被约掉，所以要使得乘积为 <span class="math inline">1</span>，只需找到两个相等的数做头尾。</p><p>时间复杂度 <span class="math inline">𝒪(<em>n</em>)</span> 。<a href="https://codeforces.com/contest/2133/submission/335317695">Code</a>.</p><h4 id="b.-villagers">B. Villagers</h4><p>揣摩样例可知，两两配对完成后再进行合并代价就是 <span class="math inline">0</span> 了，这是很优的。</p><p>要使得配对这个过程代价最小，做法就是先倒序排序，然后 <span class="math inline">(<em>g</em><sub>1</sub>, <em>g</em><sub>2</sub>), (<em>g</em><sub>3</sub>, <em>g</em><sub>4</sub>)…</span> 相邻的配对。</p><p>正确性似乎并不是太好说明，此处就略去了。</p><p>时间复杂度 <span class="math inline">𝒪(<em>n</em>log <em>n</em>)</span> 。<a href="https://codeforces.com/contest/2133/submission/335328351">Code</a>.</p><h4 id="c.-the-nether">C. The Nether</h4><hr /><h3 id="codeforces-round-1045div.-2">2134. <a href="https://codeforces.com/contest/2134">CodeForces Round 1045（Div. 2）</a></h3><p><strong>过题：</strong> 3/6 <strong>排名：</strong> 3829 <strong>上分：</strong> - 34 (1641)</p><p>还是自己太菜了。BC若只题写写写半天，D题又死活看不出结论，活该掉分。</p><h4 id="a.-painting-with-two-colors">A. Painting With Two Colors</h4><h4 id="b.-add-0-or-k">B. Add 0 or K</h4><h4 id="c.-even-larger">C. Even Larger</h4><hr /><h3 id="codeforces-round-1046div.-2">2136. <a href="https://codeforces.com/contest/2136">CodeForces Round 1046（Div. 2）</a></h3><p><strong>过题：</strong> 5/7 <strong>排名：</strong> 537 <strong>上分：</strong> +79 (1720)</p><p>感觉是近期发挥最好的一场，除了D代码实现得太慢，其他题都在合适的时间内想到正解并码出。交互题是对的，建议CF多多的出。</p><h4 id="a.-in-the-dream">A. In the Dream</h4><p>显然如果一方在半场内进了 <span class="math inline"><em>a</em></span> 球，且没有被连续打进 <span class="math inline">3</span> 球，则另一方至多进了 <span class="math inline">2(<em>a</em> + 1)</span> 球。因此只需判断上下半场是否都没有出现超出的情况。</p><p>时间复杂度 <span class="math inline">𝒪(1)</span>。<a href="https://codeforces.com/contest/2136/submission/335948108">Code</a>.</p><h4 id="b.-like-the-bitset">B. Like the Bitset</h4><p>首先发现，挑选一个满足 <span class="math inline"><em>s</em><sub><em>i</em></sub> = 0</span> 的 <span class="math inline"><em>i</em></span> 放入 <span class="math inline"><em>n</em></span> ，即同时满足了区间 <span class="math inline">[<em>i</em>−<em>k</em>+1,<em>i</em>+<em>k</em>−1]</span> 内所有的要求。</p><p>试着按照这个思路来让合法区间覆盖满区间 <span class="math inline">[1,<em>n</em>]</span>。操作流程为每次从当前位置向右跳 <span class="math inline"><em>k</em></span> 格，然后往回找到最近的 <span class="math inline"><em>s</em><sub><em>i</em></sub> = 0</span> 处填入当前所剩的最大值，循环这一流程。如果直到退回上一个位置还未找到 <span class="math inline">0</span> 则判断为无解。正确性证明略。</p><p>在这一流程中，每个下标至多被访问一次。时间复杂度 <span class="math inline">𝒪(<em>n</em>)</span> 。<a href="https://codeforces.com/contest/2136/submission/335969855">Code</a>.</p><h4 id="c.-against-the-difference">C. Against the Difference</h4><p>首先对于每一个 <span class="math inline"><em>i</em></span>，设这是 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 第 <span class="math inline"><em>k</em></span> 次出现。如果 <span class="math inline"><em>k</em> &gt;  = <em>a</em><sub><em>i</em></sub></span>，令 <span class="math inline"><em>p</em><em>r</em><em>e</em><sub><em>i</em></sub></span> 为 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 第 <span class="math inline"><em>k</em> − <em>a</em><sub><em>i</em></sub> + 1</span> 次出现的位置；否则设置为默认值 <span class="math inline"> − 1</span>。这一过程可以利用二维 <code>vector</code> 实现。</p><p>用 <span class="math inline"><em>f</em><sub><em>i</em></sub></span> 表示区间 <span class="math inline">[1,<em>i</em>]</span> 内，整洁序列的最大长度。于是有如下转移： <span class="math display"><em>f</em><sub><em>i</em></sub> = max (<em>f</em><sub><em>i</em> − 1</sub>, <em>f</em><sub><em>p</em><em>r</em><em>e</em><sub><em>i</em></sub> − 1</sub> + <em>a</em><sub><em>i</em></sub>)</span> 其中前者代表不选 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 的方案，后者表示选 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 的方案。</p><p>线性扫描一次即可。时间复杂度 <span class="math inline">𝒪(<em>n</em>)</span> 。<a href="https://codeforces.com/contest/2136/submission/335989110">Code</a>.</p><h4 id="d.-for-the-champion">D. For the Champion</h4><p>首先注意到对于极大的 <span class="math inline"><em>X</em></span> 和 <span class="math inline"><em>Y</em></span> ，点 <span class="math inline">(<em>X</em>, <em>Y</em>)</span> 与锚点 <span class="math inline">(<em>x</em><sub><em>i</em></sub>, <em>y</em><sub><em>i</em></sub>)</span> 间的曼哈顿距离 <span class="math inline">|<em>X</em> − <em>x</em><sub><em>i</em></sub>| + |<em>Y</em> − <em>y</em><sub><em>i</em></sub>|</span> 可以直接去绝对值，写作 <span class="math inline">(<em>X</em> + <em>Y</em>) − (<em>x</em><sub><em>i</em></sub> + <em>y</em><sub><em>i</em></sub>)</span> 。</p><p>设机器人初始位置为 <span class="math inline">(<em>a</em>, <em>b</em>)</span> ，当我们将其移至足够大的 <span class="math inline">(<em>a</em> + <em>M</em>, <em>b</em> + <em>N</em>)</span> 之后发起询问，得到的 <span class="math inline">min<sub>1 ≤ <em>i</em> ≤ <em>n</em></sub>(<em>a</em> + <em>b</em> + <em>M</em> + <em>N</em> − (<em>x</em><sub><em>i</em></sub> + <em>y</em><sub><em>i</em></sub>))</span> 即为 <span class="math inline"><em>a</em> + <em>b</em> + <em>M</em> + <em>N</em> − max<sub>1 ≤ <em>i</em> ≤ <em>n</em></sub>(<em>x</em><sub><em>i</em></sub> + <em>y</em><sub><em>i</em></sub>)</span> 。<span class="math inline"><em>M</em> + <em>N</em></span> 是已知值，而 <span class="math inline">max </span> 下的内容可以提前处理得到。于是我们可以计算得到 <span class="math inline"><em>a</em> + <em>b</em></span> 的值。</p><p>接着我们移动到 <span class="math inline">(<em>a</em> + <em>M</em>, <em>b</em> − <em>G</em>)</span> ，其中 <span class="math inline"><em>b</em> − <em>G</em> ≤ min <em>y</em><sub><em>i</em></sub></span> 。便可以得到 <span class="math inline">min<sub>1 ≤ <em>i</em> ≤ <em>n</em></sub>(<em>a</em> − <em>b</em> + <em>M</em> + <em>G</em> − (<em>x</em><sub><em>i</em></sub> − <em>y</em><sub><em>i</em></sub>))</span> ，同理可以计算得到 <span class="math inline"><em>a</em> − <em>b</em></span>。</p><p>两相联立便解出了 <span class="math inline">(<em>a</em>, <em>b</em>)</span> 的值。</p><p>由于题目给出了步长的限制，还需要检验这些操作能否在 <span class="math inline">10</span> 步内完成。<span class="math inline"> − 10<sup>9</sup> ≤ <em>a</em>, <em>b</em> ≤ 10<sup>9</sup></span> ，且 <span class="math inline"><em>a</em> + <em>M</em>, <em>b</em> + <em>N</em> ≥ 10<sup>9</sup></span> 。可以得到 <span class="math inline"><em>M</em>, <em>N</em> ≤ 2 × 10<sup>9</sup></span> 。因此第一阶段我们直接以 <span class="math inline">10<sup>9</sup></span> 的步长向上两次，再向右两次即可保证在所有锚点的右上方。</p><p>此时坐标为 <span class="math inline">(<em>a</em> + 2 × 10<sup>9</sup>, <em>b</em> + 2 × 10<sup>9</sup>)</span> ，横纵坐标的范围都是 <span class="math inline">[10<sup>9</sup>, 3 × 10<sup>9</sup>]</span> 。再以 <span class="math inline">10<sup>9</sup></span> 的步长向下走四步即可保证在所有锚点的右下方。总步数 <span class="math inline">8</span> 步，符合要求。<a href="https://codeforces.com/contest/2136/submission/336018954">Code</a>.</p><h4 id="f1.-from-the-unknown-easy-version">F1. From the Unknown (Easy Version)</h4><p>一共只能询问两次，所以最好每次询问都能获得有效的信息。</p><p>一个很自然的想法是直接询问一次 <code>? 100000 1 1 1...1 1</code> 来获得行长的大致范围（假设第一次的回答是 <span class="math inline"><em>p</em></span> 行，可知每行长度处于 <span class="math inline">$[\frac{N}{p},\frac{N}{p - 1})$</span> 范围内。），再根据范围构造一个输入序列获得精确值。</p><p>之所以说这是自然的，是因为如果输入的某个单词长度超过了行长，我们将不会得到任何有效信息。这意味着第一次输入时，词长必须全部足够小。</p><p>设行长可能值最小为 <span class="math inline"><em>L</em></span>，最大为 <span class="math inline"><em>R</em></span> 。第二次询问的构造如下：<code>? 2*(R - L) L 1 L 2 L 3...L R - L</code> 。当 <span class="math inline"><em>L</em> + <em>i</em> ≤ <em>l</em><em>e</em><em>n</em></span> 时， <span class="math inline"><em>L</em></span> 和 <span class="math inline"><em>i</em></span> 位列同一行；此后分列两行。因此，如果总行数为 <span class="math inline"><em>x</em></span> ，行长就是 <span class="math inline">2(<em>R</em> − <em>L</em>) − <em>x</em> + <em>L</em></span>。</p><p>另外，特判一下 <span class="math inline"><em>L</em> = <em>R</em></span> 的情况，避免出现 <span class="math inline"><em>n</em> = 0</span> 的不合法询问。</p><p>总的来说，是道不错的构造题。<a href="https://codeforces.com/contest/2136/submission/336042071">Code</a>.</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暑训3&amp;4 补题</title>
    <link href="/2025/07/25/%E6%9A%91%E8%AE%AD3&amp;4%20%E8%A1%A5%E9%A2%98/"/>
    <url>/2025/07/25/%E6%9A%91%E8%AE%AD3&amp;4%20%E8%A1%A5%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="c">C</h1><p><strong>题目大意：</strong> 给定一个由小写字母构成的字符串和若干次修改操作。在每次修改后，求其符合以下要求的最大子串长度：出现奇数次的字母有奇数个，出现非零偶数次的字母有偶数个。</p><p><strong>难度：</strong> ~2000 <strong>知识点：</strong> 线段树，分类讨论</p><p>观察可以得到，要求等价于：串长和字符集大小都为奇数。这一点可以通过枚举串长和字符集大小各自的奇偶性来验证。</p><p>然后进行分类讨论。</p><ul><li><p>当字符集大小为奇数时：</p><ul><li><p>如果串长为奇数：直接取原串即可。</p></li><li><p>如果串长为偶数：</p><ul><li><p>如果首或尾字母出现了超过一次，那么删去它不改变字符集大小，但让串长变为奇数，符合了要求。</p></li><li><p>如果首尾字母都只出现了一次，我们正序和倒序分别找到第一个出现多次的字母。为了方便下文叙述，我们不妨设原串形如 <code>[abcd X ... Y uvw]</code>，其中小/大写字母分别代表出现一/多次的字母。</p><p>那么如果我们只删去头尾的若干字母，字符集大小和串长的奇偶性一定同时改变，不可能同时变为奇数。因此，我们至少需要删到串中的 <code>X</code> 或 <code>Y</code> 。</p><ul><li>如果删去的串长为奇数（如 <code>[abcdX]</code>），则剩下的串长和字符集大小都为奇数，符合了要求。</li><li>如果删去的串长为偶数（如 <code>[Yuvw]</code>），则剩下的串长和字符集大小都为偶数，我们再删去另一端的一个字母即可符合要求。</li></ul><p>分别求解删除两端的情形后，对答案取较大值即可。</p></li></ul></li></ul></li><li><p>当字符集大小为偶数时：</p><p>我们可以这样做：对于每种字符，求不含它的极大子串。可以证明，所有极长子串中最长的一个的字符集大小一定就是原串字符集大小减一，是一个奇数。</p><p>证明很显然。记原串形如 <code>...A[...]A..</code> ，<code>[...]</code> 是最大极长子串，不包含的字母是 <code>A</code>。</p><p>使用反证法，假设该子串字符集大小不为原串字符集大小减一，说明一定存在某不为 <code>A</code> 的字母不在该子串中，记为 <code>B</code>。无论原串的形式为 <code>..B...A[...]A..</code> 还是 <code>..B..A[...]A..B..</code> ，不含 <code>B</code> 的极大子串一定比不含 <code>A</code> 的极大子串更长，这与 <code>[...]</code> 是最大极长子串相矛盾。因此假设不成立，证明完成。</p><p>由于至少需要删去一种字符，最终的答案一定不长于最大极长子串，此处设该最大极长子串长度为 <span class="math inline"><em>L</em></span>。</p><ul><li><p>如果最大极长子串串长为奇数，直接取，答案就是 <span class="math inline"><em>L</em></span>。</p></li><li><p>如果最大极长子串串长为偶数，与第一类讨论类似地：</p><ul><li><p>如果子串首或尾字母在串内出现了超过一次，那么删去它不改变字符集大小，但让串长变为奇数，符合了要求。答案是 <span class="math inline"><em>L</em> − 1</span>。</p></li><li><p>如果首尾字母都只出现了一次，记原串形如 <code>...A [abc X ... Y uvw] A...</code>，其中小/大写字母分别代表在子串内出现一/多次的字母，<code>[]</code> 内为最大极长子串。</p><p>观察后可知，<code>A</code> 右侧为 <code>a</code> 或右边界。否则 <code>a</code> 分割成的子串将长于最大极长子串。该性质可以向左右推广，也就是说原串一定是 <code>...uvw A [abc X ... Y uvw] A abc...</code> 的子串。</p><p>我们考虑 <code>...A(abc X ... Y uvw A)...</code> 括号内的串，初始字符集大小为偶数，串长为奇数。</p><p>试着往右侧移动括号范围。括号内最左侧仍为单次出现的字母时，括号内子串奇偶性质保持不变。</p><p>当最左侧为多次出现字母时（如 <code>...A abc (X ... Y uvw A abc)...</code> 所示）我们直接删去最左侧的 <code>X</code> 和最右侧的 <code>c</code>，剩下的串长和字符集大小都为奇数。这个奇数是不大于最大极长子串长度的最大奇数，是最优值。向左侧移动同理。只要有一侧能移到，答案就是 <span class="math inline"><em>L</em> − 1</span>。这个过程中移动不超过 <span class="math inline">26</span> 次。</p><p>移不到的情况形如 <code>vw A ab(c X ... Y uvw A ab)</code>，子串两侧的部分长度很短。</p><p>由于初始时 <code>()</code> 内字符集大小为偶数，串长为奇数。而删单次出现字符会使字符集大小和串长的奇偶性同时改变，不能使两者同时变为奇数。必须删多次出现的字母。</p><p>以上串为例，再删去括号内的 <code>cX</code> 后，剩下部分的字符集大小和串长的奇偶性就相同了。如果是偶数就再删去另一侧的一个单次出现字母即可。求解只需要找到 <code>X</code> 和 <code>Y</code> 的位置，根据其到另一侧的距离计算即可。</p></li></ul></li></ul><p>可以看见，解决问题的关键就是维护当前最大极长子串。</p><p>我们开 <span class="math inline">26</span> 个线段树，维护各字母对应的极长子串。将当前字母视为 <span class="math inline">1</span>，其他字母视为 <span class="math inline">0</span>，则问题转化为求最长的连续零段。</p><p>线段树内每个节点维护以下信息：【1】区间内最长连续零段的长度；【2】区间内最长连续零段的起始位置【3】从区间最左端起的连续零段的长度；【4】在区间最右端止的连续零段的长度。【5】区间和。</p><p>其中维护【5】是为了快速得到某区间内某字母是否多次出现。</p></li></ul><p>Code：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int, int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt;= b; i++)</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, q, cnt;<br><span class="hljs-type">int</span> Ans;<br>string ss, s;<br><br>map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; mp;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">seg_tree</span> &#123;<br><br>    <span class="hljs-type">char</span> id;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>        <span class="hljs-type">int</span> mx, lmx, rmx, pos, val;<br>    &#125; t[N &lt;&lt; <span class="hljs-number">2</span>];<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        t[u].val = t[u &lt;&lt; <span class="hljs-number">1</span>].val + t[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].val;<br>        <span class="hljs-type">int</span> mmx = t[u &lt;&lt; <span class="hljs-number">1</span>].rmx + t[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].lmx;<br>        t[u].mx = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(t[u &lt;&lt; <span class="hljs-number">1</span>].mx, t[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].mx), mmx);<br>        t[u].lmx = t[u &lt;&lt; <span class="hljs-number">1</span>].lmx;<br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (t[u &lt;&lt; <span class="hljs-number">1</span>].lmx == mid - l + <span class="hljs-number">1</span>) t[u].lmx += t[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].lmx;<br>        t[u].rmx = t[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].rmx;<br>        <span class="hljs-keyword">if</span> (t[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].rmx == r - mid) t[u].rmx += t[u &lt;&lt; <span class="hljs-number">1</span>].rmx;<br>        <span class="hljs-keyword">if</span> (t[u].mx == mmx) t[u].pos = mid - t[u &lt;&lt; <span class="hljs-number">1</span>].rmx + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t[u].mx == t[u &lt;&lt; <span class="hljs-number">1</span>].mx) t[u].pos = t[u &lt;&lt; <span class="hljs-number">1</span>].pos;<br>        <span class="hljs-keyword">else</span> t[u].pos = t[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].pos;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            <span class="hljs-keyword">if</span> (id == s[l]) &#123;<br>                t[u].val = <span class="hljs-number">1</span>;<br>                t[u].mx = t[u].lmx = t[u].rmx = <span class="hljs-number">0</span>;<br>                t[u].pos = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                t[u].val = <span class="hljs-number">0</span>;<br>                t[u].mx = t[u].lmx = t[u].rmx = <span class="hljs-number">1</span>;<br>                t[u].pos = l;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid);<br>        <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-built_in">pushup</span>(u, l, r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r &amp;&amp; l == x) &#123;<br>            <span class="hljs-keyword">if</span> (op) &#123;<br>                t[u].val = <span class="hljs-number">0</span>;<br>                t[u].mx = t[u].lmx = t[u].rmx = <span class="hljs-number">1</span>;<br>                t[u].pos = l;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                t[u].val = <span class="hljs-number">1</span>;<br>                t[u].mx = t[u].lmx = t[u].rmx = <span class="hljs-number">0</span>;<br>                t[u].pos = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid, x, op);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, x, op);<br>        <span class="hljs-built_in">pushup</span>(u, l, r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> t[u].val;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>, mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (L &lt;= mid) ret += <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R);<br>        <span class="hljs-keyword">if</span> (R &gt; mid) ret += <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>&#125; tree[<span class="hljs-number">26</span>];<br><br><span class="hljs-function">pii <span class="hljs-title">fnd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> mxl = <span class="hljs-number">0</span>, mxr = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, <span class="hljs-number">25</span>) &#123;<br>        <span class="hljs-type">int</span> mxi = tree[i].t[<span class="hljs-number">1</span>].mx, p = tree[i].t[<span class="hljs-number">1</span>].pos;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-number">1</span> &amp;&amp; p + mxi - <span class="hljs-number">1</span> == n) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (mxi &gt; mxr - mxl + <span class="hljs-number">1</span>) &#123;<br>            mxl = p; mxr = p + mxi - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(mxl, mxr);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cnt &amp; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (mp[s[<span class="hljs-number">1</span>]] &gt; <span class="hljs-number">1</span> || mp[s[n]] &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> ix = <span class="hljs-number">0</span>, iy = <span class="hljs-number">0</span>, ans1, ans2;<br>                <span class="hljs-keyword">while</span> (ix + <span class="hljs-number">1</span> &lt;= n &amp;&amp; mp[s[ix + <span class="hljs-number">1</span>]] == <span class="hljs-number">1</span>) ix++;<br>                <span class="hljs-keyword">while</span> (n - iy &gt;= <span class="hljs-number">1</span> &amp;&amp; mp[s[n - iy]] == <span class="hljs-number">1</span>) iy++;<br>                <span class="hljs-keyword">if</span> (ix &amp; <span class="hljs-number">1</span>) ans1 = n - ix - <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">else</span> ans1 = n - ix - <span class="hljs-number">1</span>; <br>                <span class="hljs-keyword">if</span> (iy &amp; <span class="hljs-number">1</span>) ans2 = n - iy - <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">else</span> ans2 = n - iy - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(ans1, ans2);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        pii tt = <span class="hljs-built_in">fnd</span>();<br>        <span class="hljs-type">int</span> len = tt.second - tt.first + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (len &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> len;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> l = tt.first, r = tt.second;<br>            <span class="hljs-keyword">if</span> (tree[s[l] - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r) &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> len - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (tree[s[r] - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r) &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> len - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> cntl = <span class="hljs-number">0</span>, cntr = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (l + cntl &lt;= r &amp;&amp; tree[s[l + cntl] - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r) == <span class="hljs-number">1</span>) cntl++;<br>            <span class="hljs-keyword">while</span> (r - cntr &gt;= l &amp;&amp; tree[s[r - cntr] - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r) == <span class="hljs-number">1</span>) cntr++;<br>            <span class="hljs-keyword">if</span> (l - <span class="hljs-number">2</span> &gt;= cntr) <span class="hljs-keyword">return</span> len - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (n - r - <span class="hljs-number">1</span> &gt;= cntl) <span class="hljs-keyword">return</span> len - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> ans1 = n - (cntl + l);<br>            <span class="hljs-keyword">if</span> (ans1 % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) ans1 -= <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> ans2 = r - cntr - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (ans2 % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) ans2 -= <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(ans1, ans2);<br>        &#125; <br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; q &gt;&gt; ss;<br>    s = <span class="hljs-string">&#x27; &#x27;</span> + ss;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, <span class="hljs-number">25</span>) &#123;<br>        tree[i].id = i + <span class="hljs-string">&#x27;a&#x27;</span>;<br>        tree[i].<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        <span class="hljs-keyword">if</span> (mp[s[i]] == <span class="hljs-number">0</span>) cnt += <span class="hljs-number">1</span>;<br>        mp[s[i]] += <span class="hljs-number">1</span>;<br>    &#125;<br>    Ans = <span class="hljs-built_in">solve</span>();<br>    cout &lt;&lt; Ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">int</span> x; <span class="hljs-type">char</span> c; cin &gt;&gt; x &gt;&gt; c;<br>        <span class="hljs-keyword">if</span> (s[x] == c) &#123; cout &lt;&lt; Ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-keyword">continue</span>; &#125;<br>        tree[c - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, x, <span class="hljs-number">0</span>);<br>        tree[s[x] - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, x, <span class="hljs-number">1</span>);<br>        mp[s[x]] -= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (mp[s[x]] == <span class="hljs-number">0</span>) cnt -= <span class="hljs-number">1</span>;<br>        s[x] = c;<br>        mp[s[x]] += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (mp[s[x]] == <span class="hljs-number">1</span>) cnt += <span class="hljs-number">1</span>;<br>        Ans = <span class="hljs-built_in">solve</span>();<br>        cout &lt;&lt; Ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>25暑训</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暑训5&amp;6 补题</title>
    <link href="/2025/07/25/%E6%9A%91%E8%AE%AD5&amp;6%20%E8%A1%A5%E9%A2%98/"/>
    <url>/2025/07/25/%E6%9A%91%E8%AE%AD5&amp;6%20%E8%A1%A5%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="h">5H</h1><blockquote><p><strong>题目大意：</strong> 给定 <span class="math inline"><em>n</em>, <em>m</em>, <em>s</em>, <em>t</em>, {<em>a</em><sub><em>n</em></sub>}, {<em>k</em><sub><em>n</em></sub>}, {<em>b</em><sub><em>n</em></sub>}, {<em>c</em><sub><em>n</em></sub>}</span>。 每次操作，选定任一非 <span class="math inline">0</span> 的 <span class="math inline"><em>b</em><sub><em>i</em></sub> → max {<em>b</em><sub><em>i</em></sub> − <em>p</em>, 0}</span> ，若此后 <span class="math inline"><em>b</em><sub><em>i</em></sub> = 0</span>， <span class="math inline"><em>a</em><sub><em>i</em></sub> → max {<em>a</em><sub><em>i</em></sub> − <em>c</em><sub><em>i</em></sub>, 0}</span>. 然后选择一项：</p><ul><li>使第一个非 <span class="math inline">0</span> 的 <span class="math inline"><em>a</em><sub><em>i</em></sub> → max {<em>a</em><sub><em>i</em></sub> − <em>m</em>, 0}</span>。若此后 <span class="math inline"><em>a</em><sub><em>i</em></sub> = 0</span>， <span class="math inline"><em>m</em> → <em>m</em> + <em>k</em><sub><em>i</em></sub></span>.</li><li><span class="math inline"><em>c</em><em>n</em><em>t</em> → <em>c</em><em>n</em><em>t</em> + <em>m</em></span> （<span class="math inline"><em>c</em><em>n</em><em>t</em></span> 初始为 <span class="math inline">0</span>） 求 <span class="math inline">min <em>p</em></span> ，使得存在一种方案使得 <span class="math inline"><em>t</em></span> 次操作内可能使 <span class="math inline"><em>c</em><em>n</em><em>t</em> ≥ <em>s</em></span>.</li></ul></blockquote><blockquote><p><strong>知识点：</strong> 二分，dp</p></blockquote><p>这题的难度相当一部分来自于冗长的题面，我费了老大劲才把原题面中 <strong>Civilization VI</strong> 的元素换成了数学语言。赛时也是被这题面吓到以为是大模拟。</p><p>首先显然可以二分答案，将问题转化成给定 <span class="math inline"><em>p</em></span> ，判定方案存在性。</p><p>考虑 <span class="math inline"><em>d</em><em>p</em></span> 来做。令 <span class="math inline"><em>d</em><em>p</em><sub><em>i</em>, <em>j</em>, <em>l</em></sub></span> 表示前 <span class="math inline"><em>i</em></span> 次操作中，已经使 <span class="math inline"><em>a</em><sub><em>j</em></sub> = 0</span>，选择了 <span class="math inline"><em>l</em></span> 次 <span class="math inline"><em>b</em><sub>{<em>j</em> + 1...<em>n</em>}</sub></span> 中元素的情况下 <span class="math inline"><em>c</em><em>n</em><em>t</em></span> 的最大值。</p><p>设 <span class="math inline">$sum_i = m+\sum_{j=1}^{i}k_j$</span> ，有如下三种转移：</p><ul><li><p>第 <span class="math inline"><em>i</em></span> 次操作选择增加 <span class="math inline"><em>c</em><em>n</em><em>t</em></span>： <span class="math display"><em>d</em><em>p</em><sub><em>i</em>, <em>j</em>, <em>l</em></sub> + <em>s</em><em>u</em><em>m</em><sub><em>j</em></sub> → <em>d</em><em>p</em><sub><em>i</em> + 1, <em>j</em>, <em>l</em> + 1</sub></span></p></li><li><p>通过若干次操作使 <span class="math inline"><em>a</em><sub><em>j</em> + 1</sub> → 0</span>（未触发 <span class="math inline"><em>a</em><sub><em>i</em></sub> → max {<em>a</em><sub><em>i</em></sub> − <em>c</em><sub><em>i</em></sub>, 0}</span>）： <span class="math display">$$dp_{i,j,l}\to dp_{i+\left \lceil \frac{a_{j+1}}{sum_j} \right \rceil,j+1, l+\left \lceil \frac{a_{j+1}}{sum_j} \right \rceil}$$</span></p></li><li><p>通过若干次操作使 <span class="math inline"><em>a</em><sub><em>j</em> + 1</sub> → 0</span>（触发 <span class="math inline"><em>a</em><sub><em>i</em></sub> → max {<em>a</em><sub><em>i</em></sub> − <em>c</em><sub><em>i</em></sub>, 0}</span>）： <span class="math display">$$dp_{i,j,l}\to dp_{i+ \left \lceil \frac{a_{j+1} - c_{j+1}}{sum_j} \right \rceil,j+1,l-\left \lceil \frac{b_{j+1}}{p} \right \rceil + \left \lceil \frac{a_{j+1} - c_{j+1}}{sum_j} \right \rceil}$$</span> 其中 <span class="math inline">$l-\left \lceil \frac{b_{j+1}}{p} \right \rceil + \left \lceil \frac{a_{j+1} - c_{j+1}}{sum_j} \right \rceil \geq 0$</span> 。</p></li></ul><p>存在某 <span class="math inline"><em>d</em><em>p</em><sub><em>i</em>, <em>j</em>, <em>l</em></sub> ≥ <em>s</em></span> 则方案存在。</p><p>注意写好转移时的边界条件，并特判 <span class="math inline"><em>p</em> = 0</span> 的情况即可。</p><p>时间复杂度 <span class="math inline">𝒪(<em>t</em><sup>2</sup><em>n</em>log <em>b</em>)</span> ，可以通过本题。</p><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOR(i,a,b) for (int i = a; i &lt;= b; i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ceiL(x, y) ((x - 1) / y + 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">105</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = LONG_LONG_MAX;<br><br><span class="hljs-type">int</span> n, m, s, t;<br><span class="hljs-type">int</span> sumk[N];<br><br><span class="hljs-type">int</span> a[N], k[N], b[N], c[N];<br><br><span class="hljs-type">int</span> dp[N][N][N];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, t) <span class="hljs-built_in">FOR</span>(j, <span class="hljs-number">0</span>, n) <span class="hljs-built_in">FOR</span>(l, <span class="hljs-number">0</span>, t) dp[i][j][l] = -INF;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, t) &#123;<br>        <span class="hljs-built_in">FOR</span>(j, <span class="hljs-number">0</span>, n) &#123;<br>            <span class="hljs-built_in">FOR</span>(l, <span class="hljs-number">0</span>, i) &#123;<br>                <span class="hljs-keyword">if</span> (dp[i][j][l] == -INF) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (dp[i][j][l] &gt;= s) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; N &amp;&amp; l + <span class="hljs-number">1</span> &lt; N) dp[i + <span class="hljs-number">1</span>][j][l + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-number">1</span>][j][l + <span class="hljs-number">1</span>], dp[i][j][l] + sumk[j]);<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j]) &lt; N &amp;&amp; j + <span class="hljs-number">1</span> &lt; N &amp;&amp; l + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j]) &lt; N)<br>                    dp[i + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j])][j + <span class="hljs-number">1</span>][l + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j])] <br>                    = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j])][j + <span class="hljs-number">1</span>][l + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j])], dp[i][j][l]);<br>                <span class="hljs-type">int</span> newl = l - <span class="hljs-built_in">ceiL</span>(b[j + <span class="hljs-number">1</span>], x) + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>] - c[j + <span class="hljs-number">1</span>], sumk[j]);<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>] - c[j + <span class="hljs-number">1</span>], sumk[j]) &lt; N &amp;&amp; j + <span class="hljs-number">1</span> &lt; N &amp;&amp; newl &gt;= <span class="hljs-number">0</span> &amp;&amp; newl &lt; N) <br>                    dp[i + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>] - c[j + <span class="hljs-number">1</span>], sumk[j])][j + <span class="hljs-number">1</span>][newl]<br>                    = <span class="hljs-built_in">max</span>(dp[i][j][l], dp[i + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>] - c[j + <span class="hljs-number">1</span>], sumk[j])][j + <span class="hljs-number">1</span>][newl]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; m &gt;&gt; s &gt;&gt; t;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; a[i] &gt;&gt; k[i] &gt;&gt; b[i] &gt;&gt; c[i];<br>    sumk[<span class="hljs-number">0</span>] = m;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) sumk[i] = sumk[i - <span class="hljs-number">1</span>] + k[i];<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, N - <span class="hljs-number">1</span>) <span class="hljs-built_in">FOR</span>(j, <span class="hljs-number">0</span>, N - <span class="hljs-number">1</span>) <span class="hljs-built_in">FOR</span>(k, <span class="hljs-number">0</span>, N - <span class="hljs-number">1</span>) dp[i][j][k] = -INF;<br>    <span class="hljs-comment">// 先判断 p = 0 行不行，只有前两种转移</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, t) &#123;<br>        <span class="hljs-built_in">FOR</span>(j, <span class="hljs-number">0</span>, n) &#123;<br>            <span class="hljs-built_in">FOR</span>(l, <span class="hljs-number">0</span>, i) &#123;<br>                <span class="hljs-keyword">if</span> (dp[i][j][l] == -INF) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (dp[i][j][l] &gt;= s) &#123; cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; N &amp;&amp; l + <span class="hljs-number">1</span> &lt; N) dp[i + <span class="hljs-number">1</span>][j][l + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-number">1</span>][j][l + <span class="hljs-number">1</span>], dp[i][j][l] + sumk[j]);<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j]) &lt; N &amp;&amp; j + <span class="hljs-number">1</span> &lt; N &amp;&amp; l + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j]) &lt; N)<br>                    dp[i + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j])][j + <span class="hljs-number">1</span>][l + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j])] <br>                    = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j])][j + <span class="hljs-number">1</span>][l + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j])], dp[i][j][l]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> L = <span class="hljs-number">1</span>, R = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (L &lt; R) &#123;<br>        <span class="hljs-type">int</span> mid = (L + R) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) R = mid;<br>        <span class="hljs-keyword">else</span> L = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check</span>(L)) cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; L &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="l">5L</h1><blockquote><p><strong>题目大意：</strong> 现有 <span class="math inline"><em>a</em> = 0</span> 和 <span class="math inline"><em>b</em> = <em>z</em></span>，目标为使 <span class="math inline"><em>a</em> = <em>n</em></span>。你每次尝试有 <span class="math inline"><em>p</em></span> 的概率成功使 <span class="math inline"><em>a</em> → <em>a</em> + 1</span> ，另有 <span class="math inline">1 − <em>p</em></span> 的概率失败。 失败时，若 <span class="math inline"><em>b</em> &gt; 0, <em>b</em> → <em>b</em> − 1</span>，否则 <span class="math inline"><em>a</em> → 0</span>。对于每个 <span class="math inline"><em>z</em> ∈ [0, <em>m</em>]</span>，求期望尝试次数。</p></blockquote><blockquote><p><strong>知识点：</strong> 期望dp</p></blockquote><p>将总期望尝试次数拆成 <span class="math inline"><em>b</em> &gt; 0</span> 和 <span class="math inline"><em>b</em> = 0</span> 两部分（可能在第一部分中已经达成目标，那么第二部分就没有被经过）</p><p>先考虑 <span class="math inline"><em>b</em> &gt; 0</span> 的情形。考虑二维状态 <span class="math inline">(<em>i</em>, <em>j</em>)</span> ，表示当前 <span class="math inline"><em>a</em> = <em>i</em></span>，<span class="math inline"><em>b</em> = <em>z</em> − <em>j</em></span>。初始状态为 <span class="math inline">(0, 0)</span> ，目标状态为 <span class="math inline">(<em>n</em>, ?)</span> 。状态转移为：有 <span class="math inline"><em>p</em></span> 的概率 <span class="math inline">(<em>i</em>, <em>j</em>) → (<em>i</em> + 1, <em>j</em>)</span> ，<span class="math inline">(1 − <em>p</em>)</span> 的概率 <span class="math inline">(<em>i</em>, <em>j</em>) → (<em>i</em>, <em>j</em> + 1)</span>。由于不会走回头路，第一部分的期望步数就是所有状态的概率之和。</p><p>假设 <span class="math inline"><em>P</em><sub><em>i</em>, <em>j</em></sub></span> 表示经过某状态的概率，可得方程： <span class="math display">$$P_{i,j}=\begin{cases}1 &amp;\text {if } i, j = 0\\p P_{i - 1, j} &amp;\text{if } j = 0\\(1-p)P_{i, j - 1} &amp; \text{if } i = 0\\pP_{i - 1,j}+(1 - p)P_{i,j - 1} &amp; \text{if } i, j\neq 0\end{cases}$$</span> 设 <span class="math inline">$S_j = \sum_{i = 0}^{n - 1}P_{i, j}$</span>，由于 <span class="math inline"><em>P</em><sub><em>i</em>, <em>j</em></sub> = <em>p</em><em>P</em><sub><em>i</em> − 1, <em>j</em></sub> + (1 − <em>p</em>)<em>P</em><sub><em>i</em>, <em>j</em> − 1</sub></span> ， 累加可得： <span class="math display">$$\sum_{i = 0} ^ {n - 1} P_{i, j} = p\sum_{i = 0} ^{n - 1}P_{i - 1, j} + (1 - p) \sum_{i = 0}^{n - 1} P_{i, j - 1}$$</span> 整理之后可得： <span class="math display">$$S_j = p(S_j - P_{n - 1, j} + P_{-1, j})+(1 - p)S_{j - 1}\\S_j = S_{j - 1}-\frac p {1 - p} P_{n - 1, j}\\S_0 = \frac{1 - p^n}{1 - p}$$</span> 再结合 <span class="math inline"><em>P</em><sub><em>n</em> − 1, <em>j</em></sub></span> 的递推式： <span class="math display">$$P_{n - 1, j} = C_{n - 1 + j}^{j}p^{n - 1}(1 - p)^{j} = \frac{(n - 1 + j)(1 - p)}{j} P_{n - 1, j - 1}$$</span> 就可以通过递推得到 <span class="math inline"><em>S</em><sub><em>j</em></sub></span> ，而对于每个 <span class="math inline"><em>z</em></span> ，这一部分的答案就是 <span class="math inline">$\sum_{j = 0}^{z}S_j$</span>。</p><p>再考虑 <span class="math inline"><em>b</em> = 0</span> 的情形。这一部分的期望尝试次数是好计算的。</p><p>设从 <span class="math inline"><em>a</em></span> 从 <span class="math inline">0</span> 到 <span class="math inline"><em>i</em></span> 期望尝试次数为 <span class="math inline"><em>D</em><sub><em>i</em></sub></span> ，从 <span class="math inline"><em>i</em> − 1</span> 到 <span class="math inline"><em>i</em></span> 的期望尝试次数为 <span class="math inline"><em>d</em><sub><em>i</em></sub></span> ，则可以得到以下式子： <span class="math display">$$\begin{align}\begin{cases}d_i = p + (1 - p) (D_i+1) \\d_i = D_i - D_{i - 1}\end{cases}\end{align}$$</span> 可以解得： <span class="math display">$$pD_i = D_{i - 1} + 1\\p(D_i + \frac{1}{1-p}) = D_{i - 1} +\frac{1}{1 - p}\\D_i = \frac{1 - p^i}{(1 - p)p^i}$$</span> 而进入第二部分的概率就是是简单的 <span class="math inline"><em>S</em><sub><em>z</em></sub>(1 − <em>p</em>)</span> ，将概率和期望尝试次数相乘即为第二部分的答案。</p><p>总体上时间复杂度为 <span class="math inline">𝒪(<em>m</em>log <em>m</em>)</span> ，可通过预处理逆元优化为线性。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++">cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;<br><span class="hljs-keyword">if</span> (p == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, m) cout &lt;&lt; n % MOD &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>pbex = <span class="hljs-built_in">qp</span>(<span class="hljs-built_in">inv</span>(p), n) - <span class="hljs-number">1ll</span>;<br>pp = <span class="hljs-built_in">qp</span>(p, n - <span class="hljs-number">1ll</span>);<br>ans = sum = (<span class="hljs-built_in">qp</span>(p, n) + MOD - <span class="hljs-number">1ll</span>) * <span class="hljs-built_in">inv</span>(p + MOD - <span class="hljs-number">1ll</span>) % MOD;<br>cout &lt;&lt; (ans + pbex * sum % MOD) % MOD &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, m) &#123;<br>    pp = pp * (n - <span class="hljs-number">1ll</span> + i) % MOD * <span class="hljs-built_in">inv</span>(i) % MOD * (MOD + <span class="hljs-number">1ll</span> - p) % MOD;<br>    sum = (sum + pp * (MOD - p) % MOD * <span class="hljs-built_in">inv</span>(MOD + <span class="hljs-number">1ll</span> - p) % MOD) % MOD;<br>    ans = (ans + sum) % MOD;<br>    cout &lt;&lt; (ans + pbex * sum % MOD) % MOD &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="e">6E</h1><blockquote><p><strong>题目大意：</strong> 给定 <span class="math inline"><em>a</em></span> 和 <span class="math inline"><em>p</em></span> 两个数组，在线处理 <span class="math inline"><em>q</em></span> 个操作，操作有两种类型： + 给定 <span class="math inline"><em>l</em></span> ， <span class="math inline"><em>r</em></span> ，<span class="math inline"><em>x</em></span>。使 <span class="math inline"><em>a</em><sub><em>i</em></sub> → <em>a</em><sub><em>i</em></sub> + <em>x</em>(<em>i</em> ∈ [<em>l</em>, <em>r</em>])</span> + 给定 <span class="math inline"><em>l</em></span>， <span class="math inline"><em>r</em></span>。 计算 <span class="math inline">$\sum_{i = l} ^r a_{p_i}$</span> 。</p></blockquote><blockquote><p><strong>知识点：</strong> 分块</p></blockquote><p>考虑朴素的分块。记块长为 <span class="math inline"><em>L</em></span> ，<span class="math inline"><em>a</em></span> 的第 <span class="math inline"><em>i</em></span> 个块为 <span class="math inline"><em>A</em><sub><em>i</em></sub></span> ，<span class="math inline"><em>a</em><sub><em>p</em></sub></span> 的第 <span class="math inline"><em>i</em></span> 个块是 <span class="math inline"><em>B</em><sub><em>i</em></sub></span> 。</p><p>再记 <span class="math inline"><em>A</em><sub><em>i</em></sub></span> 整块加一后 <span class="math inline"><em>B</em><sub><em>j</em></sub></span> 的增量为 <span class="math inline"><em>f</em><sub><em>i</em>, <em>j</em></sub></span> 。并对 <span class="math inline"><em>f</em><sub><em>i</em></sub></span> 做前缀和 <span class="math inline"><em>S</em><sub><em>i</em>, <em>j</em></sub></span> 。（可以在预处理时 <span class="math inline">$\mathcal O(n + (\frac{n}{L})^2)$</span> 求得）</p><p>修改涉及整块时，对 <span class="math inline"><em>A</em><sub><em>i</em></sub></span> 维护一个懒标记 <span class="math inline"><em>t</em><em>a</em><em>g</em><sub><em>i</em></sub></span> ，则其对 <span class="math inline"><em>B</em><sub><em>l</em>..<em>r</em></sub></span> 的影响之和为 <span class="math inline">$tag_i \sum_{j = l}^{r}f_{i,j}$</span> ，即 <span class="math inline"><em>t</em><em>a</em><em>g</em><sub><em>i</em></sub>(<em>S</em><sub><em>i</em>, <em>r</em></sub> − <em>S</em><sub><em>i</em>, <em>l</em> − 1</sub>)</span> 。至于不成整块的部分，直接暴力修改。单次修改时间复杂度为 <span class="math inline">$\mathcal O(\frac nL + L)$</span> 。</p><p>查询时类似。整块用懒标记统计增量，不成整块的部分直接暴力统计。单次修改时间复杂度也为 <span class="math inline">$\mathcal O(\frac n L + L)$</span> 。</p><p>取 <span class="math inline">$L = \sqrt n$</span>，则总时间复杂度为 <span class="math inline">$\mathcal O(n + q\sqrt n)$</span> ，可以通过本题。</p><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOR(i,j,k) for (int i = j; i &lt;= k; i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int, int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb(x) push_back(x)</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> B = <span class="hljs-number">320</span>;<br><br><span class="hljs-type">int</span> n, m, k, q;<br><span class="hljs-type">int</span> op, l, r, x, ans;<br><br><span class="hljs-type">int</span> a[N], ap[N], c[N], p[N], bg[N], ed[N];<br><span class="hljs-type">int</span> lz[B + <span class="hljs-number">10</span>], f[B + <span class="hljs-number">10</span>][B + <span class="hljs-number">10</span>], sum[B + <span class="hljs-number">10</span>][B + <span class="hljs-number">10</span>];<br><br>vector&lt;<span class="hljs-type">int</span>&gt; vc[N];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; q;<br>    m = (n - <span class="hljs-number">1</span>) / B + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        cin &gt;&gt; p[i];<br>        vc[p[i]].<span class="hljs-built_in">pb</span>(i);<br>        c[i] = (i - <span class="hljs-number">1</span>) / B + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (i % B == <span class="hljs-number">1</span>) bg[c[i]] = i;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i % B == <span class="hljs-number">0</span> || i == n) ed[c[i]] = i;<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) f[c[p[i]]][c[i]] += <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, m) <span class="hljs-built_in">FOR</span>(j, <span class="hljs-number">1</span>, m) sum[i][j] = sum[i][j - <span class="hljs-number">1</span>] + f[i][j];<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r; l ^= ans; r ^= ans;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>            cin &gt;&gt; x; x ^= ans;<br>            <span class="hljs-keyword">if</span> (c[l] == c[r]) &#123;<br>                <span class="hljs-built_in">FOR</span>(i, l, r) &#123;<br>                    a[i] += x;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : vc[i]) ap[c[j]] += x;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">FOR</span>(i, c[l] + <span class="hljs-number">1</span>, c[r] - <span class="hljs-number">1</span>) lz[i] += x;<br>                <span class="hljs-built_in">FOR</span>(i, l, ed[c[l]]) &#123;<br>                    a[i] += x;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : vc[i]) ap[c[j]] += x;<br>                &#125;<br>                <span class="hljs-built_in">FOR</span>(i, bg[c[r]], r) &#123;<br>                    a[i] += x;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : vc[i]) ap[c[j]] += x;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (c[l] == c[r]) <span class="hljs-built_in">FOR</span>(i, l, r) ret += a[p[i]] + lz[c[p[i]]];<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">FOR</span>(i, c[l] + <span class="hljs-number">1</span>, c[r] - <span class="hljs-number">1</span>) ret += ap[i];<br>                <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, m) ret += lz[i] * (sum[i][c[r] - <span class="hljs-number">1</span>] - sum[i][c[l]]);<br>                <span class="hljs-built_in">FOR</span>(i, l, ed[c[l]]) ret += a[p[i]] + lz[c[p[i]]];<br>                <span class="hljs-built_in">FOR</span>(i, bg[c[r]], r) ret += a[p[i]] + lz[c[p[i]]];<br>            &#125;<br>            cout &lt;&lt; ret &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>            ans = ret;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>25暑训</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暑训1&amp;2 补题</title>
    <link href="/2025/07/16/%E6%9A%91%E8%AE%AD1&amp;2%20%E8%A1%A5%E9%A2%98/"/>
    <url>/2025/07/16/%E6%9A%91%E8%AE%AD1&amp;2%20%E8%A1%A5%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>我承认开训前确实摆了太久，第一场训练赛根本没有进入状态。那么就从今天开始抑制惰性，好好训练吧！</p><h1 id="l">L</h1><p><strong>题目大意：</strong> 给定 <span class="math inline"><em>n</em></span> 个正整数 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 和 <span class="math inline"><em>q</em></span> 次询问。每次询问给定 <span class="math inline"><em>i</em></span>, <span class="math inline"><em>j</em></span>，修改：<span class="math inline"><em>a</em><sub><em>i</em></sub> ← <em>a</em><sub><em>i</em></sub> + <em>j</em></span>，（修改在后续询问中也生效）然后你需要统计此时有多少 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 满足：大于 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 的数的数目不小于 $n 2 $。 <strong>难度：</strong> ~2000 <strong>知识点：</strong> 权值线段树 / 平衡树</p><p>为了方便叙述，我们重新定义中位数为升序排序后的 <span class="math inline">$a_{\left \lceil \frac n 2 \right \rceil }$</span>。（也就是说在 <span class="math inline"><em>n</em></span> 为偶数时不取均值）</p><p>容易发现，小于中位数的元素一定符合统计要求，大于中位数的元素一定不符合统计要求。等于中位数的元素满足以下要求时符合：升序排序后， <span class="math inline">$a_{\left \lceil \frac n 2 \right \rceil } \ne a_{ \left \lceil \frac n 2 \right \rceil + 1}$</span> 。</p><p>因此我们只需寻找一种数据结构支持以下操作：单点修改、查询给定下标的元素、查询小于某数的元素个数。各种数据结构都可以，这里就写一个权值线段树吧。</p><p>先离线对所有可能出现的数进行离散化，作为线段树的值域。线段树维护值域上各数的出现次数，各操作如下。</p><p><strong>单点修改</strong> ：原数出现次数–，新数出现次数++； <strong>查询给定下标的元素</strong> ：线段树上二分即可； <strong>查询小于某数的元素个数</strong> ：其实就是做区间查询；</p><p>好像确实什么难度。但为什么赛时没切？有点无语。</p><h5 id="code">Code:</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOR(i,j,k) for (int i = j; i &lt;= k; i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb(x) push_back(x)</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> T;<br><span class="hljs-type">int</span> n, Q;<br><br><span class="hljs-type">int</span> a[N], b[N], q[N][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> t[N &lt;&lt; <span class="hljs-number">4</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>        t[u] = <span class="hljs-number">0</span>; <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid);<br>    <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>    t[u] = t[u &lt;&lt; <span class="hljs-number">1</span>] + t[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> d)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>        t[u] += d; <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid, x, d);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, x, d);<br>    t[u] = t[u &lt;&lt; <span class="hljs-number">1</span>] + t[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> l;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (x &lt;= t[u &lt;&lt; <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid, x);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, x - t[u &lt;&lt; <span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (L &gt; R) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> t[u];<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>, mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (mid &gt;= L) ret += <span class="hljs-built_in">ask</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R);<br>    <span class="hljs-keyword">if</span> (mid &lt; R) ret += <span class="hljs-built_in">ask</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; Q;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; arr;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; ump;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; id;<br><br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        cin &gt;&gt; a[i]; b[i] = a[i];<br>        <span class="hljs-keyword">if</span> (ump[a[i]]) <span class="hljs-keyword">continue</span>;<br>        ump[a[i]] = <span class="hljs-literal">true</span>;<br>        arr.<span class="hljs-built_in">pb</span>(a[i]);<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, Q) &#123;<br>        cin &gt;&gt; q[i][<span class="hljs-number">0</span>] &gt;&gt; q[i][<span class="hljs-number">1</span>];<br>        b[q[i][<span class="hljs-number">0</span>]] += q[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (ump[b[q[i][<span class="hljs-number">0</span>]]]) <span class="hljs-keyword">continue</span>;<br>        ump[b[q[i][<span class="hljs-number">0</span>]]] = <span class="hljs-literal">true</span>;<br>        arr.<span class="hljs-built_in">pb</span>(b[q[i][<span class="hljs-number">0</span>]]);<br>    &#125;<br>    <span class="hljs-type">int</span> m = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">sort</span> (arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>) id[arr[i]] = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m);<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, id[a[i]], <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, Q) &#123;<br>        <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, id[a[q[i][<span class="hljs-number">0</span>]]], <span class="hljs-number">-1</span>);<br>        a[q[i][<span class="hljs-number">0</span>]] += q[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, id[a[q[i][<span class="hljs-number">0</span>]]], <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> k1 = <span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>), k2 = <span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (k1 == k2) ans = <span class="hljs-built_in">ask</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, <span class="hljs-number">1</span>, k1 - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> ans = <span class="hljs-built_in">ask</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, <span class="hljs-number">1</span>, k1);<br>        cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="i">I</h1><p><strong>题目大意：</strong> 给定区间内 <span class="math inline"><em>n</em> − 1</span> 个点的位置，每次操作选择一个不同点将其左右分割成两个区间。假设操作后两个新子区间的长度为 <span class="math inline"><em>l</em><sub>1</sub>, <em>l</em><sub>2</sub></span> ，则当次操作代价为 <span class="math inline">min {<em>l</em><sub>1</sub>,<em>l</em><sub>2</sub>} × ⌈log<sub>2</sub>(<em>l</em><sub>1</sub>+<em>l</em><sub>2</sub>)⌉</span>，不平衡度为 <span class="math inline">|<em>l</em><sub>1</sub>−<em>l</em><sub>2</sub>|</span>。要求 <span class="math inline"><em>n</em> − 1</span> 次分割操作不平衡度单调不增，代价之和最小。 <strong>难度：</strong> ~2200 <strong>知识点：</strong> 区间DP，空间卡常</p><p>以为是小清新区间DP，但发现并非如此啊，原来是神人卡常题。</p><p>首先我们注意到子区间转移至父区间需要满足不平衡度的要求，所以我们设计的状态需要包含不平衡度的信息，方便转移。</p><p>此处我们设 <span class="math inline"><em>d</em><em>p</em><sub><em>l</em>, <em>r</em>, <em>m</em></sub></span> 表示区间 <span class="math inline">[<em>l</em>, <em>r</em>]</span> ，若第一步割 <span class="math inline"><em>m</em></span>​ ，最终完全分割至少需要付出的代价。那么我们可以做出以下转移： <span class="math display"><em>d</em><em>p</em><sub><em>l</em>, <em>r</em>, <em>m</em></sub> = min<sub><em>i</em></sub><em>d</em><em>p</em><sub><em>l</em>, <em>m</em>, <em>i</em></sub> + min<sub><em>j</em></sub><em>d</em><em>p</em><sub><em>m</em> + 1, <em>r</em>, <em>j</em></sub> + <em>w</em></span> 其中 <span class="math inline"><em>w</em></span> 表示该次转移产生的代价，也就是 <span class="math inline">min {<em>l</em><sub>1</sub>,<em>l</em><sub>2</sub>} × ⌈log<sub>2</sub>(<em>l</em><sub>1</sub>+<em>l</em><sub>2</sub>)⌉</span> ，<span class="math inline"><em>l</em><sub>1</sub>, <em>l</em><sub>2</sub></span> 可以通过预处理前缀和 <span class="math inline">𝒪(1)</span> 求出。</p><p>同时 <span class="math inline"><em>i</em></span> 和 <span class="math inline"><em>j</em></span> 的取值有范围要求，必须在 <span class="math inline"><em>d</em><em>p</em><sub><em>l</em>, <em>m</em>, <em>i</em></sub></span> 和 <span class="math inline"><em>d</em><em>p</em><sub><em>m</em> + 1, <em>r</em>, <em>j</em></sub></span> 的不平衡度小于等于父区间的范围内。此处若枚举 <span class="math inline"><em>i</em>, <em>j</em></span> 取值，时间复杂度 <span class="math inline">𝒪(<em>n</em><sup>4</sup>)</span> ，无法通过本题。</p><p>考虑根据 <span class="math inline"><em>d</em><em>p</em><sub><em>l</em>, <em>r</em>, <em>m</em></sub></span> 的不平衡度对 <span class="math inline"><em>d</em><em>p</em><sub><em>l</em>, <em>r</em></sub></span> 序列进行排序，并做前缀最小值。由父状态得到不平衡度限制，便可在新的 <span class="math inline"><em>d</em><em>p</em><sub><em>l</em>, <em>r</em></sub></span> 上进行二分，以得到最优转移。时间复杂度 <span class="math inline">𝒪(<em>n</em><sup>3</sup>log <em>n</em>)</span> ，可以通过此题。</p><p>但此题对空间的限制很严格。即使优化代码实现方法，只留两个 $420   $ 级别的 <code>long long</code> 数组依旧无法通过。必须再对空间常数做优化。</p><p>注意到 <span class="math inline"><em>d</em><em>p</em><sub><em>i</em>, <em>j</em>, <em>k</em></sub></span> 只在 <span class="math inline"><em>i</em> ≤ <em>k</em> &lt; <em>j</em></span> 时有意义，也就是说当前的 <span class="math inline"><em>d</em><em>p</em></span> 数组占据了大量的无效空间。</p><p>因此我们考虑对满足 <span class="math inline"><em>i</em> ≤ <em>k</em> &lt; <em>j</em></span> 的三元组 <span class="math inline">(<em>i</em>, <em>j</em>, <em>k</em>)</span> 按照字典序进行编号。这个编号可以以一个多项式的形式表示。通过演算可知，这样做可以将空间压缩至原来的六分之一。于是艰难通过本题。</p><h5 id="code-1">Code:</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOR(i,j,k) for (int i = j; i &lt;= k; i++)</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">422</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">1e16</span>;<br><br><span class="hljs-type">int</span> T;<br><span class="hljs-type">int</span> n, cnt;<br><span class="hljs-type">int</span> a[N], sum[N], pre[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sta</span> &#123;<br>    <span class="hljs-type">int</span> imb, mn;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> sta &amp; x) &amp; &#123;<br>        <span class="hljs-keyword">return</span> imb &lt; x.imb;<br>    &#125;<br>&#125; g[(N - <span class="hljs-number">1</span>) * N * (N + <span class="hljs-number">1</span>) / <span class="hljs-number">6</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> pre[i - <span class="hljs-number">1</span>] + (j - i) * (j - i + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - (j - <span class="hljs-number">1</span> - k);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Qry</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> D)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> L = l, R = r - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> ans = INF;<br>    <span class="hljs-keyword">while</span> (L &lt;= R) &#123;<br>        <span class="hljs-type">int</span> mid = (L + R) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (g[<span class="hljs-built_in">calc</span>(l, r, mid)].imb &lt;= D) &#123;<br>            L = mid + <span class="hljs-number">1</span>;<br>            ans = <span class="hljs-built_in">min</span>(ans, g[<span class="hljs-built_in">calc</span>(l, r, mid)].mn);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            R = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ans == INF) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) pre[i] = pre[i - <span class="hljs-number">1</span>] + (n - i + <span class="hljs-number">1</span>) * (n - i) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">FOR</span>(j, i + <span class="hljs-number">1</span>, n) <span class="hljs-built_in">FOR</span>(k, i, j - <span class="hljs-number">1</span>) g[++cnt].mn = INF;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; a[i], sum[i] = sum[i - <span class="hljs-number">1</span>] + a[i];<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>) &#123;<br>        g[<span class="hljs-built_in">calc</span>(i, i + <span class="hljs-number">1</span>, i)].mn = <span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">log2</span>(a[i] + a[i + <span class="hljs-number">1</span>])) * <span class="hljs-built_in">min</span>(a[i], a[i + <span class="hljs-number">1</span>]);;<br>        g[<span class="hljs-built_in">calc</span>(i, i + <span class="hljs-number">1</span>, i)].imb = <span class="hljs-built_in">abs</span>(a[i] - a[i + <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>        cout &lt;&lt; g[<span class="hljs-built_in">calc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)].mn &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(len, <span class="hljs-number">3</span>, n) &#123;<br>        <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n - len + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">FOR</span>(m, i, j - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-type">int</span> Lsz = sum[m] - sum[i - <span class="hljs-number">1</span>];<br>                <span class="hljs-type">int</span> Rsz = sum[j] - sum[m];<br>                <span class="hljs-type">int</span> D = <span class="hljs-built_in">abs</span>(Lsz - Rsz);<br>                <span class="hljs-type">int</span> ans1 = <span class="hljs-built_in">Qry</span>(i, m, D), ans2 = <span class="hljs-built_in">Qry</span>(m + <span class="hljs-number">1</span>, j, D);<br>                <span class="hljs-type">int</span> pos = <span class="hljs-built_in">calc</span>(i, j, m);<br>                <span class="hljs-keyword">if</span> (ans1 == <span class="hljs-number">-1</span> || ans2 == <span class="hljs-number">-1</span>) g[pos].mn = INF;<br>                <span class="hljs-keyword">else</span> g[pos].mn = ans1 + ans2 + <span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">log2</span>(Lsz + Rsz)) * <span class="hljs-built_in">min</span>(Lsz, Rsz);<br>                g[pos].imb = D;<br>                <span class="hljs-keyword">if</span> (len == n) &#123;<br>                    <span class="hljs-keyword">if</span> (g[pos].mn == INF) cout &lt;&lt; <span class="hljs-string">&quot;-1 &quot;</span>; <br>                    <span class="hljs-keyword">else</span> cout &lt;&lt; g[pos].mn &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">int</span> bg = <span class="hljs-built_in">calc</span>(i, j, i), ed = <span class="hljs-built_in">calc</span>(i, j, j - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">sort</span>(g + bg, g + ed);<br>            <span class="hljs-built_in">FOR</span>(m, i + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>) &#123;<br>                g[<span class="hljs-built_in">calc</span>(i, j, m)].mn = <span class="hljs-built_in">min</span>(g[<span class="hljs-built_in">calc</span>(i, j, m)].mn, g[<span class="hljs-built_in">calc</span>(i, j, m - <span class="hljs-number">1</span>)].mn);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--) <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>25暑训</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯2025省赛A组游记&amp;题解</title>
    <link href="/2025/04/28/%E8%93%9D%E6%A1%A5%E6%9D%AF2025%E7%9C%81%E8%B5%9BA%E7%BB%84%E6%B8%B8%E8%AE%B0&amp;%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/04/28/%E8%93%9D%E6%A1%A5%E6%9D%AF2025%E7%9C%81%E8%B5%9BA%E7%BB%84%E6%B8%B8%E8%AE%B0&amp;%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>说起来这届蓝桥杯参赛过程还挺波折的。原定的时间恰好碰到北京大风（一直呆在室内，没有体验一下大风有多大）推迟后的时间又和你航的数分期中撞了……</p><p>一个周末内前后脚比赛和考试，怎么想都很痛苦吧。此外这周内还塞满了许多琐事，导致根本没有大块的空闲时间进行复习。直到周五晚上十点多排练结束回到寝室才想起来第二天就要比赛了，把一些基础的数据结构和算法过了一遍，心里稍微有了点底。</p><p>众所周知，备用卷总是容易出现难度或区分度方面的问题。这届也是如此，总体上难度偏低，区分度也不足。</p><p>不同于2024年A组真题E/F/G/H有层次的难度设计与全面的知识面考察，这套题在G题之前几乎没有给到任何强度。而G题又是一个显而易见的线段树模板题，于是区分度等于是全部由H题的差分约束提供了（很不幸我被区分了）</p><p>在此写一篇个人向题解，赛时心路历程会穿插其中。</p><h1 id="a">A</h1><p><strong>题目大意：</strong>大盒尺寸 <span class="math inline">200 × 250 × 240</span>，小盒尺寸 <span class="math inline">30 × 40 × 50</span>，问大盒里能放几个小盒。</p><p><strong>标签：</strong>小学数学</p><p>我认为将小学二年级数学题放在大学生竞赛里是不妥的。所以我认真思考了很久哪里有坑。</p><p>但事实上这就是一道小学二年级数学题，无语了家人们。</p><p>注意到有 <span class="math inline">30|240</span>，<span class="math inline">40|200</span>，<span class="math inline">50|250</span> ，所以答案就是大体积除以小体积。</p><p>哎哎，出题人的苦心。</p><h1 id="b">B</h1><p><strong>题目大意：</strong>求符合要求的正整数 <span class="math inline"><em>n</em></span> 的数量：<span class="math inline"><em>n</em> + 20255202</span> 和 <span class="math inline"><em>n</em> + 10244201</span> 都是完全平方数。</p><p><strong>标签：</strong>枚举/初中数学</p><p>赛时我先考虑了直接枚举 <span class="math inline"><em>n</em></span>。分别设 <span class="math inline"><em>a</em><sup>2</sup> = <em>n</em> + 20255202</span>，<span class="math inline"><em>b</em><sup>2</sup> = <em>n</em> + 10244201</span>。由于 <span class="math inline"><em>a</em><sup>2</sup> &gt; <em>b</em><sup>2</sup></span>，因此也有 <span class="math inline"><em>a</em><sup>2</sup> ≥ (<em>b</em> + 1)<sup>2</sup></span> ，稍加变形可得：<span class="math inline">$b\leq\frac{a^2-b^2-1}{2}$</span> ，其中 <span class="math inline"><em>a</em><sup>2</sup> − <em>b</em><sup>2</sup></span> 是定值 <span class="math inline">10011001</span> 。那么 <span class="math inline"><em>b</em></span> 的枚举范围就不超过 <span class="math inline">5005500</span> ，在计算机的承受范围之内。枚举时判断 <span class="math inline"><em>b</em><sup>2</sup> + 10011001</span> 是不是完全平方数即可。</p><p>不过我最终选择的并非此解法。注意到 <span class="math inline">(<em>a</em> + <em>b</em>)(<em>a</em> − <em>b</em>) = 10011001</span> ，可以考虑对 <span class="math inline">10011001</span> 进行因数分解。由于这是个奇数，所以因数一定同为奇数，解出来的 <span class="math inline"><em>a</em></span> 和 <span class="math inline"><em>b</em></span> 一定是整数。去掉那些 <span class="math inline"><em>a</em><sup>2</sup> ≤ 20255202</span> 的情形后，<span class="math inline">10011001</span> 剩下的因数对的数量便是最终答案。</p><p>比较幽默的是，我枚举因数的时候是从 <span class="math inline">2</span> 开始的，因此最终答案少了一种，痛失五分。</p><h2 id="c">C</h2><p><strong>题目大意：</strong>用循环的字符串填充矩阵的每一行。每一行的字符串是 <code>LANQIAO</code> 循环左移对应次数后形成的串。求矩阵上 <code>A</code> 的个数。</p><p><strong>标签：</strong>模拟</p><p>既然数据范围这么小的话，先把矩阵填满，再取数 <code>A</code> 的数量就行了。没什么好讲的。</p><h1 id="d">D</h1><p><strong>题目大意：</strong>给定AB串，重复执行操作，每次删去一个AB子列直至不能操作。问串最终长度可能的最大值。</p><p><strong>标签：</strong>贪心，双指针</p><p>显然串最终形态一定形如 <code>BB...BBAAA...A</code>，否则就还能继续操作。我们应尽量删去所有靠左的A，所有靠右的B。</p><p>那么贪心地去做，用一个双指针维护这个过程。每次删去串中第一个 A 和最后一个 B 。直到双指针相遇。</p><p>贪心的正确性是显然的。因为靠左的 B 与靠右的 B 相比，不被删去从而留在最终串中对答案做出贡献的机会更大。</p><h1 id="e">E</h1><p><strong>题目大意：</strong>给定一棵树，每次出发走至多 <span class="math inline"><em>k</em></span> 步，步长为 <span class="math inline">1</span> 或 <span class="math inline">2</span> ，然后获得路径终点的权值。你可以从 <span class="math inline">1</span> 号节点出发无数次。问最终获得的权值。</p><p><strong>标签：</strong>树的遍历</p><p>注意到 <span class="math inline">2<em>k</em></span> 以内的所有数字都可以写成不超过 <span class="math inline"><em>k</em></span> 个 <span class="math inline">1</span> 或 <span class="math inline">2</span> 的和，我们求出所有深度不大于 <span class="math inline">2<em>k</em></span> 节点的权值和即可。（初读题的时候还以为只能出发一次，以为是个树形DP类似物，但实际上……）</p><h1 id="f">F</h1><p><strong>题目大意：</strong>给定 01 串，问有多少对不重叠的子串互为反串（每个对应位置均相反）</p><p><strong>标签：</strong>计数</p><p>不太记得思路从何而来了，这里直接给出我的做法吧：</p><p>记所给 01 串 <span class="math inline"><em>s</em></span> 的长度为 <span class="math inline"><em>n</em></span> 。</p><p>枚举两串首间的距离 <span class="math inline"><em>j</em></span> ，记 <span class="math inline"><em>t</em><sub><em>i</em></sub> = <em>s</em><sub><em>i</em></sub> + <em>s</em><sub><em>i</em> + <em>j</em></sub></span> <span class="math inline">(<em>i</em> + <em>j</em> ≤ <em>n</em>)</span> ，那么 <span class="math inline"><em>t</em><sub><em>i</em></sub> = 1</span> 说明： <span class="math inline"><em>s</em><sub><em>i</em></sub></span> 与 <span class="math inline"><em>s</em><sub><em>i</em> + <em>j</em></sub></span> 相反，<span class="math inline"><em>s</em><sub><em>i</em></sub></span> 可成为前串的一部分。</p><p>如果 <span class="math inline"><em>t</em><sub><em>L</em>...<em>R</em></sub></span> 都等于 <span class="math inline">1</span> ，那么我们从这些能成为前串一部分的字符中任取一段 <span class="math inline"><em>s</em><sub><em>l</em>...<em>r</em></sub>(<em>L</em>≤<em>l</em>≤<em>r</em>≤<em>R</em>)</span> ，都会有 <span class="math inline"><em>s</em><sub><em>i</em></sub> = 1 − <em>s</em><sub><em>i</em> + <em>j</em></sub>(<em>l</em>≤<em>i</em>≤<em>r</em>)</span> 恒成立。</p><p>也就是说：如果 <span class="math inline"><em>t</em><sub><em>L</em>...<em>R</em></sub></span> 与 <span class="math inline"><em>t</em><sub><em>L</em> + <em>j</em>...<em>R</em> + <em>j</em></sub></span> 没有重叠部分 <span class="math inline">(<em>R</em> &lt; <em>L</em> + <em>j</em>)</span> ，这一段对答案的贡献就是段内的子串数。对于段内每个字符 <span class="math inline"><em>s</em><sub><em>i</em></sub></span>，以它开头的子串数就是 <span class="math inline"><em>R</em> − <em>i</em> + 1</span>，整段的贡献为 <span class="math inline">$\sum_{i=1}^{R-L+1}i.$</span></p><p>那如果有重叠部分怎么办呢？其实也不难想。不论起点的位置，长度大于 <span class="math inline"><em>j</em></span> 的子串一定和后串重叠，不大于 <span class="math inline"><em>j</em></span> 的一定合法。所以我们只需对上面的计算方式稍作调整，改为 <span class="math inline">$\sum_{i=1}^{R-L+1}\min(i,j).$</span> 可以和上式合并。</p><p>计算所有 <span class="math inline"><em>j</em></span> 下贡献的和即可。</p><p>时间复杂度 <span class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span>，可以通过此题。</p><h1 id="g">G</h1><p><strong>题目大意：</strong>维护一个支持入栈、出栈、以及查询栈顶前若干数乘积操作的栈。</p><p><strong>标签：</strong>线段树</p><p>单点修改，区间乘积查询，线段树的暗示已经给得很明显了。</p><p>考虑到栈内的数不超过 <span class="math inline"><em>Q</em></span> 个，线段树的容量开到 <span class="math inline">4<em>e</em>5</span> 级别已经足够。</p><p>入栈操作就是把栈当前容量加一处的数修改为目标数；出栈操作只需让记录栈当前容量的变量自减；查询操作只需调用线段树区间乘积查询函数即可。</p><p>为了让超过 <span class="math inline">2<sup>32</sup></span> 的数输出为 <code>OVERFLOW</code>，我们可以修改区间合并的函数。对每个节点以 <span class="math inline"> − 1</span> 值记录乘积超出 <span class="math inline">2<sup>32</sup></span> 的情况。区间合并时分以下情况（按从上往下的优先级判断）：</p><ul><li>左右子区间节点值有 <span class="math inline">0</span>，则父区间节点值为 <span class="math inline">0</span>。</li><li>左右子区间节点值有 <span class="math inline"> − 1</span> ，则父区间节点值为 <span class="math inline"> − 1</span>。</li><li>左右子区间节点值乘积大于等于 <span class="math inline">2<sup>32</sup></span> ，则父区间节点值为 <span class="math inline"> − 1</span>。</li><li>左右子区间节点值乘积小于 <span class="math inline">2<sup>32</sup></span> ，则父区间节点值为左右子区间节点值乘积。</li></ul><p>剩下就是线段树的常规写法了。算是一道很好调的DS题了。</p><h1 id="h">H</h1><p><strong>题目大意：</strong>给定序列 <span class="math inline"><em>a</em></span> 以及若干约束 <span class="math inline">(<em>l</em>, <em>r</em>, <em>p</em>, <em>q</em>)</span>，求解序列内最大最小差值的可能最小值。约束的意义是： <span class="math display">min<sub><em>l</em> ≤ <em>x</em> ≤ <em>r</em></sub><em>a</em><sub><em>x</em></sub> − max<sub><em>p</em> ≤ <em>y</em> ≤ <em>q</em></sub><em>a</em><sub><em>y</em></sub> ≥ <em>a</em><em>n</em><em>s</em></span> <strong>标签：</strong>差分约束</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯2024省赛A组题解</title>
    <link href="/2025/04/08/%E8%93%9D%E6%A1%A5%E6%9D%AF2024%E7%9C%81%E8%B5%9BA%E7%BB%84%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/04/08/%E8%93%9D%E6%A1%A5%E6%9D%AF2024%E7%9C%81%E8%B5%9BA%E7%BB%84%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>做下来的体感是，涉及的知识点比较基础，但需要写的细节并不少。难度略高于 CSP-J，低于 NOIP/CSP-S。</p><p>我给出的难度排序大致是：A&lt;C&lt;B=D&lt;G&lt;E&lt;F&lt;H，比较令人恶心的是E和F会爆 long long，考场上我肯定无情挂分。</p><p>H题初见没有明确的思路，写的玄学复杂度做法只有 20pts。不是一道好做的题。</p><p>只剩一个礼拜了，很难针对蓝桥杯的风格做专项复习了，稍微复习复习图论/数据结构的板子吧，再切几道推柿子题找找感觉，剩下的听天由命辽。</p><h1 id="a">A</h1><p><strong>标签：</strong> 枚举</p><p>枚举区间内所有日期，统计笔画数大于 <span class="math inline">50</span> 的天数即可。</p><p>Code: 略。</p><h1 id="b">B</h1><p><strong>标签：</strong> DFS</p><p>笔者一开始考虑的错误做法是：枚举 <span class="math inline">13</span> 个白子的位置，再判断是否为平局。复杂度是阶乘级别，难以在短时间内得到结果。</p><p>于是转变思路，考虑到平局要求棋盘被填满，那么最终状态一共只有 <span class="math inline">2<sup>25</sup> = 33, 554, 432</span> 种，时间可以接受。 直接枚举并判断每种情形是否符合平局标准（白子数目为 <span class="math inline">13</span>，且不存在横、竖、斜连成一线）</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">26</span>) &#123;<br>        <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>) &#123;<br>            <span class="hljs-keyword">if</span> (sumx[i] == <span class="hljs-number">0</span> || sumx[i] == <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span> (sumy[i] == <span class="hljs-number">0</span> || sumy[i] == <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sec == <span class="hljs-number">0</span> || sec == <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (fir == <span class="hljs-number">0</span> || fir == <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (tot != <span class="hljs-number">13</span>) <span class="hljs-keyword">return</span>;<br>        cnt++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125; <br>    <span class="hljs-type">int</span> i = (k - <span class="hljs-number">1</span>) / <span class="hljs-number">5</span> + <span class="hljs-number">1</span>, j;<br>    <span class="hljs-keyword">if</span> (k % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) j = <span class="hljs-number">5</span>; <span class="hljs-keyword">else</span> j = k % <span class="hljs-number">5</span>;<br>    sumx[i] += <span class="hljs-number">1</span>; <span class="hljs-comment">// sumx[i] 为第 i 行中白子的个数</span><br>    sumy[j] += <span class="hljs-number">1</span>; <span class="hljs-comment">// sumy[j] 为第 j 列中白子的个数</span><br>    <span class="hljs-keyword">if</span> (i == j) fir += <span class="hljs-number">1</span>; <span class="hljs-comment">// fir 为主对角线上白子个数</span><br>    <span class="hljs-keyword">if</span> (i + j == <span class="hljs-number">6</span>) sec += <span class="hljs-number">1</span>; <span class="hljs-comment">// sec 为副对角线上白子个数</span><br>    tot += <span class="hljs-number">1</span>; <span class="hljs-comment">// tot 为白子总个数</span><br>    <span class="hljs-built_in">dfs</span>(k + <span class="hljs-number">1</span>);<br>    tot -= <span class="hljs-number">1</span>;<br>    sumx[i] -= <span class="hljs-number">1</span>;<br>    sumy[j] -= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (i == j) fir -= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (i + j == <span class="hljs-number">6</span>) sec -= <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">dfs</span>(k + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="c">C</h1><p><strong>标签：</strong> 前缀和，贪心</p><p>当训练进行到一定程度时，训练未完成的士兵一次训练所需的金币数可能会变得小于 <span class="math inline"><em>S</em></span> 。在这个时刻之前，选择组团训练，之后则仅对未完成的士兵训练。下面我们需要找到这个时刻。</p><p>根据需要的训练次数，对士兵进行升序排序。对其做后缀和，判断何时后缀和首次小于 <span class="math inline"><em>S</em></span>。然后根据上述的策略模拟即可。另外注意对 <span class="math inline"><em>S</em></span> 小于最后一位的情况进行判断。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">person</span> &#123;<br>    <span class="hljs-type">int</span> p, c;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> person &amp;x) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> c &lt; x.c;<br>    &#125;<br>&#125; y[N];<br><br><span class="hljs-type">int</span> sum[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>(); m = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; y[i].p &gt;&gt; y[i].c;<br>    <span class="hljs-built_in">sort</span>(y + <span class="hljs-number">1</span>, y + n + <span class="hljs-number">1</span>);<br>    sum[n] = y[n].p;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        sum[i] = sum[i + <span class="hljs-number">1</span>] + y[i].p;<br>    &#125;<br>    <span class="hljs-type">int</span> pos = n + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (m &gt; sum[i]) &#123;<br>            pos = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pos == n + <span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; y[n].c * m &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = y[pos - <span class="hljs-number">1</span>].c * m;<br>    <span class="hljs-built_in">FOR</span>(i, pos, n) &#123;<br>        ans += (y[i].c - y[i - <span class="hljs-number">1</span>].c) * sum[i];<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="d">D</h1><p><strong>标签：</strong> DFS</p><p>在第一棵树上进行搜索，再设置一个指向第二棵树的指针。搜索过程中，先判断第二棵树上下一步能不能到达同样权值的点（使用 <span class="math inline"><em>m</em><em>a</em><em>p</em></span> 进行预处理），不能则跳过，能则继续搜索，并在搜索完成后回溯指针的位置。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m, k, pos, ans;<br><br><span class="hljs-type">int</span> a[N], b[N], dep[N];<br><br>vector&lt;<span class="hljs-type">int</span>&gt; e1[N], e2[N];<br><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    dep[u] = dep[fa] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : e2[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;<br>        mp[u][b[v]] = v;<br>        <span class="hljs-built_in">pre</span>(v, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : e1[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (mp[pos][a[v]]) &#123;<br>            <span class="hljs-type">int</span> tmp = pos;<br>            pos = mp[pos][a[v]];<br>            <span class="hljs-built_in">dfs</span>(v, u);<br>            pos = tmp;<br>        &#125;<br>    &#125;<br>    ans = <span class="hljs-built_in">max</span>(ans, dep[u]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>(); m = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) a[i] = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, m) b[i] = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-built_in">read</span>(), v = <span class="hljs-built_in">read</span>();<br>        e1[u].<span class="hljs-built_in">push_back</span>(v);<br>        e1[v].<span class="hljs-built_in">push_back</span>(u);<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-built_in">read</span>(), v = <span class="hljs-built_in">read</span>();<br>        e2[u].<span class="hljs-built_in">push_back</span>(v);<br>        e2[v].<span class="hljs-built_in">push_back</span>(u);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a[<span class="hljs-number">1</span>] != b[<span class="hljs-number">1</span>]) &#123;<br>        cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    pos = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">pre</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><h1 id="e">E</h1><p><strong>标签：</strong> 二分</p><p>显然选出的最小方差随 <span class="math inline"><em>x</em></span> 的增大单调不增，考虑二分答案，将最优化问题转化为判定性问题。</p><p>对前 <span class="math inline"><em>x</em></span> 名同学的成绩进行排序，可以证明方差最小时选出的 <span class="math inline"><em>k</em></span> 名同学一定是连续的。</p><p>将方差的式子转化为在转移中便于维护的形式： <span class="math display">$${\sigma^2}=\frac{1}{k}\sum_{i=1}^{k}{v_i}^2 - \frac{1}{k^2}(\sum_{i=1}^{k}v_i)^2$$</span> 转移时执行类似滑动窗口的操作修改 <span class="math inline">$\sum_{i=1}^{k}v_i^2$</span> 和 <span class="math inline">$\sum_{i = 1}^{k} v_i$</span> 的值，找出方差值的最小值，判断是否小于给定的 <span class="math inline"><em>T</em></span> 即可。</p><p>但此题似乎对浮点数的精度要求偏高，因此令上式两端同乘 <span class="math inline"><em>k</em><sup>2</sup></span> 转化为整数进行操作规避精度问题。注意到这样做过程中可能超出 <strong>long long 的范围</strong>，还需开 <strong>unsigned long long</strong>。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vc;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, x) vc.<span class="hljs-built_in">push_back</span>(a[i]);<br>    <span class="hljs-built_in">sort</span>(vc.<span class="hljs-built_in">begin</span>(), vc.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> sumsq = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, k) &#123;<br>        sumsq += vc[i - <span class="hljs-number">1</span>] * vc[i - <span class="hljs-number">1</span>];<br>        sum += vc[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-type">int</span> mn = sumsq * k - sum * sum;<br>    <span class="hljs-type">int</span> pos = k;<br>    <span class="hljs-built_in">FOR</span>(i, k + <span class="hljs-number">1</span>, x) &#123;<br>        sumsq += vc[i - <span class="hljs-number">1</span>] * vc[i - <span class="hljs-number">1</span>];<br>        sumsq -= vc[i - <span class="hljs-number">1</span> - k] * vc[i - <span class="hljs-number">1</span> - k];<br>        sum += vc[i - <span class="hljs-number">1</span>];<br>        sum -= vc[i - <span class="hljs-number">1</span> - k];<br>        <span class="hljs-type">int</span> newans = sumsq * k - sum * sum;<br>        <span class="hljs-keyword">if</span> (newans &lt; mn) pos = i;<br>        mn = <span class="hljs-built_in">min</span>(mn, newans);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mn &lt; T * k * k) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>(); k = <span class="hljs-built_in">read</span>(); T = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n) a[i] = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-type">int</span> L = k, R = n;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check</span>(R)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (L &lt; R) &#123;<br>        <span class="hljs-type">int</span> mid = (L + R) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) R = mid;<br>        <span class="hljs-keyword">else</span> L = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    cout &lt;&lt; L &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="f">F</h1><p><strong>标签：</strong> 容斥原理</p><p>先考虑前置问题：满足 <span class="math inline"><em>a</em><sub><em>j</em></sub>|<em>a</em><sub><em>i</em></sub></span> 的有序二元组 <span class="math inline">(<em>i</em>, <em>j</em>)</span> 有多少个。</p><p>由于 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 的数据范围并不大，我们先预处理出每个数的出现次数，然后用根号筛得到 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 的全部因数，对他们的出现次数求和，就可以得到对于当前的 <span class="math inline"><em>i</em></span> ，有多少满足条件的 <span class="math inline">(<em>i</em>, <em>j</em>)</span> 。注意，由于 <span class="math inline"><em>i</em> ≠ <em>j</em></span> ，应将次数减一。</p><p>下面我们利用容斥原理，计算有序四元组 <span class="math inline">(<em>i</em>, <em>j</em>, <em>k</em>, <em>l</em>)</span> 的数量，其中 <span class="math inline"><em>i</em>, <em>j</em>, <em>k</em>, <em>l</em></span> 互异。</p><p>为了方便说明，下设：</p><p>满足条件且 <span class="math inline"><em>i</em> ≠ <em>j</em></span> 的有序二元组数量是 <span class="math inline"><em>N</em><sub>0</sub></span> ；</p><p>满足条件但不限制互异性的有序四元组数量是 <span class="math inline"><em>N</em><sub>1</sub></span> ；</p><p>满足条件但 <span class="math inline">(<em>i</em> = <em>j</em>) ∧ (<em>k</em> ≠ <em>l</em>)</span> 的有序四元组数量是 <span class="math inline"><em>N</em><sub>2</sub></span>；</p><p>满足条件但 <span class="math inline">(<em>i</em> ≠ <em>j</em>) ∧ (<em>k</em> = <em>l</em>)</span> 的有序四元组数量是 <span class="math inline"><em>N</em><sub>3</sub></span>；</p><p>满足条件但 <span class="math inline">(<em>i</em> = <em>j</em>) ∧ (<em>k</em> = <em>l</em>)</span> 的有序四元组数量是 <span class="math inline"><em>N</em><sub>4</sub></span>；</p><p>满足条件但 <span class="math inline">(<em>i</em> = <em>l</em>) ∧ (<em>j</em> ≠ <em>k</em>)</span> 的有序四元组数量是 <span class="math inline"><em>N</em><sub>5</sub></span>；</p><p>满足条件但 <span class="math inline">(<em>i</em> ≠ <em>l</em>) ∧ (<em>j</em> = <em>k</em>)</span> 的有序四元组数量是 <span class="math inline"><em>N</em><sub>6</sub></span>；</p><p>满足条件但 <span class="math inline">(<em>i</em> = <em>l</em>) ∧ (<em>j</em> = <em>k</em>)</span> 的有序四元组数量是 <span class="math inline"><em>N</em><sub>7</sub></span>；</p><p>满足条件且满足互异性的有序四元组数量（也就是最终答案）是 <span class="math inline"><em>N</em></span> 。</p><p>那么根据容斥原理，有： <span class="math inline"><em>N</em> = <em>N</em><sub>1</sub> − <em>N</em><sub>2</sub> − <em>N</em><sub>3</sub> + <em>N</em><sub>4</sub> − <em>N</em><sub>5</sub> − <em>N</em><sub>6</sub> + <em>N</em><sub>7</sub></span> 。</p><p>由于未限制互异性，根据乘法原理，显然 <span class="math inline"><em>N</em><sub>1</sub> = <em>N</em><sub>0</sub><sup>2</sup></span> 。另外可以注意到 <span class="math inline"><em>N</em><sub>4</sub> = <em>N</em><sub>0</sub></span>。</p><p>下面考虑怎样求 <span class="math inline"><em>N</em><sub>2</sub></span> 与 <span class="math inline"><em>N</em><sub>3</sub></span> ：</p><p>先说 <span class="math inline"><em>N</em><sub>2</sub></span>：假设除 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 自身之外，数列中 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 倍数的个数为 <span class="math inline"><em>x</em><sub><em>i</em></sub></span>。对于有序四元组而言，只需 <span class="math inline"><em>a</em><sub><em>k</em></sub></span> 和 <span class="math inline"><em>a</em><sub><em>l</em></sub></span> 互异且都为 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 倍数即可。易得 <span class="math inline"><em>N</em><sub>2</sub> = ∑<em>x</em><sub><em>i</em></sub>(<em>x</em><sub><em>i</em></sub> − 1)</span> 。</p><p><span class="math inline"><em>N</em><sub>3</sub></span> 的求解方式同理：假设除 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 自身之外，数列中 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 因数的个数为 <span class="math inline"><em>y</em><sub><em>i</em></sub></span>，那么有 <span class="math inline"><em>N</em><sub>3</sub> = ∑<em>y</em><sub><em>i</em></sub>(<em>y</em><sub><em>i</em></sub> − 1)</span>。</p><p><span class="math inline"><em>x</em><sub>1</sub></span> 和 <span class="math inline"><em>x</em><sub>2</sub></span> 都可以通过预处理获得。</p><p>下面求解 <span class="math inline"><em>N</em><sub>5</sub></span> 和 <span class="math inline"><em>N</em><sub>6</sub></span>：</p><p>根据对称性，显然两个值是相等的。以 <span class="math inline">(<em>i</em> = <em>l</em>) ∧ (<em>j</em> ≠ <em>k</em>)</span> 的情形为例，则 <span class="math inline"><em>a</em><sub><em>j</em></sub>|<em>a</em><sub><em>i</em></sub></span> 且 <span class="math inline"><em>a</em><sub><em>i</em></sub>|<em>a</em><sub><em>k</em></sub></span> ，我们枚举这个作为 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 的数。沿用上文中的 <span class="math inline"><em>x</em><sub><em>i</em></sub></span> 与 <span class="math inline"><em>y</em><sub><em>i</em></sub></span> ，可以导出 <span class="math inline"><em>N</em><sub>5</sub> = <em>N</em><sub>6</sub> = ∑<em>x</em><sub><em>i</em></sub><em>y</em><sub><em>i</em></sub></span> 。</p><p>至于 <span class="math inline"><em>N</em><sub>7</sub></span> 有且仅有一种情形：两个相等的数互为对方的倍数和因数。枚举 <span class="math inline"><em>a</em><sub><em>i</em></sub></span> 的取值，假设数列中共有 <span class="math inline"><em>z</em><sub><em>i</em></sub></span> 个取该值的数，那么有 <span class="math inline"><em>N</em><sub>7</sub> = ∑<em>z</em><sub><em>i</em></sub>(<em>z</em><sub><em>i</em></sub> − 1)</span> 。</p><p>需要注意的是，在极端情况下（如数列中全是 <span class="math inline">1</span> ）答案可能会超过 <strong>unsigned long long</strong> 的范围，因此需要用 **__int128**。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n0, n1, n2, n3, n4, n5, n6, n7;<br><span class="hljs-type">int</span> cnt[N], times[N], res[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        a[i] = <span class="hljs-built_in">read</span>();<br>        cnt[a[i]]++;<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j * j &lt;= a[i]; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j * j == a[i]) &#123;<br>                res[i] += cnt[j];<br>                times[j] += <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (a[i] % j == <span class="hljs-number">0</span>) &#123;<br>                    res[i] += cnt[j];<br>                    res[i] += cnt[a[i] / j];<br>                    times[j] += <span class="hljs-number">1</span>;<br>                    times[a[i] / j] += <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        n0 += (res[i] - <span class="hljs-number">1</span>);<br>    &#125;<br>    n1 = n0 * n0;<br>    n4 = n0;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        n2 += (times[a[i]] - <span class="hljs-number">1</span>) * (times[a[i]] - <span class="hljs-number">1</span>);<br>        n3 += (res[i] - <span class="hljs-number">1</span>) * (res[i] - <span class="hljs-number">1</span>);<br>        n5 += (times[a[i]] - <span class="hljs-number">1</span>) * (res[i] - <span class="hljs-number">1</span>);<br>        n6 += (times[a[i]] - <span class="hljs-number">1</span>) * (res[i] - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, N - <span class="hljs-number">5</span>) n7 += cnt[i] * (cnt[i] - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">print</span>(n1 - n2 - n3 + n4 - n5 - n6 + n7);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="g">G</h1><p><strong>标签：</strong> LCA，树上差分</p><p>注意到零食的种类非常少，考虑对每种零食分别做树上前缀和。再以起点与终点的 <span class="math inline"><em>l</em><em>c</em><em>a</em></span> 为分界点，将所求路径拆成两条链，借助前缀和求出路径上每种零食的数量，从而求得路径上零食的种类数。</p><p>Code：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m, k, q;<br><br><span class="hljs-type">int</span> a[N], b[N], c[N], dep[N];<br><br><span class="hljs-type">int</span> sum[N][<span class="hljs-number">30</span>], f[N][<span class="hljs-number">30</span>];<br><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    dep[u] = dep[fa] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : e[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>) sum[v][i] = sum[u][i];<br>        sum[v][c[v]]++;<br>        <span class="hljs-built_in">dfs1</span>(v, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    f[u][<span class="hljs-number">0</span>] = fa;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; i) &lt;= dep[u]; i++) &#123;<br>        f[u][i] = f[f[u][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : e[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs2</span>(v, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dep[u] &lt; dep[v]) <span class="hljs-built_in">swap</span>(u, v);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">20</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">if</span> (dep[u] - (<span class="hljs-number">1</span> &lt;&lt; i) &gt;= dep[v])<br>            u = f[u][i];<br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> u;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">20</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (f[u][i] != f[v][i]) &#123;<br>            u = f[u][i];<br>            v = f[v][i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[u][<span class="hljs-number">0</span>]; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>(); q = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) c[i] = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-built_in">read</span>(), v = <span class="hljs-built_in">read</span>();<br>        e[u].<span class="hljs-built_in">push_back</span>(v);<br>        e[v].<span class="hljs-built_in">push_back</span>(u);<br>    &#125;<br>    sum[<span class="hljs-number">1</span>][c[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-built_in">read</span>(), v = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-type">int</span> fa = <span class="hljs-built_in">lca</span>(u, v), ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">25</span>)</span></span>;<br>        <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>) &#123;<br>            t[i] += sum[u][i] - sum[fa][i];<br>            t[i] += sum[v][i] - sum[f[fa][<span class="hljs-number">0</span>]][i];<br>            <span class="hljs-keyword">if</span> (t[i] != <span class="hljs-number">0</span>) ans += <span class="hljs-number">1</span>;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="h">H</h1><p><strong>标签：</strong> 贪心，线段树</p><p>所求为字典序最大的序列，那么每一步都应该选择能选的中最大的。当且仅当没有能放的宝石时，这一步放 <span class="math inline"> − 1</span>。</p><p>体力值本质上是对选取范围做了限制。假设当前体力为 <span class="math inline"><em>k</em></span> ，当前位置是 <span class="math inline"><em>i</em></span> ，那么宝石的选取范围就是 <span class="math inline">[<em>i</em>,<em>i</em>+<em>k</em>]</span> 。当有多个宝石值相等时，显然我们应该选取位置最靠前的，因为越靠后越可能在后续过程中有机会被选取到。选取完成后我们将其修改为 <span class="math inline">0</span> ，示意已经被选取过。</p><p>因而我们需要维护的是区间内的第一个最大值及其所在位置，并支持单点修改的操作，考虑用线段树维护。</p><p>在此基础上题目又增加了限制，相邻位置不能选取等大的数。那么当我们查询到的区间内最大值与上一位的取值相等时，应改为查询区间内的第一个严格次大值。这也可以使用线段树维护，只需修改一下线段树的信息结构和合并方式即可。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">seg</span> &#123;<br>    <span class="hljs-type">int</span> mx, mx2, mxpos, mx2pos;<br>&#125; t[N &lt;&lt; <span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    pii tmp[<span class="hljs-number">5</span>];<br>    tmp[<span class="hljs-number">0</span>] = <span class="hljs-built_in">make_pair</span>(t[p &lt;&lt; <span class="hljs-number">1</span>].mx, -t[p &lt;&lt; <span class="hljs-number">1</span>].mxpos);<br>    tmp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">make_pair</span>(t[p &lt;&lt; <span class="hljs-number">1</span>].mx2, -t[p &lt;&lt; <span class="hljs-number">1</span>].mx2pos);<br>    tmp[<span class="hljs-number">2</span>] = <span class="hljs-built_in">make_pair</span>(t[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].mx, -t[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].mxpos); <br>    tmp[<span class="hljs-number">3</span>] = <span class="hljs-built_in">make_pair</span>(t[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].mx2, -t[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].mx2pos);<br>    <span class="hljs-built_in">sort</span>(tmp, tmp + <span class="hljs-number">4</span>);<br>    t[p].mx = tmp[<span class="hljs-number">3</span>].first; t[p].mxpos = -tmp[<span class="hljs-number">3</span>].second;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (tmp[i].first != tmp[<span class="hljs-number">3</span>].first) &#123;<br>            t[p].mx2 = tmp[i].first;<br>            t[p].mx2pos = -tmp[i].second;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>        t[p].mx = a[l];<br>        t[p].mxpos = l;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid);<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r &amp;&amp; l == x) &#123;<br>        t[p].mx = y;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, x, y);<br>    <span class="hljs-keyword">if</span> (x &gt; mid) <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, x, y);<br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function">seg <span class="hljs-title">querymx2</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> t[p];<br>    <span class="hljs-keyword">if</span> (L &gt; r || R &lt; l) <span class="hljs-keyword">return</span> (seg)&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    seg mxl = <span class="hljs-built_in">querymx2</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R);<br>    seg mxr = <span class="hljs-built_in">querymx2</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R);<br>    pii tmp[<span class="hljs-number">5</span>];<br>    tmp[<span class="hljs-number">0</span>] = <span class="hljs-built_in">make_pair</span>(mxl.mx, -mxl.mxpos);<br>    tmp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">make_pair</span>(mxl.mx2, -mxl.mx2pos);<br>    tmp[<span class="hljs-number">2</span>] = <span class="hljs-built_in">make_pair</span>(mxr.mx, -mxr.mxpos); <br>    tmp[<span class="hljs-number">3</span>] = <span class="hljs-built_in">make_pair</span>(mxr.mx2, -mxr.mx2pos);<br>    <span class="hljs-built_in">sort</span>(tmp, tmp + <span class="hljs-number">4</span>);<br>    seg ans = (seg)&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    ans.mx = tmp[<span class="hljs-number">3</span>].first; ans.mxpos = -tmp[<span class="hljs-number">3</span>].second;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (tmp[i].first != tmp[<span class="hljs-number">3</span>].first) &#123;<br>            ans.mx2 = tmp[i].first;<br>            ans.mx2pos = -tmp[i].second;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>(); k = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) a[i] = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        seg now = <span class="hljs-built_in">querymx2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, i, <span class="hljs-built_in">min</span>(i + k, n));<br>        <span class="hljs-keyword">if</span> (now.mx == <span class="hljs-number">0</span>) &#123;<br>            ans[i] = <span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span> &amp;&amp; now.mx == ans[i - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">if</span> (now.mx2 == <span class="hljs-number">0</span>) &#123;<br>                ans[i] = <span class="hljs-number">-1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans[i] = now.mx2;<br>                <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, now.mx2pos, <span class="hljs-number">0</span>);<br>                k -= now.mx2pos - i;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans[i] = now.mx;<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, now.mxpos, <span class="hljs-number">0</span>);<br>            k -= now.mxpos - i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>25春训2题解</title>
    <link href="/2025/04/01/25%E6%98%A5%E8%AE%AD2%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/04/01/25%E6%98%A5%E8%AE%AD2%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="a">A</h1><p><strong>题目大意：</strong> 规定每一位采用的进制。求十进制数在该进制下的表示。</p><p><strong>难度：</strong> ~900</p><p>按照题意，模拟进位的过程即可。（注意要求输出前导零）</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    string s; <br>    cin &gt;&gt; n &gt;&gt; m;<br>    cin &gt;&gt; s &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-type">int</span> cur = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        ans[i] = m % cur;<br>        m /= cur;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cout &lt;&lt; ans[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="b">B</h1><p><strong>题目大意：</strong> 构造含 <span class="math inline">1</span> 至 <span class="math inline"><em>n</em></span> 各两次的排列，以最小化 <span class="math inline">$\sum_{i=1}^{n}(n-i)\left|d_i+i-n\right|$</span> 的值，其中 <span class="math inline"><em>d</em><sub><em>i</em></sub></span> 是排列中两个 <span class="math inline"><em>i</em></span> 之间的距离。</p><p><strong>难度：</strong> 1900</p><p>显然 <span class="math inline"><em>i</em> = <em>n</em></span> 放的位置不改变答案。因此考虑最后放。</p><p>考虑构造 <span class="math inline"><em>d</em><sub><em>i</em></sub> = <em>n</em> − <em>i</em></span> <span class="math inline">(1 ≤ <em>i</em> ≤ <em>n</em> − 1)</span> 的方案，<span class="math inline"><em>n</em></span> 为奇数和偶数时，分别如下（以 <span class="math inline"><em>n</em> = 5, 6</span> 为例）。</p><p><img src="pic1.png" /></p><p><img src="pic2.png" /></p><p>将奇数偶数聚在一起放置，最后空出的位置放 <span class="math inline"><em>n</em></span> 。这样可保证目标式的值为 <span class="math inline">0</span> ，达到最小。</p><p>Code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i += <span class="hljs-number">2</span>) &#123;<br>        a[(i + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>] = i;<br>        a[(i + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + n - i] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i += <span class="hljs-number">2</span>) &#123;<br>        a[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span> - i / <span class="hljs-number">2</span>] = i;<br>        a[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span> - i / <span class="hljs-number">2</span> - n + i] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!a[i]) a[i] = n;<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * n) cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="d">D</h1><p><strong>题目大意：</strong> 给定一棵有向树型图，此外每个节点有一个指回根节点的边。要求维护两种操作：修改边权以及查询两点之间的最短路径。</p><p><strong>难度：</strong> 2100</p><p>为了方便叙述，下面设树的根节点是 <span class="math inline"><em>r</em></span> ，询问中起点是 <span class="math inline"><em>u</em></span> ，终点是 <span class="math inline"><em>v</em></span> ，修改中的终点是 <span class="math inline"><em>x</em></span> .</p><p>此外，将节点 <span class="math inline"><em>i</em></span> 与根节点的距离记为 <span class="math inline"><em>s</em><em>u</em><em>m</em><sub><em>i</em></sub></span> .</p><p>观察后不难发现，最短路径有两种情形。</p><p>一、<span class="math inline"><em>v</em></span> 在 <span class="math inline"><em>u</em></span> 的子树内。那么无论选择何时返回 <span class="math inline"><em>r</em></span> 再前往 <span class="math inline"><em>v</em></span> ，路径都包含从 <span class="math inline"><em>u</em></span> 到 <span class="math inline"><em>v</em></span> 的简单路径。所以这种情形下答案就是简单路径的长度，也就是 <span class="math inline"><em>s</em><em>u</em><em>m</em><sub><em>v</em></sub> − <em>s</em><em>u</em><em>m</em><sub><em>u</em></sub></span> .</p><p>二、<span class="math inline"><em>v</em></span> 不在 <span class="math inline"><em>u</em></span> 的子树内。那么路径一定如下构成：<span class="math inline"><em>u</em> → <em>t</em> → <em>r</em> → <em>v</em></span> ，其中的 <span class="math inline"><em>t</em></span> 是 <span class="math inline"><em>u</em></span> 子树中的节点。 <span class="math display">$$\begin{align*}w_{u\rightarrow v}&amp;=w_{u\rightarrow t} + w_{t\rightarrow r}+w_{r\rightarrow v}\\&amp;=sum_t - sum_u+w_{t\rightarrow r}+sum_v\end{align*}$$</span> 由于询问中 <span class="math inline"><em>u</em></span> 和 <span class="math inline"><em>v</em></span> 确定，我们只需维护每一个节点的 <span class="math inline"><em>s</em><em>u</em><em>m</em><sub><em>t</em></sub> + <em>w</em><sub><em>t</em> → <em>r</em></sub></span> 值，然后在 <span class="math inline"><em>u</em></span> 的子树中找出最小值即可。</p><p>修改操作同样有两种情形。</p><p>一、修改的是树边。那么 <span class="math inline"><em>x</em></span> 的子树内所有节点对应的 <span class="math inline"><em>s</em><em>u</em><em>m</em></span> 值会改变相同的值。结合查询的要求，这似乎可以用线段树维护，但同子树内的节点编号不一定连续，难以维护。为了解决这个问题，我们将节点按照其 <span class="math inline"><em>d</em><em>f</em><em>s</em></span> 序重新编号，这样就可以保证同子树内节点的编号是一个连续的区间，从而可以用线段树的区间修改来维护。</p><p>二、修改的不是树边。只需对 <span class="math inline"><em>s</em><em>u</em><em>m</em><sub><em>t</em></sub> + <em>v</em><sub><em>t</em> → <em>r</em></sub></span> 做单点修改即可。</p><p>总的来说，我们根据 <span class="math inline"><em>d</em><em>f</em><em>s</em></span> 序重排后建立两棵线段树。第一棵维护 <span class="math inline"><em>s</em><em>u</em><em>m</em></span> 值，支持区间修改和单点查询；第二棵维护 $sum_i + w_{ir} $ 值，支持区间修改和区间最值查询。在修改和查询时根据上文所说执行对应操作即可。</p><p>赛时思路完全正确，也完成了代码。但调试能力太差，未能场切。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOR(i,j,k) for (int i = j; i &lt;= k; i++)</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">4e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">1e16</span>;<br><br><span class="hljs-type">int</span> T;<br><br><span class="hljs-type">int</span> n, m, k, q;<br><br><span class="hljs-type">int</span> a[N], b[N];<br><br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; e[N &lt;&lt; <span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>(); <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> ((ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>) &amp;&amp; ch != <span class="hljs-string">&#x27;-&#x27;</span>) ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) &#123; ch = <span class="hljs-built_in">getchar</span>(); f = - <span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123; x = x * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span>; ch = <span class="hljs-built_in">getchar</span>(); &#125;<br>    <span class="hljs-keyword">return</span> x * f;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sgt</span> &#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> mid (l + r) / 2</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;<br>        <span class="hljs-type">int</span> val, len, mn, tag;<br>    &#125; info[N &lt;&lt; <span class="hljs-number">2</span>];<br><br>    <span class="hljs-type">int</span> a[N];<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>        info[p].val = info[p &lt;&lt; <span class="hljs-number">1</span>].val + info[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].val;<br>        info[p].len = info[p &lt;&lt; <span class="hljs-number">1</span>].len + info[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].len;<br>        info[p].mn = <span class="hljs-built_in">min</span>(info[p &lt;&lt; <span class="hljs-number">1</span>].mn, info[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].mn);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (info[p].tag) &#123;<br>            info[p &lt;&lt; <span class="hljs-number">1</span>].tag += info[p].tag;<br>            info[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].tag += info[p].tag;<br>            info[p &lt;&lt; <span class="hljs-number">1</span>].mn += info[p].tag;<br>            info[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].mn += info[p].tag;<br>            info[p &lt;&lt; <span class="hljs-number">1</span>].val += info[p].tag * (mid - l + <span class="hljs-number">1</span>);<br>            info[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].val += info[p].tag * (r - mid);<br>            info[p].tag = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            info[p].val = a[l];<br>            info[p].len = <span class="hljs-number">1</span>;<br>            info[p].mn = a[l];<br>            info[p].tag = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid);<br>        <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-built_in">pushup</span>(p);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pmodify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r &amp;&amp; l == x) &#123;<br>            info[p].val = v;<br>            info[p].mn = v;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">pushdown</span>(p, l, r);<br>        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">pmodify</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, x, v);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">pmodify</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, x, v);<br>        <span class="hljs-built_in">pushup</span>(p);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rmodify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;<br>            info[p].val += (r - l + <span class="hljs-number">1</span>) * v;<br>            info[p].tag += v;<br>            info[p].mn += v;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (R &lt; l || L &gt; r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">pushdown</span>(p, l, r);<br>        <span class="hljs-built_in">rmodify</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R, v);<br>        <span class="hljs-built_in">rmodify</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R, v);<br>        <span class="hljs-built_in">pushup</span>(p);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> info[p].val;<br>        <span class="hljs-keyword">if</span> (R &lt; l || L &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">pushdown</span>(p, l, r);<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        res += <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R);<br>        res += <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R);<br>        <span class="hljs-built_in">pushup</span>(p);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">querymin</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> info[p].mn;<br>        <span class="hljs-keyword">if</span> (R &lt; l || L &gt; r) <span class="hljs-keyword">return</span> INF;<br>        <span class="hljs-built_in">pushdown</span>(p, l, r);<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        res = <span class="hljs-built_in">querymin</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R);<br>        res =  <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">querymin</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R));<br>        <span class="hljs-built_in">pushup</span>(p);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125; t, tt;<br><br><span class="hljs-type">int</span> nowmax = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> idx[N], nd[N], rg[N][<span class="hljs-number">2</span>], dep[N], f[N][<span class="hljs-number">30</span>];<br><br>vector&lt;<span class="hljs-type">int</span>&gt; sum;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>    dep[u] = dep[fa] + <span class="hljs-number">1</span>;<br>    nowmax++;<br>    idx[u] = nowmax;<br>    nd[nowmax] = u;<br>    rg[idx[u]][<span class="hljs-number">0</span>] = nowmax;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v.first == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs1</span>(u, v.first);<br>    &#125;<br>    rg[idx[u]][<span class="hljs-number">1</span>] = nowmax;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v.first == fa) <span class="hljs-keyword">continue</span>;<br>        sum[idx[v.first]] = sum[idx[u]] + v.second;<br>        <span class="hljs-built_in">dfs2</span>(u, v.first);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (dep[u] &lt; dep[v]) <span class="hljs-built_in">swap</span>(u, v);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">20</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br><span class="hljs-keyword">if</span> ((dep[u] - (<span class="hljs-number">1</span> &lt;&lt; i)) &gt;= dep[v])<br>u = f[u][i];<br><span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> u;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">20</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-keyword">if</span> (f[u][i] == f[v][i]) <span class="hljs-keyword">continue</span>;<br>u = f[u][i]; v = f[v][i];<br>&#125;<br><span class="hljs-keyword">return</span> f[u][<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs3</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>f[u][<span class="hljs-number">0</span>] = fa;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; i) &lt;= dep[u]; i++) <br>f[u][i] = f[f[u][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v.first == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs3</span>(v.first, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> rec[N][<span class="hljs-number">5</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>(); q = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) b[i] = INF;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>) &#123;<br>        rec[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">read</span>();<br>        rec[i][<span class="hljs-number">2</span>] = <span class="hljs-built_in">read</span>();<br>        rec[i][<span class="hljs-number">3</span>] = <span class="hljs-built_in">read</span>();<br>        e[rec[i][<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(rec[i][<span class="hljs-number">2</span>], rec[i][<span class="hljs-number">3</span>]));<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, n, <span class="hljs-number">2</span> * n - <span class="hljs-number">2</span>) &#123;<br>        rec[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">read</span>();<br>        rec[i][<span class="hljs-number">2</span>] = <span class="hljs-built_in">read</span>();<br>        rec[i][<span class="hljs-number">3</span>] = <span class="hljs-built_in">read</span>();<br>        b[rec[i][<span class="hljs-number">1</span>]] = rec[i][<span class="hljs-number">3</span>];<br>    &#125;<br>    <br>    sum.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dfs3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) t.a[i] = sum[i];<br>    t.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) tt.a[i] = b[nd[i]] + sum[i];<br>    tt.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">int</span> op = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-type">int</span> u = <span class="hljs-built_in">read</span>(), v = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (u &gt;= n) &#123;<br>                <span class="hljs-type">int</span> tsum = t.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, idx[rec[u][<span class="hljs-number">1</span>]], idx[rec[u][<span class="hljs-number">1</span>]]);<br>                tt.<span class="hljs-built_in">pmodify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, idx[rec[u][<span class="hljs-number">1</span>]], v + tsum);<br>                b[rec[u][<span class="hljs-number">1</span>]] = v;<br>                rec[u][<span class="hljs-number">3</span>] = v;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> root = idx[rec[u][<span class="hljs-number">2</span>]];<br>                t.<span class="hljs-built_in">rmodify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, rg[root][<span class="hljs-number">0</span>], rg[root][<span class="hljs-number">1</span>], v - rec[u][<span class="hljs-number">3</span>]);<br>                tt.<span class="hljs-built_in">rmodify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, rg[root][<span class="hljs-number">0</span>], rg[root][<span class="hljs-number">1</span>], v - rec[u][<span class="hljs-number">3</span>]);<br>                rec[u][<span class="hljs-number">3</span>] = v;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">lca</span>(u, v) == u) &#123;<br>                <span class="hljs-type">int</span> s1 = t.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, idx[u], idx[u]);<br>                <span class="hljs-type">int</span> s2 = t.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, idx[v], idx[v]);<br>                cout &lt;&lt; s2 - s1 &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> ans = t.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, idx[v], idx[v]);<br>                <span class="hljs-type">int</span> ans2 = tt.<span class="hljs-built_in">querymin</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, rg[idx[u]][<span class="hljs-number">0</span>], rg[idx[u]][<span class="hljs-number">1</span>]);<br>                <span class="hljs-type">int</span> ans3 = t.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, idx[u], idx[u]);<br>                cout &lt;&lt; ans + ans2 - ans3 &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>25春训</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>25春训1题解</title>
    <link href="/2025/03/17/25%E6%98%A5%E8%AE%AD1%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/03/17/25%E6%98%A5%E8%AE%AD1%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="a">A</h1><p><strong>难度：</strong> 900</p><p>合法的数字最高位一定不为 <span class="math inline">0</span> ，这也就意味着低位只能全部为 <span class="math inline">0</span> （如果有低位的话）。因此只需将最高位加一，其余位归零即可。</p><p>Code：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n / res &gt;= <span class="hljs-number">10</span>) res *= <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> ans = ( n / res + <span class="hljs-number">1</span> ) * res - n;<br>    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="b">B</h1><p><strong>题目大意：</strong> 现有 <span class="math inline"><em>n</em></span> 个取值 <span class="math inline">1</span>，<span class="math inline">2</span> 或 <span class="math inline">3</span> 的三元组。存在和不为 <span class="math inline">6</span> 的三元组的方案被视为合法方案。求合法方案数。</p><p><strong>难度：</strong> 1500</p><p>要求的方案数就是：全部的方案数 <span class="math inline">−</span> 所有三元组和均为 <span class="math inline">6</span> 的方案数。</p><p>由于对于每个三元组而言，总方案数是 <span class="math inline">27</span> ，和为 <span class="math inline">6</span> 的方案数是 <span class="math inline">7</span> ，故最终答案为 <span class="math inline">27<sup><em>n</em></sup> − 7<sup><em>n</em></sup></span>。</p><p>Code：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-type">int</span> ans1 = <span class="hljs-number">1</span>, ans2 = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) ans1 = ans1 * <span class="hljs-number">7</span> % MOD;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n * <span class="hljs-number">3</span>) ans2 = ans2 * <span class="hljs-number">3</span> % MOD;<br>    cout &lt;&lt; (ans2 - ans1 + MOD) % MOD;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="c">C</h1><p><strong>题目大意：</strong> 给定出入会记录的一部分。判断哪些人可能满足：会中有人时始终在会中。</p><p><strong>难度：</strong> 1800</p><p>首先，显然全程未出现记录的人一定符合要求，且不影响其他人的判断。我们在分析过程中无视他们即可。</p><p>第一条记录是出会的人在片段开始前就在会中。因此只要有这样的球员存在，第一条记录是入会的人一定不符合要求。而如果这样的人不存在，可能符合要求的只剩第一个入会的人。</p><p>接着我们模拟出会入会的情况。以下两种情况会被取消资格：</p><ol type="1"><li>出会时还有其他人在会中。</li><li>出会时会中没人，但紧接着有其他人入会。</li></ol><p>模拟结束后仍然未被取消资格的人，或全程无记录的人是符合要求的人。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, m) &#123;<br>        cin &gt;&gt; c[i] &gt;&gt; a[i];<br>        mp[a[i]] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, m) &#123;<br>        <span class="hljs-keyword">if</span> (c[i] == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>            b[a[i]] = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (!b[a[i]]) &#123;<br>                d[a[i]] = <span class="hljs-number">1</span>;<br>                ans[a[i]] = <span class="hljs-number">1</span>;<br>                cnt++;<br>                b[a[i]] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) &#123;<br>        ans[a[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;<br>        d[a[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, m) &#123;<br>        <span class="hljs-keyword">if</span> (c[i] == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>            cnt++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (c[i] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>            cnt--;<br>            <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">0</span>) ans[a[i]] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (i != m) &#123;<br>                <span class="hljs-keyword">if</span> (a[i + <span class="hljs-number">1</span>] != a[i]) &#123;<br>                    ans[a[i]] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-keyword">if</span> (mp[i] == <span class="hljs-number">0</span>) ans[i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-keyword">if</span> (ans[i]) tot++;<br>    cout &lt;&lt; tot &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-keyword">if</span> (ans[i]) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="d">D</h1><p><strong>题目大意：</strong> 定义一个排列的值是其字典序排名，排列求和的结果是，两排列值之和模排列总数的结果对应的排列。求指定两排列的和。</p><p><strong>难度：</strong> 2000</p><p>这似乎是康托展开的板子题，不过在听讲评之前我并不知道。</p><p>注意到一个排列的排名可如下计算： <span class="math display">$$R_p = \sum _{i = 1} ^{n} (r_i - 1) (n - i)!$$</span> 其中 <span class="math inline"><em>r</em><sub><em>i</em></sub></span> 代表 <span class="math inline"><em>p</em><sub><em>i</em></sub></span> 在 <span class="math inline"><em>p</em><sub><em>k</em></sub>(<em>k</em> ≥ <em>i</em>)</span> 中的排名。因此也可知 <span class="math inline"><em>r</em><sub><em>i</em></sub> ≤ <em>n</em> − <em>i</em>.</span></p><p>我们使用权值线段树记录到当前位置为止 <span class="math inline"><em>x</em></span> 是否还能选，则 <span class="math inline"><em>x</em></span> 的前缀和（不含 <span class="math inline"><em>x</em></span> ）即为 <span class="math inline"><em>x</em></span> 在剩下的数中的排名。</p><p>题目所求为两排列的排名之和，我们考虑以“各位分别相加+进位”的方法处理排名相加的过程。若进位至第零位，则正好满足了模 <span class="math inline"><em>n</em>!</span> 的要求，无需处理。</p><p>进位完成后，只需再根据每一位在剩下数中的排名复原其值即可。这一操作赛时我通过二分查找+线段树来实现，时间复杂度 <span class="math inline"><em>O</em>(<em>n</em>log<sup>2</sup><em>n</em>)</span> ，未能通过此题。使用线段树上二分可将复杂度降至 <span class="math inline"><em>O</em>(<em>n</em>log <em>n</em>)</span> ，可以通过此题。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOR(i,j,k) for (int i = j; i &lt;= k; i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ROF(i,j,k) for (int i = j; i &gt;= k; i--)</span><br><br><span class="hljs-type">int</span> n, m, k;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>(); <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> ((ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>) &amp;&amp; ch != <span class="hljs-string">&#x27;-&#x27;</span>) ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) &#123; ch = <span class="hljs-built_in">getchar</span>(); f = - <span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123; x = x * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span>; ch = <span class="hljs-built_in">getchar</span>(); &#125;<br>    <span class="hljs-keyword">return</span> x * f;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tag</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">SGT</span> &#123;<br><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> l(p) (p &lt;&lt; 1)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> r(p) (p &lt;&lt; 1 | 1)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> mid (l + r) / 2</span><br><br>    <span class="hljs-type">int</span> n;<br>    vector&lt;Info&gt; info;<br>    vector&lt;Tag&gt; tag;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123; info[p] = info[<span class="hljs-built_in">l</span>(p)] + info[<span class="hljs-built_in">r</span>(p)]; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-built_in">addTag</span>(<span class="hljs-built_in">l</span>(p), l, mid, tag[p]);<br>        <span class="hljs-built_in">addTag</span>(<span class="hljs-built_in">r</span>(p), mid + <span class="hljs-number">1</span>, r, tag[p]);<br>        tag[p] = <span class="hljs-built_in">Tag</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addTag</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> Tag &amp;v)</span> </span>&#123;<br>        info[p].<span class="hljs-built_in">apply</span>(v); tag[p].<span class="hljs-built_in">apply</span>(v);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rmodify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">const</span> Tag &amp;v)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt; y || r &lt; x) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (r &lt;= y &amp;&amp; l &gt;= x) &#123; <span class="hljs-built_in">addTag</span>(p, l, r, v); <span class="hljs-keyword">return</span>; &#125;<br>        <span class="hljs-built_in">pushdown</span>(p, l, r);<br>        <span class="hljs-built_in">rmodify</span>(<span class="hljs-built_in">l</span>(p), l, mid, x, y, v);<br>        <span class="hljs-built_in">rmodify</span>(<span class="hljs-built_in">r</span>(p), mid + <span class="hljs-number">1</span>, r, x, y, v);<br>        <span class="hljs-built_in">pushup</span>(p);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pmodify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">const</span> Info &amp;v)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) &#123; info[p] = v; <span class="hljs-keyword">return</span>; &#125;<br>        <span class="hljs-built_in">pushdown</span>(p, l, r);<br>        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">pmodify</span>(<span class="hljs-built_in">l</span>(p), l, mid, x, v);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">pmodify</span>(<span class="hljs-built_in">r</span>(p), mid + <span class="hljs-number">1</span>, r, x, v);<br>        <span class="hljs-built_in">pushup</span>(p);<br>    &#125;<br><br>    <span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt; y || r &lt; x) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Info</span>();<br>        <span class="hljs-keyword">if</span> (r &lt;= y &amp;&amp; l &gt;= x) <span class="hljs-keyword">return</span> info[p];<br>        <span class="hljs-built_in">pushdown</span>(p, l, r);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-built_in">l</span>(p), l, mid, x, y) + <span class="hljs-built_in">query</span>(<span class="hljs-built_in">r</span>(p), mid + <span class="hljs-number">1</span>, r, x, y);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findkth</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> l;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">pushdown</span>(p, l, r);<br>            <span class="hljs-keyword">if</span> (info[<span class="hljs-built_in">l</span>(p)].sum &gt;= k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">findkth</span>(<span class="hljs-built_in">l</span>(p), l, mid, k);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">findkth</span>(<span class="hljs-built_in">r</span>(p), mid + <span class="hljs-number">1</span>, r, k - info[<span class="hljs-built_in">l</span>(p)].sum);<br>            <span class="hljs-built_in">pushup</span>(p);<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">SGT</span>(<span class="hljs-type">int</span> _n) : <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">info</span>(_n &lt;&lt; <span class="hljs-number">2</span>), <span class="hljs-built_in">tag</span>(_n &lt;&lt; <span class="hljs-number">2</span>) &#123;&#125;;<br>    <br>    <span class="hljs-built_in">SGT</span>(vector&lt;Info&gt; vc) : <span class="hljs-built_in">SGT</span>(vc.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> build = [&amp;](<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;<br>            <span class="hljs-keyword">if</span> (l == r) &#123;<br>                info[p] = vc[l];<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-built_in">self</span>(self, <span class="hljs-built_in">l</span>(p), l, mid);<br>            <span class="hljs-built_in">self</span>(self, <span class="hljs-built_in">r</span>(p), mid + <span class="hljs-number">1</span>, r);<br>            <span class="hljs-built_in">pushup</span>(p);<br>        &#125;;<br>        <span class="hljs-built_in">build</span>(build, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rmodify</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">const</span> Tag &amp;v)</span> </span>&#123; <span class="hljs-built_in">rmodify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, x, y, v); &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pmodify</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">const</span> Info &amp;v)</span> </span>&#123; <span class="hljs-built_in">pmodify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, x, v); &#125;<br><br>    <span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, x, y); &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findkth</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">findkth</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, k); &#125;<br><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tag</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> add;<br>    <span class="hljs-built_in">Tag</span>(): <span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-built_in">Tag</span>(<span class="hljs-type">int</span> val): <span class="hljs-built_in">add</span>(val) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(Tag v)</span> </span>&#123; add += v.add; &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum;<br>    <span class="hljs-built_in">Info</span>(): <span class="hljs-built_in">len</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">sum</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-built_in">Info</span>(<span class="hljs-type">int</span> val): <span class="hljs-built_in">len</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">sum</span>(val) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(Tag v)</span> </span>&#123; sum += v.add * len; &#125;<br>&#125;;<br><br>Info <span class="hljs-keyword">operator</span>+(Info a, Info b) &#123;<br>    Info c;<br>    c.len = a.len + b.len;<br>    c.sum = a.sum + b.sum;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">q</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">rq</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">rk</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) p[i] = <span class="hljs-built_in">read</span>() + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) q[i] = <span class="hljs-built_in">read</span>() + <span class="hljs-number">1</span>;<br>    <span class="hljs-function">SGT&lt;Info, Tag&gt; <span class="hljs-title">tp</span><span class="hljs-params">(n)</span>, <span class="hljs-title">tq</span><span class="hljs-params">(n)</span>, <span class="hljs-title">tt</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        tp.<span class="hljs-built_in">pmodify</span>(p[i], <span class="hljs-built_in">Info</span>(<span class="hljs-number">1</span>));<br>        rp[i] = p[i] - tp.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, p[i]).sum;<br>        tq.<span class="hljs-built_in">pmodify</span>(q[i], <span class="hljs-built_in">Info</span>(<span class="hljs-number">1</span>));<br>        rq[i] = q[i] - tq.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, q[i]).sum;<br>        rk[i] = rp[i] + rq[i];<br>    &#125;<br>    <span class="hljs-built_in">ROF</span>(i, n - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) &#123;<br>        rk[i - <span class="hljs-number">1</span>] += rk[i] / (n - i + <span class="hljs-number">1</span>);<br>        rk[i] %= (n - i + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) tt.<span class="hljs-built_in">pmodify</span>(i, <span class="hljs-built_in">Info</span>(<span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        <span class="hljs-type">int</span> u = tt.<span class="hljs-built_in">findkth</span>(rk[i] + <span class="hljs-number">1</span>);<br>        tt.<span class="hljs-built_in">pmodify</span>(u, <span class="hljs-built_in">Info</span>(<span class="hljs-number">0</span>));<br>        cout &lt;&lt; u - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>25春训</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
