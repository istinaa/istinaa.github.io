<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>⌈BUAA CO⌋ p3 课下记录</title>
    <link href="/2025/11/02/%E2%8C%88BUAA%20CO%E2%8C%8Bp3%20%E8%AF%BE%E4%B8%8B%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/11/02/%E2%8C%88BUAA%20CO%E2%8C%8Bp3%20%E8%AF%BE%E4%B8%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p> 各种事情一拖再拖，留给p3课下的时间非常紧张了。四处翻前辈的博客，终于是集百家之所短完成了本 CPU 的设计。笔者翘了合唱团的排练写下这篇设计文档。</p><h3 id="CPU-设计概述"><a href="#CPU-设计概述" class="headerlink" title="CPU 设计概述"></a>CPU 设计概述</h3><p>本次的设计的 <code>Logisim</code> cpu 在作业的要求（<code>add</code>，<code>sub</code>，<code>ori</code>，<code>lw</code>，<code>sw</code>，<code>beq</code>，<code>lui</code>，<code>nop</code>）外，并不支持其他的指令。那可拓展空间很大了。</p><p>总体采用模块化设计。由于我偏爱 <code>Tunnel</code>，各个模块之间并不像其他人的设计一样复杂交错，而是相当分立。从顶层看说这是个 CPU 都不是很让人信服。</p><p><img src="/2025/11/02/%E2%8C%88BUAA%20CO%E2%8C%8Bp3%20%E8%AF%BE%E4%B8%8B%E8%AE%B0%E5%BD%95/main.png" alt="CPU顶层示意图"></p><p>下面我将分模块讲一讲各模块的作用，和一些搭建时的注意点。</p><h3 id="IFU-指令单元"><a href="#IFU-指令单元" class="headerlink" title="IFU: 指令单元"></a>IFU: 指令单元</h3><p><img src="/2025/11/02/%E2%8C%88BUAA%20CO%E2%8C%8Bp3%20%E8%AF%BE%E4%B8%8B%E8%AE%B0%E5%BD%95/IFU_cover.png" alt="IFU外观"></p><p>IFU的接口如下：</p><table><thead><tr><th align="left">信号名</th><th align="left">位宽</th><th align="left">方向</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left"><code>clk</code></td><td align="left">1</td><td align="left">I</td><td align="left"></td></tr><tr><td align="left"><code>reset</code></td><td align="left">1</td><td align="left">I</td><td align="left"></td></tr><tr><td align="left"><code>PC_next</code></td><td align="left">32</td><td align="left">I</td><td align="left">下一条执行指令的地址</td></tr><tr><td align="left"><code>Instr</code></td><td align="left">32</td><td align="left">xxxxxxxxxx69 1#include &lt;stdio.h&gt;2​3#define MAXN 1554#define MAXE 8055​6int n;7int nodeType[MAXN];      &#x2F;&#x2F; 0: 文件, 1: 文件夹8int fileSizeVal[MAXN];   &#x2F;&#x2F; 文件大小(文件夹为0)9int headAdj[MAXN];       &#x2F;&#x2F; 邻接表头10int toEdge[MAXE], nextEdge[MAXE];11int edgeCnt;12​13void add_edge(int u, int v) {14    toEdge[edgeCnt] &#x3D; v;15    nextEdge[edgeCnt] &#x3D; headAdj[u];16    headAdj[u] &#x3D; edgeCnt++;17}18​19int dfs_sum(int u) {20    if (nodeType[u] &#x3D;&#x3D; 0) {21        return fileSizeVal[u];22    }23​24    int size &#x3D; 0;25    for (int e &#x3D; headAdj[u]; e !&#x3D; -1; e &#x3D; nextEdge[e]) {26        int v &#x3D; toEdge[e];27        size +&#x3D; dfs_sum(v);28    }29    return size;30}31​32int main() {33    scanf(“%d”, &amp;n);34​35    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {36        headAdj[i] &#x3D; -1;37        fileSizeVal[i] &#x3D; 0;38        nodeType[i] &#x3D; 0;39    }40    edgeCnt &#x3D; 0;41​42    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) {43        int t, x;44        scanf(“%d %d”, &amp;t, &amp;x);45        if (t &#x3D;&#x3D; 0) {46            nodeType[i] &#x3D; 0;47            fileSizeVal[i] &#x3D; x;48        } else {49            nodeType[i] &#x3D; 1;50            int k &#x3D; x;51            for (int j &#x3D; 0; j &lt; k; j++) {52                int v;53                scanf(“%d”, &amp;v);54                add_edge(i, v);55            }56        }57    }58​59    int q;60    scanf(“%d”, &amp;q);61    while (q–) {62        int id;63        scanf(“%d”, &amp;id);64        int ans &#x3D; dfs_sum(id);65        printf(“%d\n”, ans);66    }67​68    return 0;69}c</td><td align="left">当前执行的指令</td></tr><tr><td align="left"><code>PC</code></td><td align="left">32</td><td align="left">O</td><td align="left">当前执行指令的地址</td></tr></tbody></table><p>其实是将 <strong>PC</strong>（程序计数器）和 <strong>IM</strong>（指令存储器）拼接构成。其中 PC 用寄存器实现，IM 通过 <code>ROM</code> 实现。具体连线如下：</p><p><img src="/2025/11/02/%E2%8C%88BUAA%20CO%E2%8C%8Bp3%20%E8%AF%BE%E4%B8%8B%E8%AE%B0%E5%BD%95/IFU.png" alt="IFU结构"></p><p>这一部分的逻辑可能会让人想起 P0 时搭的有限状态机。寄存器输出的 <code>PC</code> 经过一系列状态转移后得到 <code>PC_next</code> ，然后再重新作用于寄存器。</p><p>值得注意的地方有两点：</p><ul><li><p>根据题目要求：<code>PC</code> 的初始值是 <code>0x00003000</code>，对应的指令存在 <code>ROM</code> 的 <code>0x00000000</code> 位置。因此 <code>PC</code> 需要用一个多路选择器实现等效初始化，而 <code>ROM</code> 读入的地址应为 <code>PC-0x00003000</code>。</p><p>还有一种写法是内部实现不管题目“初值为 <code>0x00003000</code>” 的要求，直接一一对应。而在顶层面向评测机的输出时加上 <code>0x00003000</code>（zhp的写法）应该都可以？</p></li><li><p>可以看到 <code>ROM</code> 读入的是 $2\sim13$ 位，而非 $0\sim 11$ 位。这是因为 <code>PC</code> 和 <code>ROM</code> 计算地址的方式不一样。前者认为每 $+4$ 是下个指令，后者则认为每 $+1$ 是下个指令。为了使二者的操作能对上，需要将 <code>PC</code> 除以 $4$，也就是舍弃了最后两位。</p></li></ul><h3 id="NPC-此地址计算单元"><a href="#NPC-此地址计算单元" class="headerlink" title="NPC: 此地址计算单元"></a>NPC: 此地址计算单元</h3><p><img src="/2025/11/02/%E2%8C%88BUAA%20CO%E2%8C%8Bp3%20%E8%AF%BE%E4%B8%8B%E8%AE%B0%E5%BD%95/NPC_cover.png" alt="NPC外观"></p><p>NPC 的接口如下：</p><table><thead><tr><th>信号名</th><th>位宽</th><th>方向</th><th>备注</th></tr></thead><tbody><tr><td>PC</td><td>32</td><td>I</td><td>当前指令的地址</td></tr><tr><td>immExtended</td><td>32</td><td>I</td><td>经过扩展的 32 位立即数</td></tr><tr><td>isBeq?</td><td>1</td><td>I</td><td>当前指令是否为 <code>Beq</code></td></tr><tr><td>ALU&#x3D;0?</td><td>1</td><td>I</td><td>ALU 计算结果是否为 0</td></tr><tr><td>PC_next</td><td>32</td><td>O</td><td>下条指令的地址</td></tr></tbody></table><p>具体的连线是下面这样。唯一需要注意的地方可能就是 <code>Beq</code> 指令跳转除了加立即数外还要加 $4$。不过这部分在加入 <code>J</code> 类型指令后需要大改。</p><p><img src="/2025/11/02/%E2%8C%88BUAA%20CO%E2%8C%8Bp3%20%E8%AF%BE%E4%B8%8B%E8%AE%B0%E5%BD%95/NPC.png" alt="NPC结构"></p><h3 id="ALU-计算单元"><a href="#ALU-计算单元" class="headerlink" title="ALU: 计算单元"></a>ALU: 计算单元</h3><p><img src="/2025/11/02/%E2%8C%88BUAA%20CO%E2%8C%8Bp3%20%E8%AF%BE%E4%B8%8B%E8%AE%B0%E5%BD%95/ALU_cover.png" alt="ALU外观"></p><p>ALU 的接口如下：</p><table><thead><tr><th align="left">信号名</th><th align="left">位宽</th><th align="left">方向</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">inA</td><td align="left">32</td><td align="left">I</td><td align="left"></td></tr><tr><td align="left">inB</td><td align="left">32</td><td align="left">I</td><td align="left"></td></tr><tr><td align="left">op</td><td align="left">2</td><td align="left">I</td><td align="left">运算种类，详情见下表。</td></tr><tr><td align="left">res</td><td align="left">32</td><td align="left">O</td><td align="left">ALU 运算结果</td></tr><tr><td align="left">isZero?</td><td align="left">1</td><td align="left">O</td><td align="left">判断结果是否为 $0$，用于 <code>NPC</code> 模块中的 <code>beq</code> 判等。</td></tr></tbody></table><table><thead><tr><th align="left">OP</th><th align="left">操作类型</th></tr></thead><tbody><tr><td align="left">00</td><td align="left">A+B</td></tr><tr><td align="left">01</td><td align="left">A-B</td></tr><tr><td align="left">10</td><td align="left">A or B</td></tr><tr><td align="left">11</td><td align="left">B &lt;&lt; 16</td></tr></tbody></table><p>这些肯定是不够的。感觉最好要预留出两位操作指令的空间。</p><p><img src="/2025/11/02/%E2%8C%88BUAA%20CO%E2%8C%8Bp3%20%E8%AF%BE%E4%B8%8B%E8%AE%B0%E5%BD%95/ALU.png" alt="ALU结构"></p><h3 id="GRF-寄存器堆"><a href="#GRF-寄存器堆" class="headerlink" title="GRF: 寄存器堆"></a>GRF: 寄存器堆</h3><p><img src="/2025/11/02/%E2%8C%88BUAA%20CO%E2%8C%8Bp3%20%E8%AF%BE%E4%B8%8B%E8%AE%B0%E5%BD%95/GRF_cover.png" alt="GRF外观"></p><p>GRF的接口如下：</p><table><thead><tr><th>信号名</th><th>位宽</th><th>方向</th><th>备注</th></tr></thead><tbody><tr><td>A1</td><td>5</td><td>I</td><td>地址1，读出寄存器数据到 <code>RD1</code></td></tr><tr><td>A2</td><td>5</td><td>I</td><td>地址2，读出寄存器数据到 <code>RD2</code></td></tr><tr><td>A3</td><td>5</td><td>I</td><td>写地址</td></tr><tr><td>reset</td><td>1</td><td>I</td><td></td></tr><tr><td>clk</td><td>1</td><td>I</td><td></td></tr><tr><td>W_Enable</td><td>1</td><td>I</td><td>写使能信号</td></tr><tr><td>W_Data</td><td>32</td><td>I</td><td>写入的内容</td></tr><tr><td>RD1</td><td>32</td><td>O</td><td><code>A1</code> 对应的数据</td></tr><tr><td>RD2</td><td>32</td><td>O</td><td><code>A2</code> 对应的数据</td></tr></tbody></table><p>实现这边直接复用了P0课下搭的。连线很繁琐，但总得来说没什么好说。</p><p><img src="/2025/11/02/%E2%8C%88BUAA%20CO%E2%8C%8Bp3%20%E8%AF%BE%E4%B8%8B%E8%AE%B0%E5%BD%95/GRF.png" alt="GRF结构"></p><h3 id="DM-内存组"><a href="#DM-内存组" class="headerlink" title="DM: 内存组"></a>DM: 内存组</h3><p><img src="/2025/11/02/%E2%8C%88BUAA%20CO%E2%8C%8Bp3%20%E8%AF%BE%E4%B8%8B%E8%AE%B0%E5%BD%95/DM_cover.png" alt="DM外观"></p><p>DM 的接口如下：</p><table><thead><tr><th>信号名</th><th>位宽</th><th>方向</th><th>备注</th></tr></thead><tbody><tr><td>Address</td><td>32</td><td>I</td><td>访问的内存地址</td></tr><tr><td>Data</td><td>32</td><td>I</td><td></td></tr><tr><td>clk</td><td>1</td><td>I</td><td></td></tr><tr><td>WE</td><td>1</td><td>I</td><td>写使能</td></tr><tr><td>clr</td><td>1</td><td>I</td><td></td></tr><tr><td>RD</td><td>32</td><td>O</td><td>读出内存的数据</td></tr></tbody></table><p>其实就是一个 <code>ROM</code> 。如果加入半字和字节的读写就麻烦了，此处不涉及。</p><p><img src="/2025/11/02/%E2%8C%88BUAA%20CO%E2%8C%8Bp3%20%E8%AF%BE%E4%B8%8B%E8%AE%B0%E5%BD%95/DM.png" alt="DM结构"></p><h3 id="EXT-扩展单元"><a href="#EXT-扩展单元" class="headerlink" title="EXT: 扩展单元"></a>EXT: 扩展单元</h3><p><img src="/2025/11/02/%E2%8C%88BUAA%20CO%E2%8C%8Bp3%20%E8%AF%BE%E4%B8%8B%E8%AE%B0%E5%BD%95/EXT_cover.png" alt="EXT外观"></p><p>用于将 $16$ 位的立即数扩展为 $32$ 位。接口如下：</p><table><thead><tr><th>信号名</th><th>位宽</th><th>方向</th><th>备注</th></tr></thead><tbody><tr><td>in</td><td>16</td><td>I</td><td>原立即数</td></tr><tr><td>ExtOp</td><td>1</td><td>I</td><td>扩展类型（1: 符号扩展 | 0: 零扩展）</td></tr><tr><td>out</td><td>32</td><td>O</td><td>扩展后的立即数</td></tr></tbody></table><p>大概是最简单的一个部件了。布线如下：</p><p><img src="/2025/11/02/%E2%8C%88BUAA%20CO%E2%8C%8Bp3%20%E8%AF%BE%E4%B8%8B%E8%AE%B0%E5%BD%95/EXT.png" alt="EXT结构"></p><h3 id="CTRL-控制器"><a href="#CTRL-控制器" class="headerlink" title="CTRL: 控制器"></a>CTRL: 控制器</h3><p><img src="/2025/11/02/%E2%8C%88BUAA%20CO%E2%8C%8Bp3%20%E8%AF%BE%E4%B8%8B%E8%AE%B0%E5%BD%95/CTRL_cover.png" alt="CTRL外观"></p><p>控制器接口如下：</p><table><thead><tr><th>信号</th><th>位宽</th><th>方向</th><th>备注</th></tr></thead><tbody><tr><td>Opcode[5:0]</td><td>6</td><td>I</td><td>指令的 31-26 位</td></tr><tr><td>func[5:0]</td><td>6</td><td>I</td><td>指令的 5-0 位</td></tr><tr><td>ToRegD</td><td>1</td><td>O</td><td>寄存器指示信号（1: 写入<code>rd</code></td></tr><tr><td>ALUsrc</td><td>1</td><td>O</td><td>ALU功能选择信号（1: 用 <code>immExtended</code> | 0: 用 RD2）</td></tr><tr><td>Mem2Reg</td><td>1</td><td>O</td><td>寄存器堆数据选择信号（1: 从 DM 写入| 0: 从 ALU 写入）</td></tr><tr><td>RegWrite</td><td>1</td><td>O</td><td>寄存器堆写入使能信号</td></tr><tr><td>MemWrite</td><td>1</td><td>O</td><td>DM 写入使能信号</td></tr><tr><td>isBeq</td><td>1</td><td>O</td><td>是否是 <code>BEQ</code> 指令</td></tr><tr><td>ExtOp</td><td>1</td><td>O</td><td>EXT扩展类型（1: 符号拓展 | 0: 0扩展）</td></tr><tr><td>ALUOp[1:0]</td><td>2</td><td>O</td><td>ALU 控制信号</td></tr></tbody></table><p>控制器可以说是整个CPU的大脑。与逻辑部分确保只有对应指令为通，而或逻辑部分相当于完成了译码的任务，将各指令触发的信号点亮。</p><p>连线的时候需要先考虑对应指令需要用到哪些信号，列出真值表，再仔细地完成连接。排线方法参考了先人的博客，总体还算美观。</p><p><img src="/2025/11/02/%E2%8C%88BUAA%20CO%E2%8C%8Bp3%20%E8%AF%BE%E4%B8%8B%E8%AE%B0%E5%BD%95/CTRL.png" alt="CTRL结构"></p><p>一个避免连错线的小技巧是先把 <code>Op</code> 和 <code>func</code> 点成指令的样子，然后无脑连亮线就行了。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>基本上是照着几篇博客依葫芦画瓢搭出来的，截止日才堪堪做完。计算机组成原理，太困难。</p><p>一个小插曲是我第一次提交交错了 <code>.circ</code> 文件的版本，但我没有发现。而是用眼睛盯了很久运行样例时 <code>Logisim</code> 和 <code>MARS</code> 中的情况是否有差别。一小时后我确认没差别，就又交了一发。结果直接过了。</p><p>如何提高电路的可维护性、可扩展性，以便上机时提交代码，还需学习。</p><h3 id="测试方案"><a href="#测试方案" class="headerlink" title="测试方案"></a>测试方案</h3><p>我也尝试着折腾了一下学长们留下的自动化评测脚本，但是始终没有运行成功。最后还是采用了最原始的瞪眼调试法，希望不要出 BUG。</p><p>测试流程大概就是：</p><ul><li><p>在 <code>MARS</code> 里编写 <code>MIPS</code> 测试程序。我这边使用的程序只是在官方提供的样例基础上做了一定的修改。下面贴出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs assembly">ori $a0, $0, 123<br>ori $a1, $a0, 456<br>lui $a2, 123         <br>lui $a3, 0xffff       <br>ori $a3, $a3, 0xffff    <br>add $s0, $a0, $a2   <br>add $s1, $a0, $a3   <br>add $s2, $a3, $a3    <br>sub $s0, $a0, $a2    <br>sub $s1, $a0, $a3   <br>sub $s2, $a3, $a3    <br>ori $t0, $0, 0x0000<br>sw $a0, 0($t0)<br>sw $a1, 4($t0)<br>sw $a2, 8($t0)<br>sw $a3, 12($t0)<br>sw $s0, 16($t0)<br>sw $s1, 20($t0)<br>sw $s2, 24($t0)<br>lw $a0, 0($t0)<br>lw $a1, 12($t0)<br>sw $a0, 28($t0)<br>sw $a1, 32($t0)<br>ori $t0, $0, 0x0020<br>sw $a0, 0($t0)<br>sw $a1, -4($t0)<br>sw $a2, -8($t0)<br>sw $a3, -12($t0)<br>lw $a0, 0($t0)<br>lw $a1, -12($t0)<br>ori $a0, $0, 1<br>ori $a1, $0, 2<br>ori $a2, $0, 1<br>beq $a0, $a1, loop1    <br>beq $a0, $a2, loop2    <br>loop1:sw $a0, 36($t0)<br>loop2:sw $a1, 40($t0)<br>sub $a1, $a1, $a0<br>nop<br>beq $a1, $a2, loop2  <br>nop<br></code></pre></td></tr></table></figure></li><li><p>将 <code>.asm</code> 文件导出为 $16$ 进制码。然后在 <code>IFU</code> 模块的 <code>ROM</code> 中导入。</p></li><li><p>一边单步执行 <code>MARS</code>，一边双击 <code>Logisim</code> 的时钟。观察寄存器、内存的变化和 <code>Logisim</code> 所示是否一致。</p></li></ul><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><p>1. </p><p>   <strong>Q：</strong> 上面我们介绍了通过 FSM 理解单周期 CPU 的基本方法。请大家指出单周期 CPU 所用到的模块中，哪些发挥状态存储功能，哪些发挥状态转移功能。</p><p>   **A： ** 状态存储：PC、GRF、DM 状态转移：NPC、ALU、CTRL</p><p>2. </p><p>   <strong>Q：</strong> 现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。</p><p>   <strong>A：</strong> 还算合理。ROM是只读存储器，数据保有性好，可以用来存储指令；RAM可读可写，满足DM的需求；GRF是寄存器堆，对读写速度要求较高，适合用寄存器实现。</p><p>   但用ROM存储指令使得CPU变成一次性的了，难以扩展。</p><p>3. </p><p>   <strong>Q：</strong> 在上述提示的模块之外，你是否在实际实现时设计了其他的模块？如果是的话，请给出介绍和设计的思路。</p><p>   **A： ** 暂时没有，但有一些在顶层看不够简洁美观的线路（如 <code>Splitter</code>、寄存器选择电路等）也可以被封装一下。</p><p>4. </p><p>   <strong>Q：</strong> 事实上，实现 nop 空指令，我们并不需要将它加入控制信号真值表，为什么？请给出你的理由。</p><p>   <strong>A：</strong> nop的机器码相当于执行 <code>sll $0, $0, 0</code>，执行后没有任何影响。</p><p>5. </p><p>   <strong>Q：</strong> 阅读 Pre 的 <a href="http://cscore.buaa.edu.cn/tutorial/mips/mips-6/mips6-1/">“MIPS 指令集及汇编语言”</a> 一节中给出的测试样例，评价其强度（可从各个指令的覆盖情况，单一指令各种行为的覆盖情况等方面分析），并指出具体的不足之处。</p><p>   <strong>A：</strong> 还算全面，但没有测试 <code>offset</code> 为负数的情况。此外，没有测试 <code>nop</code> 指令。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ol><li><a href="https://blog.csdn.net/i_want_ak_noip/article/details/134204098">2023北航计组p3课下部分_北航机组单周期logisim-CSDN博客</a></li><li><a href="https://mercuryrecords.github.io/p/co-p3-doc/">CO | P3 - Logisim 单周期 CPU 设计文档</a></li><li><a href="https://zhhangbian.github.io/2024/01/10/%E8%AE%A1%E7%BB%84-%E5%AE%9E%E9%AA%8C-P3/">计组-实验-P3 | 浮泛之舟</a></li><li><a href="http://cscore.buaa.edu.cn/tutorial/P3/P3-3/">控制器设计 - 计算机组成教程</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⌈BUAA CO⌋ p2 记录</title>
    <link href="/2025/10/29/%E2%8C%88BUAA%20CO%E2%8C%8Bp2%20%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/10/29/%E2%8C%88BUAA%20CO%E2%8C%8Bp2%20%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>P2 的考察内容是 <code>MIPS</code> 。虽然课下早早把非附加题都做了，但复习任务一拖再拖，最后拖到了上课前一小时内。由于课下的全排列题我是打表做的，所以我甚至没研究 <code>MIPS</code> 中递归怎么写。查阅往年 Blog 发现递归是必考点后，我明白这次要寄了，但也难以回天。</p><p>本次所有题目都给了 C 语言代码，我建议老老实实照着翻译哈。因为我灵机一动想出来的第二题做法喜提 WA 了，最后发现贪心是假做法。</p><hr><h3 id="第一题（Factory）"><a href="#第一题（Factory）" class="headerlink" title="第一题（Factory）"></a>第一题（Factory）</h3><blockquote><p><strong>题意</strong></p><p>给出若干个点，找出其中处于第二或四象限、与坐标轴围成的面积最大的点。如果有多个面积相等，输出最早出现的一个。</p></blockquote><p>这题主要的考点是分支语句的写法。要注意标签名的区分，不要不小心重名了。</p><p>最大的坑点在于面积是一个 $10^{18}$ 级别的数，要用两个寄存器分别存乘积的高位和低位。比较时需将高位作为第一关键词。</p><hr><h3 id="第二题（K-Increasing）"><a href="#第二题（K-Increasing）" class="headerlink" title="第二题（K_Increasing）"></a>第二题（K_Increasing）</h3><p>给定一个下标从 0 开始包含 n 个正整数的数组 arr ，和一个正整数 k 。</p><p>如果对于每个满足 k &lt;&#x3D; i &lt;&#x3D; n-1 的下标 i ，都有 arr[i-k] &lt;&#x3D; arr[i] ，那么我们称 arr 是 K 递增 的。例如，arr &#x3D; [4, 1, 5, 2, 6, 2] 对于 k &#x3D; 2 是 K 递增的。</p><p>输出使数组成为 K 递增数组所需的最少操作次数（一次操作指修改数组中一个元素的值）</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_N 20</span><br><br><span class="hljs-comment">// 计算单个子序列的 LIS 长度（最长递增子序列长度）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">computeLIS</span><span class="hljs-params">(<span class="hljs-type">int</span> *subseq, <span class="hljs-type">int</span> m)</span> &#123;<br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-type">int</span> dp[MAX_N];<br>    <span class="hljs-type">int</span> maxLen = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        dp[i] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (subseq[j] &lt;= subseq[i]) &#123;<br>                dp[i] = dp[i] &gt; (dp[j] + <span class="hljs-number">1</span>) ? dp[i] : (dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        maxLen = maxLen &gt; dp[i] ? maxLen : dp[i];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> maxLen;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kIncreasing</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> arrSize, <span class="hljs-type">int</span> k)</span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        <span class="hljs-type">int</span> subseq[MAX_N]; <br>        <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; arrSize; j += k) &#123;<br>            subseq[m++] = arr[j];<br>        &#125;<br>        <span class="hljs-type">int</span> lisLen = computeLIS(subseq, m);<br>        ans += (m - lisLen);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> n, k;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-type">int</span> arr[MAX_N];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>    &#125;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;k);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, kIncreasing(arr, n, k));<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Folder-Size"><a href="#Folder-Size" class="headerlink" title="Folder Size"></a>Folder Size</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>给定一个项目的目录树，每个节点要么是文件，要么是文件夹。请实现一个 MIPS 程序，支持多次查询：对给定的节点编号，输出其“子树总大小”（该文件夹内所有文件大小之和，包含所有子文件夹内的文件）。</p><h2 id="具体要求"><a href="#具体要求" class="headerlink" title="具体要求"></a>具体要求</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>第一行：整数 ，表示节点总数（节点编号为 ）。</p><p>接下来 段节点描述（按编号顺序从小到大给出，即第 段节点描述对应第 个节点）：</p><ul><li>若为文件：第一行为 ，第二行一个整数 ，表示文件大小。</li><li>若为文件夹：第一行 ，第二行一个整数 。接下来 行依次给出 个整数，为该文件夹的子节点编号。</li></ul><p>然后一行输入一个整数 ，表示查询次数。</p><p>接下来 行：每行一个整数 ，表示查询该节点为根的子树总大小（保证 合法）</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>对每个查询输出一行：若查询的节点为文件，直接输出其大小；若为文件夹，输出其子树总大小（目录本身大小视为零）。</p><h2 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 155</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXE 805</span><br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> nodeType[MAXN];      <span class="hljs-comment">// 0: 文件, 1: 文件夹</span><br><span class="hljs-type">int</span> fileSizeVal[MAXN];   <span class="hljs-comment">// 文件大小(文件夹为0)</span><br><span class="hljs-type">int</span> headAdj[MAXN];       <span class="hljs-comment">// 邻接表头</span><br><span class="hljs-type">int</span> toEdge[MAXE], nextEdge[MAXE];<br><span class="hljs-type">int</span> edgeCnt;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">add_edge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> &#123;<br>    toEdge[edgeCnt] = v;<br>    nextEdge[edgeCnt] = headAdj[u];<br>    headAdj[u] = edgeCnt++;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">dfs_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nodeType[u] == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> fileSizeVal[u];<br>    &#125;<br><br>    <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = headAdj[u]; e != <span class="hljs-number">-1</span>; e = nextEdge[e]) &#123;<br>        <span class="hljs-type">int</span> v = toEdge[e];<br>        size += dfs_sum(v);<br>    &#125;<br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        headAdj[i] = <span class="hljs-number">-1</span>;<br>        fileSizeVal[i] = <span class="hljs-number">0</span>;<br>        nodeType[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    edgeCnt = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> t, x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;t, &amp;x);<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-number">0</span>) &#123;<br>            nodeType[i] = <span class="hljs-number">0</span>;<br>            fileSizeVal[i] = x;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nodeType[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> k = x;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) &#123;<br>                <span class="hljs-type">int</span> v;<br>                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;v);<br>                add_edge(i, v);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> q;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;q);<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">int</span> id;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;id);<br>        <span class="hljs-type">int</span> ans = dfs_sum(id);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>上机记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⌈BUAA CO⌋ p1 记录</title>
    <link href="/2025/10/27/%E2%8C%88BUAA%20CO%E2%8C%8Bp1%20%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/10/27/%E2%8C%88BUAA%20CO%E2%8C%8Bp1%20%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>P1 的考察内容是 Verilog。我一直觉得这种硬件描述语言很抽象，脑子里对各部分知识都是晕晕的。因此考前还是很慌的。所幸考试内容没有涉及一些迷人的特性，还是顺利通过了。</p><hr><h3 id="第一题（异或卷积）"><a href="#第一题（异或卷积）" class="headerlink" title="第一题（异或卷积）"></a>第一题（异或卷积）</h3><blockquote><p><strong>题意</strong>：</p><p>输入 $a[0:35]$ 和 $b[0:8]$， 分别表示 $6\times 6$ 的待卷积矩阵和 $3\times 3$ 的卷积核。输出 $ans[0:15]$ 表示卷积后的 $4\times 4$ 矩阵。</p><p>此处卷积操作可用下列公式表达：<br>$$<br>ans[i][j]&#x3D;\bigoplus_{k&#x3D;0}^{2} \bigoplus_{l&#x3D;0}^{2} a[i+k][j+l] \wedge b[k][l]<br>$$</p></blockquote><p>印象里这题没有遇到什么困难，只要注意 Verilog 中 <code>for</code> 循环的写法即可。运行时先枚举卷积部分的左上角坐标，再枚举卷积部分内部的坐标，用一个 <code>reg</code> 变量记录异或的结果即可。</p><hr><h3 id="第二题（音符记录器）"><a href="#第二题（音符记录器）" class="headerlink" title="第二题（音符记录器）"></a>第二题（音符记录器）</h3><blockquote><p><strong>题意：</strong></p><p>每当时钟上升沿到达，优先触发同步复位，否则根据 <code>op</code> 信号决定操作。</p><ul><li><code>op = 00</code> ：所有已记录的音符往前移 $1$ 位，位置为 $0$ 的音符被丢弃，将 <code>note_in</code>  添加到 $127$ 位置上。输出不变。</li><li><code>op = 01</code> ：将 <code>query</code> 位置的音符输出到 <code>note_out</code>。</li><li><code>op = 10</code> ：无效操作，保持上一周期输出。</li><li><code>op = 11</code> ：统计 $128$ 个音符中，值等于 <code>query</code> 的数量。结果输出到 <code>note_out</code> 上。</li></ul></blockquote><p><code>01</code> 和 <code>11</code> 指令就不多说了，在 <code>switch</code> 对应语句中统计输出即可。我卡住的地方是 <code>Verilog</code> 中怎样去实现这个全部左移。实际上非常简单，直接在 <code>for</code> 循环中用非阻塞赋值更新就行了。</p><p>但我确实走了不少弯路，一开始过分拘泥于状态机的写法。用了 <code>status</code> 和 <code>nextStatus</code> 两个状态来回交换，把自己都整晕了。这就完全是画蛇添足了。</p><hr><h3 id="第三题（json-序列检验）"><a href="#第三题（json-序列检验）" class="headerlink" title="第三题（json 序列检验）"></a>第三题（json 序列检验）</h3><blockquote><p><strong>题意：</strong></p><p>串行输入形如 <code>&#123;&quot;key1&quot;:&quot;value1&quot;,&quot;key2&quot;:&quot;value2&quot;,&quot;key3&quot;:&quot;value3&quot;&#125; &#123;&quot;key4&quot;:&quot;value4&quot;&#125;&#123;&quot;key5&quot;:&quot;value5&quot;&#125;</code> 的 <code>json</code> 文件。</p><p>其中每对大括号中为一个 <code>json</code> 序列，相邻 <code>json</code> 序列间可能有若干空格。每个 <code>json</code> 序列结束时输出当前序列键值对数量 <code>cur_num</code>，每次 <code>cur_num</code> 更新时同步更新 <code>max_num</code>。</p><p>输入保证非法序列只有一种：存在某个字符串为空串。非法序列的 <code>cur_num</code> 计为 $0$。</p></blockquote><p>我的做法是设了很多状态（匹配了 <code>&#123;</code>，<code>&#123;&quot;</code>，<code>&#123;&quot;**&quot;</code> ……&#x2F; 非法状态）然后根据读入的字符做状态转移。其中在一处非法状态转移的地方写错了，肉眼盯了半天无果，只能提前排队等待助教拷问。（下文会讲述详细问答过程）</p><p>没想到问答结束后不久，忽然意识到自己的错误，修正完就过了。</p><p>考后交流发现只有我老老实实写了这么多状态转移。大家都利用题目中“保证非法序列只有一种”这一条件，大大简化了状态构成，直接数冒号个数。那我的写法就显得很愚蠢了，好在也是通过了。</p><hr><h3 id="助教问答"><a href="#助教问答" class="headerlink" title="助教问答"></a>助教问答</h3><p>这场上机被分配在三号实验室，一进门就看到监考的助教有向巨。</p><p>2h结束的时候第三题还没调出来错误在哪，只能提前举手等待助教前来拷打。果不其然一只企鹅朝我飞奔而来。检查完我的 Testbench 后，展开了下面的对话：</p><p><strong>Q：</strong> <code>$finish</code> 是用来干嘛的？</p><p><strong>A：</strong> （有点懵，不知道如何回答）就是写在 Testbench 最后的那个吗？（慌）</p><p><strong>Q：</strong> 啊对，但是很多人不写。同步复位的写法是怎样的？</p><p><strong>A：</strong> 就是…<code>always@(*)</code>…（灵机一动，以为第三题是同步复位，直接翻出第三题代码）就这样。</p><p><strong>Q：</strong> 不对！</p><p>我一看，完辣。尝试解释，但是向巨表示更多的不能告诉我。问答就这样匆匆忙忙连滚带爬地结束了。</p>]]></content>
    
    
    <categories>
      
      <category>上机记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⌈BUAA CO⌋ p0 记录</title>
    <link href="/2025/10/14/%E2%8C%88BUAA%20CO%E2%8C%8Bp0%20%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/10/14/%E2%8C%88BUAA%20CO%E2%8C%8Bp0%20%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>P0 的考察内容是 Logisim。题目顺序是按照笔者做题顺序来的，与官方排序无关。</p><hr><h3 id="第一题（组合电路）"><a href="#第一题（组合电路）" class="headerlink" title="第一题（组合电路）"></a>第一题（组合电路）</h3><blockquote><p><strong>题意</strong>：</p><p>某幢楼房共有 $0\sim 3$ 四层。以 $8$ 位二进制形式给出每层的人数（保证各不相同且均不为 $0$），以独热码的形式给出电梯初始时刻所在的楼层。</p><p>电梯会在载入初始楼层所有人后，前往剩下楼层中人数最多的楼层。到达后再载入该楼层的所有人，然后前往剩下楼层中人数最多的楼层……重复直至各层人数都为 $0$ 时停止。</p><p>以 $8$ 位二进制输出电梯移动的总楼层数。</p></blockquote><p>没有做太多思考就急忙开搭了，导致这道题实现得非常差。简单记录一下我的神人暴力做法，如下：</p><p>首先用一个 <code>MUX</code> 把起始楼层的独热码转化成 $2$ 位二进制数，最终答案根据起始楼层进行分类。</p><p><img src="/2025/10/14/%E2%8C%88BUAA%20CO%E2%8C%8Bp0%20%E8%AE%B0%E5%BD%95/one-hot.png"></p><p>接下来是对各起始楼层的答案进行分类，笔者构建得非常丑陋。</p><p>确定了起始楼层后，由于剩下的三个楼层各不相同，所以大小排序只有 $6$ 种。用比较器对两两间的大小关系编码，再用 <code>Splitter</code> 将三个大小关系编为 $3$ 位二进制数，作为 <code>MUX</code> 的读入。</p><p>除了循环大于和循环小于的 $2$ 种情况，其余 $6$ 种大小关系都可能存在。至于每种情况对应的答案…我是用 <code>C++</code> 打完表手动输入的。</p><p><img src="/2025/10/14/%E2%8C%88BUAA%20CO%E2%8C%8Bp0%20%E8%AE%B0%E5%BD%95/%E6%89%93%E8%A1%A8.png"></p><p>将各个初始楼层讨论完就完成了这道题！如果你的做法和我一样，恭喜你考场上大半时间都栽这了。</p><hr><h3 id="第二题（Mealy机）"><a href="#第二题（Mealy机）" class="headerlink" title="第二题（Mealy机）"></a>第二题（Mealy机）</h3><blockquote><p><strong>题意：</strong></p><p>每个周期读入 $2$ 位操作码 $op$ 和 $8$ 位操作数 $x$，输出计算结果并将结果存入寄存器。操作码与运算的对应关系如下表：</p><table><thead><tr><th>$op$</th><th>功能</th></tr></thead><tbody><tr><td>$00$</td><td>将寄存器清零</td></tr><tr><td>$01$</td><td>将寄存器数值左移一位，加上 $x$</td></tr><tr><td>$10$</td><td>将寄存器数值左移一位，减去 $x$</td></tr><tr><td>$11$</td><td>将寄存器数值左移一位，异或上 $x$</td></tr></tbody></table><p><strong>注：</strong> 要求使用 Mealy 机，同一周期内输入可能不停变化，但只要时钟上升沿没有到达，状态就不会被写入寄存器。</p></blockquote><p>前后反复 <code>WA</code> 了四五发，问题出在题面的理解上。</p><p>做的时候，看到 <code>op==0</code> 对应的功能是“将寄存器清零”这样一个斩钉截铁的动词词组，先入为主地觉得这是一个立即执行的异步复位，不用遵守“上升沿不到达，状态就不会被写入寄存器”的题面约束。</p><p>直到下发提示，我才意识到复位后的状态也是状态。那还说啥了，理解能力已经不存在了。</p><p>其他就不多说了，结构就是经典得不能再经典的 <code>Mealy</code> 机。</p><hr><h3 id="第三题（Moore机）"><a href="#第三题（Moore机）" class="headerlink" title="第三题（Moore机）"></a>第三题（Moore机）</h3><blockquote><p><strong>题意：</strong></p><p>搭建一个识别串行输入中“起起伏起”规律的 Moore 状态机。</p><p>每个周期输入一个位宽 $5$ 的无符号数，当最近四个周期输入满足“起起伏起”，输出 $1$，否则输出 $0$。（支持循环检测）</p><p><strong>注：</strong> 在初始状态和复位后，默认的第零项为 <code>5&#39;d7</code>。</p></blockquote><p>这题的难点在于如何去表示“第零项为 $7$” 这件事。自己做的时候一头雾水，看了提示之后意识到可以用计时器来检测是否为初始状态。</p><p>用寄存器存上一个周期的输入，记为 <code>last</code>。如果计时器为 $0$，则不存在上个周期，<code>last</code> 视为 <code>5&#39;d7</code>。将 <code>now</code> 和 <code>last</code> 间的大小关系作为起落 <code>Moore</code> 机的输入。这一部分结构如图所示：</p><p><img src="/2025/10/14/%E2%8C%88BUAA%20CO%E2%8C%8Bp0%20%E8%AE%B0%E5%BD%95/P0_Moore.png"></p><p>需要注意的是此处需将 <code>Counter</code>的 <code>Action On Overflow</code> 属性设置为 <code>Stay at Value</code>。笔者一开始没注意此处，选用了默认的 <code>Wrap around</code> ,导致 <code>cnt</code> 一直处于 $0&#x2F;1$ 交替状态，不能正确运行。</p><p>得到了最新周期起落情况后，搭建状态机就是比较容易的事了。按照匹配了多少有效位划分状态，需要 $3$ 位二进制数来表示。很容易画出下图的状态转移图，手动输入真值表生成转移电路，<code>Moore</code> 机基本就搭完了。</p><p><img src="/2025/10/14/%E2%8C%88BUAA%20CO%E2%8C%8Bp0%20%E8%AE%B0%E5%BD%95/trans.png"></p><hr><p>有惊无险地通过了 P0，下周 P1 的主题是更为陌生的 <code>Verilog</code> 。哦哦大考还在后面。</p>]]></content>
    
    
    <categories>
      
      <category>上机记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⌈离散数学II⌋ 第二章</title>
    <link href="/2025/10/09/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6II-2/"/>
    <url>/2025/10/09/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6II-2/</url>
    
    <content type="html"><![CDATA[<h3 id="二、关系"><a href="#二、关系" class="headerlink" title="二、关系"></a>二、关系</h3><hr><h4 id="2-1-关系及其性质"><a href="#2-1-关系及其性质" class="headerlink" title="2.1 关系及其性质"></a>2.1 关系及其性质</h4><p><strong>关系的定义：</strong> 设 $A_1,A_2,\dots A_n$ 为 $n$ 个集合， $R\subseteq A_1\times A_2\times \dots \times A_n$，则称 $R$ 为这 $n$ 个集合间的 $n$ 元关系。</p><p>用序偶来表示关系。</p><div class="note note-success">            <p>比如考虑集合 $A &#x3D; {1,2,3}$ 上的小于关系。我们可以用序偶 $\left \langle  i,j \right \rangle$ 表示 $i&lt;j$ ，令：$R_&lt; &#x3D; {\left \langle 1,2 \right \rangle , \left \langle 1,3 \right \rangle , \left \langle 2,3 \right \rangle}$</p>          </div><p><strong>两种特殊的关系：</strong></p><ul><li><p>$X$ 上的 <strong>全关系</strong> ：<br>$$<br>U_X &#x3D; {&lt;x_i,x_j&gt;\mid x_i,x_j\in X} &#x3D; X\times X<br>$$</p></li><li><p>$X$ 上的 <strong>恒等关系</strong> ：<br>$$<br>I_X &#x3D; {&lt;x,x&gt;\mid x\in X}<br>$$</p></li></ul><p><strong>关系的定义域和值域</strong>（接下来只讨论二元关系）：</p><p>设 $R\subseteq A\times B$，$R$ 中所有 $\left \langle x,y \right \rangle $ 中 $x$ 组成的集合称为 $R$ 的定义域，记作 $\text{dom}(R)$ 。所有 $y$ 组成的集合称为 $R$ 的值域，记作 $\text{ran}(R)$。</p><p>除了上文所说的序偶表示以外，还可以用关系图（$x,y$ 间连接有向边），关系矩阵（存在 $\left \langle x,y \right \rangle $ 时 $M_{x,y}$ 取 $1$ 否则取 $0$）</p><p><strong>关系的性质</strong>：</p><ul><li><p>自反性：$x\in X$ ，则 $\left \langle x,x \right \rangle\in R$ 。</p></li><li><p>反自反性：$x\in X$ ，则 $\left \langle x,x \right \rangle\notin R$ 。</p></li><li><p>对称性：$\left \langle x,y \right \rangle \in R$ ，则 $\left \langle y,x \right \rangle \in R$。</p></li><li><p>反对称性：$\left \langle x,y \right \rangle \in R$ ，则 $\left \langle y,x \right \rangle \notin R$。</p></li><li><p>传递性：$\left \langle x,y \right \rangle \in R$ 且 $\left \langle y,z \right \rangle \in R$ ，则 $\left \langle x,z \right \rangle \in R$。</p></li></ul><hr><h4 id="2-2-关系的运算"><a href="#2-2-关系的运算" class="headerlink" title="2.2 关系的运算"></a>2.2 关系的运算</h4><p>主要关注在 $\cup$，$\cap$，$-$，$\oplus$，$\sim$ 这五种运算下，是否保持上述五种性质。</p><p><strong>定义：</strong> 设 $R$ 和 $S$ 是从集合 $A$ 到集合 $B$ 的关系，则 $R\cup S$，$R\cap S\cdots$ 仍是 $A$ 到 $B$ 的关系，且有：$x(R\cap S)y &#x3D; \left \langle x,y \right \rangle \in R\cap S$ 。</p><table><thead><tr><th></th><th>$R\cap S$</th><th>$R\cup S$</th><th>$R-S$</th><th>$R\oplus S$</th><th>$\sim R$</th></tr></thead><tbody><tr><td>自反</td><td>√</td><td>√</td><td></td><td></td><td></td></tr><tr><td>反自反</td><td>√</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>对称</td><td>√</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>反对称</td><td>√</td><td></td><td>√</td><td></td><td></td></tr><tr><td>传递</td><td>√</td><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>逆关系</strong></p><p>指将关系每个有序偶的第一元、第二元对换所得到的关系。<br>$$<br>R^{-1} &#x3D; {\left \langle x,y \right \rangle\mid\left \langle y,x \right \rangle\in R}<br>$$<br>显然有 $\text{dom}(R^{-1})&#x3D;\text{ran}(R)$，$\text{ran}(R^{-1})&#x3D;\text{dom}(R)$。且可以证明逆运算保持上述的五种关系。</p><p><strong>复合运算</strong></p><p>设 $R$ 是 $X$ 到 $Y$ 的关系，$S$ 是 $Y$ 到 $Z$ 的关系。则 $R\circ S &#x3D; {\left \langle x,y \right \rangle\mid \exists y \in Y, 使得 x R y\wedge y S z}$ 。</p><p>有 $\text{dom}(R\circ S)\subseteq\text{dom}(R)$，$\text{ran}(R\circ S)&#x3D;\text{ran}(S)$。</p><p>复合运算满足结合律，但不满足交换律。</p><p>以此递归定义 <strong>关系的幂次</strong> ：$R^{n+1}&#x3D;R^n \circ R$ ，$R^0&#x3D;I_A$ ，其中 $I_A$ 是 $A$ 上的恒等关系。</p><p><strong>关系复合的矩阵表示：</strong></p><p>记关系矩阵 $M_R&#x3D;(r_{ij})<em>{m\times p}, M_S &#x3D; (S</em>{ij})<em>{p\times n}, M</em>{R\circ S } &#x3D; (t_{ij})_{m\times n}$ 。</p><p>计算 $M_{R\circ S}$ 的方法：$t_{ij} &#x3D;  {\textstyle \bigvee_{k&#x3D;1}^{p}(r_{ik}\wedge s_{kj})}$。</p><p><strong>闭包</strong></p><p>将 $R$ 的自反、对称、传递闭包分别记作 $r(R),s(R),t(R)$。其中 $R$ 自反闭包是指：包含 $R$ 的最小自反关系。其他闭包同理。</p><p><strong>定理：</strong> $R$ 是自反的当且仅当 $r(R)&#x3D;R$，其他闭包同理。</p><p><strong>计算方法：</strong> $r(R) &#x3D; R\cup I_A$，$s(R) &#x3D; R\cup R^{-1}$，$t(R) &#x3D; {\textstyle \bigcup_{n&#x3D;1}^{\infin}R^n}$.</p><p><strong>性质：</strong> $R_1\subseteq R_2$ 可以推得 $r(R_1)\subseteq r(R_2),s(R_1)\subseteq s(R_2),t(R_1)\subseteq t(R_2)$.</p><h4 id="2-3-次序关系"><a href="#2-3-次序关系" class="headerlink" title="2.3 次序关系"></a>2.3 次序关系</h4><p><strong>偏序关系</strong></p><p>当且仅当 $R$ 是自反的、反对称的、传递的，我们称 $R$ 是 $A$ 上的偏序关系（即半序关系）</p><p>如果在此基础上，任选 $x,y\in A$，$x$ 和 $y$ 都可比，则称其为 $A$ 上的全序关系。</p><p>称 $y$ 是 $x$ 的覆盖，当且仅当 $x&lt;y$ 且找不到其他元素 $z$ 使得 $x&lt;z&lt;y$。</p><p><strong>哈斯图</strong></p><p>哈斯图是一种描述偏序结构的无向图。将每个元素画成图中的一个点。</p><p>对于任意 $x,y\in A$ ，若 $x&lt;y$ 则点 $x$ 画在点 $y$ 之下。若 $y$ 覆盖 $x$，则 $x$ 和 $y$ 间连一条无向边。</p><h4 id="2-4-等价关系与划分"><a href="#2-4-等价关系与划分" class="headerlink" title="2.4 等价关系与划分"></a>2.4 等价关系与划分</h4>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⌈离散数学II⌋ 第一章</title>
    <link href="/2025/10/07/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6II-1/"/>
    <url>/2025/10/07/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6II-1/</url>
    
    <content type="html"><![CDATA[<h3 id="一、集合的基本概念和运算"><a href="#一、集合的基本概念和运算" class="headerlink" title="一、集合的基本概念和运算"></a>一、集合的基本概念和运算</h3><hr><h4 id="1-1-集合与元素"><a href="#1-1-集合与元素" class="headerlink" title="1.1 集合与元素"></a>1.1 集合与元素</h4><p><strong>集合与元素的关系</strong></p><p>设 $a$ 是任意一个对象， $A$ 是任意一个集合。在 $a$ 和 $A$ 之间有且仅有下列两种情况：</p><ul><li>$a$ 是 $A$ 中元素，记为 $a\in A$；</li><li>$a$ 不是 $A$ 中元素，记为 $a\notin A$。</li></ul><p><strong>集合的表示方法</strong></p><p>列举法（全部枚举），部分列举法，抽象法（用命题表示），归纳定义法。</p><p>抽象法很危险，可能会出现 <strong>理发师悖论</strong> 这样的问题。</p><hr><h4 id="1-2-集合间的关系"><a href="#1-2-集合间的关系" class="headerlink" title="1.2 集合间的关系"></a>1.2 集合间的关系</h4><p><strong>集合相等</strong></p><p>$A&#x3D;B \Leftrightarrow \forall x(x\in A \leftrightarrow x\in B)$</p><p><strong>集合的包含关系</strong></p><p>若 $A$ 中每个元素都是集合 $B$ 的元素，称 $A$ 是 $B$ 的子集。记作 $A\subseteq B$。</p><p>$A\subseteq B \Leftrightarrow \forall x(x\in A \to x \in B)$</p><p>$A\nsubseteq B \Leftrightarrow \neg \forall x(x\in A \to x \in B)$</p><hr><h4 id="1-3-幂集"><a href="#1-3-幂集" class="headerlink" title="1.3 幂集"></a>1.3 幂集</h4><p><strong>生成方式：</strong></p><p>用二进制编码表示某个元素的取与不取。有字典序生成方法、格雷码生成方法（相邻二进制编码只有一位不同）等。</p><p>若 $B$ 有 $n$ 个元素，那么 $P(B)$ 有 $2^n$ 个元素。</p><blockquote><p><strong>例题：</strong></p><p>证明：若 $B\subseteq C$ ，则 $P(B)\subseteq P(C)$</p><p>$X\in P(B)\Rightarrow X\subseteq B\Rightarrow X\subseteq C\Rightarrow X\in P(C)$</p></blockquote><hr><h4 id="1-4-集合运算"><a href="#1-4-集合运算" class="headerlink" title="1.4 集合运算"></a>1.4 集合运算</h4><p><strong>基础运算</strong></p><ul><li><p>交：$A\cap B &#x3D; {x\mid x\in A \cap x\in B}$</p></li><li><p>并：$A\cup B &#x3D; {x\mid x\in A \cup x\in B}$</p></li><li><p>差：$A- B &#x3D; {x\mid x\in A \cap x\notin B}$</p></li><li><p>补：$\sim A &#x3D; {x\mid \neg (x\in A)}$</p></li><li><p>对称差集：$A\oplus B &#x3D; (A - B)\cup(B - A)$</p></li></ul><p><strong>运算性质</strong></p><p>幂等律、交换律、结合律、分配律、同一律、零律、否定律、吸收律、德摩根律……</p><p><strong>对偶原理</strong></p><p>在不含 $-$ 的集合恒等式中，将 $\cup$ 和 $\cap$ 交换，$\varnothing$ 和 $\text U$ 互换，所得结果仍是集合恒等式。</p><p><strong>广义运算（集类上）</strong></p><ul><li>广义并：$\cup A &#x3D; {x\mid \exists B( B \in A \cap x\in B)}$ ；</li><li>广义交：若 $A\ne \varnothing, \cap A &#x3D; {x\mid \forall B(B\in A \to x\in B) }$。</li></ul><div class="note note-success">            <p>之所以要强调 $A\ne \varnothing$，是因为如果 $A\ne \varnothing$ ，则 $B\in A \to x\in B$ 前件始终为假，$\cap A$ 是全集。这是无意义的。</p>          </div><hr><h4 id="1-5-有穷集的计数原理"><a href="#1-5-有穷集的计数原理" class="headerlink" title="1.5 有穷集的计数原理"></a>1.5 有穷集的计数原理</h4><p>多个集合的交并问题可以参考文氏图。所谓计数原理其实和容斥原理是一回事。</p><p><img src="/2025/10/07/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6II-1/vens.png" alt="文氏图"></p><hr><h4 id="1-6-集合的归纳表示"><a href="#1-6-集合的归纳表示" class="headerlink" title="1.6 集合的归纳表示"></a>1.6 集合的归纳表示</h4><div class="note note-info">            <p><strong>例题</strong>：不允许有前导 $0$ 的十进制整数集合：</p><p><strong>解答：</strong> 采用归纳表示法：</p><ul><li><p>令 $S_0 &#x3D; {0,1,2,3,4,5,6,7,8,9}\subseteq A$；</p></li><li><p>若 $\alpha, \beta \in A$ 且 $\alpha \ne 0$，则 $\alpha \beta \in A$。</p></li></ul>          </div><hr><h4 id="1-7-有序偶和笛卡尔积"><a href="#1-7-有序偶和笛卡尔积" class="headerlink" title="1.7 有序偶和笛卡尔积"></a>1.7 有序偶和笛卡尔积</h4><ul><li>无序偶集：任意两个元素 $x$， $y$ 组成的集合 ${x, y}$。</li><li>有序偶：将两个对象按规定的顺序构成的序列称为有序偶，记为 $\left \langle x, y \right \rangle $。</li><li>$n$ 元序偶：设 $x_1,x_2,\cdots x_n$ 为 $n$ 个元素。<ul><li>若 $n&#x3D;1$，令 $\left \langle x_1 \right \rangle&#x3D;x_1$</li><li>若 $n&#x3D;2$，规定 $\left \langle x_1,x_2 \right \rangle$ 为包含 ${x_1}$ 和 ${x_1,x_2}$ 两个元素的集合。</li><li>若 $n\geq 3$，令 $\left \langle x_1,x_2,\cdots,x_n \right \rangle &#x3D; \left \langle \left \langle x_1,x_2,\cdots,x_{n-1} \right \rangle ,x_n \right \rangle $</li></ul></li><li>笛卡尔积：集合 $A$ 和 $B$ 的笛卡尔积 $A\times B$ 定义为：$A\times B &#x3D; {\left \langle  x, y \right \rangle \mid x\in A \cap y \in B }$ 。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>离散数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⌈Hexo⌋ 建站记录</title>
    <link href="/2025/10/05/Hexo%20%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/10/05/Hexo%20%E5%BB%BA%E7%AB%99%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>近来想给自己的 Blog 换个好记的域名和主题风格，研究了一会发现好像必须开个新仓库从头再来。于是我写下这篇，给将来可能还要重建的自己做参考。</p><hr><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>首先确认电脑中安装了 <a href="https://git-scm.com/">Git</a> 和较高版本的 <a href="https://nodejs.org/en/">Node.js</a> 。</p><p>然后用以下命令安装 <code>Hexo</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>然后查看 <code>Hexo</code> 的版本，检查是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo -v<br></code></pre></td></tr></table></figure><p>如果能输出正确的版本信息，则说明成功安装。否则说明各模块版本间可能存在兼容问题。建议询问大模型以获得解决方案。</p><p>比如此处我遭遇的问题是最新版本的 <code>Hexo 8.0.0</code> 并未完全适配其依赖包 <code>strip-ansi@7</code>。我的选择是将 <code>Hexo</code> 退回适配做得更好的 <code>7.3.0</code> 版本。</p><p>此外，还需要安装 Hexo 的 Git 部署插件，用于将静态文件推送到 Github：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure><p>至此大体上准备工作就完成了，我们可以着手于建站了。</p><hr><h4 id="初步建站"><a href="#初步建站" class="headerlink" title="初步建站"></a>初步建站</h4><p>首先在本地创建一个空白文件夹。然后在文件夹内右键选择 <code>Open Git Bash Here</code> 并输入如下命令，完成初始化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init<br></code></pre></td></tr></table></figure><p>此时我们输入以下命令就可以在本地预览博客的样式了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo s<br></code></pre></td></tr></table></figure><p>当然，官方提供的默认主题还是过于朴实了。这里推荐大家选择一些用户开发的主题，最有名的大概是 <a href="https://github.com/theme-next/hexo-theme-next">NexT</a> 和 <a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a> 这两个。由于用户多，这两款主题的更新维护是较为及时的。</p><p>我的旧博客选择的是早已停止维护的 <a href="https://github.com/saicaca/hexo-theme-vivia">vivia</a> ，当前博客则是 <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid</a>。</p><p>现在以 <code>Fluid</code> 主题为例，介绍一下主题的配置过程：</p><p>首先在根目录 <code>Git Bash</code> 中输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure><p>在根目录新建 <code>_config.fluid.yml</code>，将主题的 <code>_config.yml</code> 内容复制进去。</p><p>然后在目录中找到 <code>_config.yml</code> 文件，对 <code>theme</code> 和 <code>language</code> 属性进行修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span><br><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br></code></pre></td></tr></table></figure><p>修改主题后，同样可以用 <code>hexo s</code> 命令在本地预览。</p><p>至于更进一步的配置，官方提供了详细的<a href="https://hexo.fluid-dev.com/docs/">用户文档</a>，可以用来参考。以后我可能也会单出一篇文章记录我的美化过程。</p><hr><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><p>下面介绍一些常用的命令。</p><ul><li><p>创建一篇新文章（比如文章的标题为”八月合集”）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new post 八月合集<br></code></pre></td></tr></table></figure><p>执行此命令后，<code>_post</code> 文件夹会出现一个 <code>八月合集.md</code> 文件。我们可以对其进行编辑，完成我们的创作。</p></li><li><p>清除原有的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br></code></pre></td></tr></table></figure></li><li><p>生成静态文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo g<br></code></pre></td></tr></table></figure><p>为所有 Blog 文件生成静态文件。为后续的 <code>deploy</code> 等操作做准备。</p></li><li><p>本地预览：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo s<br></code></pre></td></tr></table></figure><p>启动服务器，默认的访问网址为：<code>http://localhost:4000/</code>。一般 <code>Git Bash</code> 窗口里会直接出现这个链接。我们可以 <code>Ctrl</code> 键左击链接的 <code>4000</code> 处直接访问。</p></li><li><p>部署网站</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo d<br></code></pre></td></tr></table></figure><p>将项目推至云端。前置操作会在接下来的章节内详细说明。</p></li></ul><hr><h4 id="部署-Github-Page"><a href="#部署-Github-Page" class="headerlink" title="部署 Github Page"></a>部署 Github Page</h4><p>为了让别人看到我们的 Blog，我们需要一个大家都可以访问的域名。通用的办法是将 Blog 直接部署在我们的 Github Page 上。网址为 <code>username.github.io</code>。操作流程如下：</p><ul><li><p>首先我们在 Github 上创建一个名为 <code>username.github.io</code> 的仓库。其中 <code>username</code> 用你的用户名替换。</p></li><li><p>然后我们打开根目录中的 <code>-config.yml</code> 文件，找到 <code>deploy</code> 部分进行修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/你的GitHub用户名/你的仓库名.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br>  <span class="hljs-attr">message:</span> <span class="hljs-string">&quot;部署 Hexo 博客，更新于 $(date &#x27;+%Y-%m-%d %H:%M:%S&#x27;)&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>然后我们就可以通过 <code>hexo d</code> 命令将本地的静态文件部署到 Github Page 上了。首次部署一般需要输入 Github 的账号密码。</p></li></ul><hr><h4 id="让-Blog-支持-LaTeX"><a href="#让-Blog-支持-LaTeX" class="headerlink" title="让 Blog 支持 $\LaTeX$"></a>让 Blog 支持 $\LaTeX$</h4><p>由于 <code>Hexo</code> 对 <code>latex</code> 的支持并不好，所以需要我们手动配置。</p><p>首先删除 <code>hexo-math</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm un hexo-math<br></code></pre></td></tr></table></figure><p>下载 <code>hexo-renderer-marked</code> 渲染器 （可能已安装）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm i hexo-renderer-marked --save<br></code></pre></td></tr></table></figure><p>在 <code>_config.yml</code> 最后加入这样一段代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># MathJax</span><br><span class="hljs-attr">math:</span><br>  <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span> <span class="hljs-comment"># or &#x27;katex&#x27;</span><br>  <span class="hljs-attr">mathjax:</span><br>    <span class="hljs-comment"># src: custom_mathjax_source</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-comment"># MathJax config</span><br></code></pre></td></tr></table></figure><p>并在主题文件中也做相应的修改。比如 <code>fluid</code> 主题中有关数学公式渲染的部分是这样的。其余主题可以参考官方文档自行配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">math:</span><br>  <span class="hljs-comment"># 开启后文章默认可用，自定义页面如需使用，需在 Front-matter 中指定 `math: true`</span><br>  <span class="hljs-comment"># If you want to use math on the custom page, you need to set `math: true` in Front-matter</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br><br>  <span class="hljs-comment"># 开启后，只有在文章 Front-matter 里指定 `math: true` 才会在文章页启动公式转换，以便在页面不包含公式时提高加载速度</span><br>  <span class="hljs-comment"># If true, only set `math: true` in Front-matter will enable math, to load faster when the page does not contain math</span><br>  <span class="hljs-attr">specific:</span> <span class="hljs-literal">false</span><br><br>  <span class="hljs-comment"># Options: mathjax | katex</span><br>  <span class="hljs-attr">engine:</span> <span class="hljs-string">mathjax</span><br><br>  <span class="hljs-attr">options:</span><br>    <span class="hljs-attr">mathjax:</span><br>      <span class="hljs-attr">src:</span> <span class="hljs-string">https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js</span><br></code></pre></td></tr></table></figure><p>粘贴时注意缩进哦。</p><p>但 <code>hexo-renderer-marked</code> 在渲染稍复杂的公式时就会崩溃。所以通常只能作为权宜之计，日后还是得把它换掉。</p><hr><h4 id="修改主题字体"><a href="#修改主题字体" class="headerlink" title="修改主题字体"></a>修改主题字体</h4><div class="note note-info">            <p>本部分参考 <a href="https://www.erenship.com/posts/40222.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AD%97%E4%BD%93">此Blog</a> 撰写。</p>          </div><p>字体对页面的观感影响不可谓不大。虽然 <code>Fluid</code> 的原生字体看着已经很舒适，但这并不妨碍我想把它换掉！因为个人更喜欢衬线体。下面就以本 Blog 使用的思源宋体为例，展示一下设置非系统字体的过程。</p><p>一种可行的做法是将字体作为本地文件引入。但由于字体文件动辄几十MB的大小，这一方案可能严重拖慢网页的加载速度。因此我们选择在线托管字体网站进行字体引用，步骤如下：</p><ul><li><p>打开 <a href="https://fonts.google.com/">Google Fonts</a> ，搜索思源宋体的英文名：<code>Noto Serif SC</code> ，在 <code>Get embed code</code> 界面复制得到这一行链接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ejs">&lt;link href=&quot;https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@200..900&amp;display=swap&quot; rel=&quot;stylesheet&quot;&gt;<br></code></pre></td></tr></table></figure></li><li><p>打开 <code>\theme\fluid\layout\_partial</code> 目录下的 <code>head.ejs</code> 文件，将上述链接粘贴到 <code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code> 的下一行。</p></li><li><p>再打开 <code>\themes\fluid\source\css\variables\</code> 目录下的 <code>base.styl</code> 文件，将 <code>font-family</code> 一行修改为以下语句：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-variable">$font</span>-family = <span class="hljs-built_in">theme-config</span>(<span class="hljs-string">&quot;font.font_family&quot;</span>, <span class="hljs-string">&quot;Noto Serif SC&quot;</span>, <span class="hljs-string">&quot;var(--font-family-sans-serif)&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><p>至此，自定义字体的引入就完成了。</p><hr><h4 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h4><p><code>Hexo</code> 提供了全局资源文件夹（一般而言路径为 <code>Root\source\img</code>）我们可以通过类似于 <code>![](/img/xxx.jpg)</code> 的方法来访问它们。</p><p>但那么博客有那么多图片，如果全部放在全局文件夹中，拖慢访问速度不说，还不便于管理。</p><p>所以推荐使用局部的文章资源文件夹。</p><p>首先我们需要在 <code>config.yml</code> 中找到 <code>post_asset_folder</code> 这一行，将其设置为 <code>true</code>。并补充其余两个属性：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-params">post_asset_folder:</span> <span class="hljs-literal">true</span><br><span class="hljs-params">asset_path:</span><br>  <span class="hljs-params">enabled:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-params">prefix:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 是否在路径前加 `/`，按需调整</span><br><span class="hljs-params">marked:</span><br>  <span class="hljs-params">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-params">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>设置完成后，我们每次用 <code>hexo new post newTitle</code> 命令生成新帖时，都会在 <code>_posts</code> 目录下同时生成一个与其同名的资源文件夹。我们将图片 <code>pic.png</code> 放在对应文件夹内，这样，我们只需要写 <code>![](pic.png)</code> 就可以访问该图片了。</p><h4 id="改用-SSH-部署"><a href="#改用-SSH-部署" class="headerlink" title="改用 SSH 部署"></a>改用 SSH 部署</h4><p><code>https</code> 部署时常不稳定。总是有一段时间 <code>hexo d</code> 无法正常推送。我们可以改用 <code>SSH</code> 部署，这是更稳定的选择。步骤如下：</p><ul><li><p>生成 <code>SSH</code> 密钥。在 <code>Git Bash</code> 中输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>复制 <code>C:\Users\&lt;你的用户名&gt;\.ssh\id_rsa.pub</code> 中的内容。</p></li><li><p>打开 GitHub - Settings - SSH and GPG keys - New SSH key。粘贴刚刚复制的内容。</p></li><li><p>测试连接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh -T git@github.com<br></code></pre></td></tr></table></figure><p>如果出现：<code>“Hi xxx! You&#39;ve successfully authenticated”</code> 说明连接成功。</p></li><li><p>修改 <code>_config.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">git@github.com:你的用户名/你的用户名.github.io.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure></li></ul><p>至此，就完成了 <code>SSH</code> 部署的配置。</p>]]></content>
    
    
    <categories>
      
      <category>技术记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⌈BUAA CO⌋ pre 记录</title>
    <link href="/2025/09/30/%E2%8C%88BUAA%20CO%E2%8C%8Bpre%20%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/09/30/%E2%8C%88BUAA%20CO%E2%8C%8Bpre%20%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="翻涌数字-Pre-roll"><a href="#翻涌数字-Pre-roll" class="headerlink" title="翻涌数字 Pre_roll"></a>翻涌数字 Pre_roll</h3><hr><blockquote><p><strong>题意</strong>：</p><p>给定位宽 $32$ 的输入 $a$，代表 $8$ 个位宽为 $4$ 的数据 $a_0,a_1\cdots, a_7$。同时令每一个 $a_i&#x3D;\sum_{j&#x3D;0}^{i}a_j$ ，对 <code>4&#39;d16</code> 取模后，按原顺序拼接输出。</p></blockquote><p>考场上先开的这个题。只需要先设置 $8$ 个 <code>wire</code> 型数据 $a_0,a_1\cdots,a_7$ 拆分 <code>input</code>  中的数据，再对 ${a_n}$ 做前缀和，最后拼接输出即可。然而由于对 <code>Verilog</code>  语法的不熟悉，写的过程非常不顺利。以下是一些需要记住的语法规则：</p><ul><li><p><code>assign</code> 的作用对象为 <code>wire</code> 型，称为连续赋值，属于结构描述。不能放在 <code>always</code> 和 <code>initial</code> 块里面；</p><p>而过程赋值的作用对象为 <code>reg</code> 型，必须放在 <code>always</code> 和 <code>initial</code> 块里面。</p></li><li><p>阻塞赋值（<code>=</code>）与 <code>c++</code> 中的赋值语句类似，更新完被赋值数的值才会执行接下来的操作。而非阻塞赋值（<code>&lt;=</code>）操作会等到全部语句计算完后统一更新。</p></li><li><p><code>Verilog</code> 中位选择 <code>[msb:lsb]</code> 必须是常量表达式。因此 <code>a[i*4 + 3 : i*4]</code> 这种写法是非法的。然而我们可以写 <code>a[i*4 + 3 -: 4]</code> 或者 <code>a[i*4 +: 4]</code>。</p></li></ul><h3 id="MIPS-Submatrix"><a href="#MIPS-Submatrix" class="headerlink" title="MIPS_Submatrix"></a>MIPS_Submatrix</h3><hr><blockquote><p><strong>题意：</strong></p><p>读入 $16$ 个整数代表一个 $4\times 4$ 的矩阵 $A_{0}\sim A_{15}$ .再读入子矩阵的左上坐标以及长宽数据。输出子矩阵内的值。如果超出边界，改为输出 <code>Out of bounds</code>。</p></blockquote><p>主要考察的其实还是 MIPS 的基本语法。除了需要对基础的语法更加熟悉之外，还要尽量提升自己代码的可读性。</p><ul><li><p>一些与赋值有关，容易混淆的命令：</p><p><img src="/2025/09/30/%E2%8C%88BUAA%20CO%E2%8C%8Bpre%20%E8%AE%B0%E5%BD%95/MIPS.png" alt="常用命令"></p></li><li><p>关于数组的存取操作。一般我们可以写一个宏定义来快速计算某下标对应的偏移量。比如图中的宏可以用来计算列数为 <code>%len</code> 的二维数组中指定坐标的偏移量，进而进行存储和载入的操作。</p><p><img src="/2025/09/30/%E2%8C%88BUAA%20CO%E2%8C%8Bpre%20%E8%AE%B0%E5%BD%95/macro.png" alt="数组存取"></p><p>这里出现了乘法的写法。涉及 <code>mult</code> 和 <code>mflo</code> 两个命令，需要特殊记忆。</p></li></ul><h3 id="Logisim-Sokoban"><a href="#Logisim-Sokoban" class="headerlink" title="Logisim_Sokoban"></a>Logisim_Sokoban</h3><hr><blockquote><p><strong>题意：</strong> </p><p>初始时玩家在 $6\times 6$ 地图上的 $(0,0)$ 处。地图上有若干障碍。除了 <code>clk</code> 和 <code>reset</code> 信号（异步复位）外，每时刻还会收到 <code>dx</code> 和 <code>dy</code> 信号。</p><p>假设玩家在 $(x,y)$ 位置，收到信号时，会尝试移动到 $(x+dx,y+dy)$ 位置。若目标位置超出地图或为障碍，则留在原位置，将 <code>flag</code> 置高 $1$ 个周期。当前位置为 $(5,5)$ 时，<code>out</code> 输出为 $1$，否则为 $0$。</p></blockquote><p>考场上没有成功搭出来这道题。是课下补题时做的。</p><p>根据经典的 <code>Moore</code> 状态机的框架来搭就可以。如下图所示：</p><p><img src="/2025/09/30/%E2%8C%88BUAA%20CO%E2%8C%8Bpre%20%E8%AE%B0%E5%BD%95/Moore.png" alt="Moore 状态机框架"></p><p>状态转移是电路的核心部分。此处我用一个八位二进制数表示此状态下的 $x,y$ 坐标。将它的各位和 <code>dx</code>，<code>dy</code> 一起作为状态转移电路的输入。</p><p>转移电路中先用一个四位加法器计算出 <code>x + dx</code> 和 <code>y + dy</code> （注意要先用 <code>Bit Extender</code> 将 <code>dx</code> 和 <code>dy</code> 同样扩展为 $4$ 位），检查 $(x + dx,y+dy)$ 是否为合法位置。</p><p>是否为合法位置，用若干个比较器即可完成。（需要注意到是，如果选用六位二进制数表示状态，则须将比较器的属性设为 <code>Unsigned</code>，否则最高位会被识别为符号位）</p><p>如果是合法位置，将 <code>x + dx</code> 和 <code>y + dy</code> 拼接成八位二进制数输出，<code>flag</code> 置 <code>0</code> ；否则将输入的数再输出，<code>flag</code> 置 <code>1</code>。</p><p>于是就完成了。其实都算不上一个难题，只能怪自己没好好学。</p><hr><h3 id="最后，P0上机顺利-！"><a href="#最后，P0上机顺利-！" class="headerlink" title="最后，P0上机顺利 -(^_^)-！"></a>最后，P0上机顺利 -(^_^)-！</h3>]]></content>
    
    
    <categories>
      
      <category>上机记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⌈Codeforces⌋ 九月合集</title>
    <link href="/2025/09/03/%E4%B9%9D%E6%9C%88%E5%90%88%E9%9B%86/"/>
    <url>/2025/09/03/%E4%B9%9D%E6%9C%88%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="2139-CodeForces-Round-1048（Div-2）"><a href="#2139-CodeForces-Round-1048（Div-2）" class="headerlink" title="2139. CodeForces Round 1048（Div. 2）"></a>2139. <a href="https://codeforces.com/contest/2139">CodeForces Round 1048（Div. 2）</a></h3><p><strong>过题：</strong> 3&#x2F;7<strong>排名：</strong> 3750<strong>上分：</strong> -（unr）</p><p>被出题人的疏忽拯救的一场。如果题面没锅不unr得掉大分了。戏剧性的是室友和队友这场打得都非常强势，得知unr后都相当愤怒。</p><h4 id="A-Maple-and-Multiplication"><a href="#A-Maple-and-Multiplication" class="headerlink" title="A. Maple and Multiplication"></a>A. Maple and Multiplication</h4><p>如果 $a&#x3D;b$，不用操作。如果 $a\mid b$ 或 $b\mid a$，操作一次。否则先 $a\to ab$，再 $b\to ab$，操作两次。 <a href="https://codeforces.com/contest/2139/submission/337556954">Code</a>.</p><h4 id="B-Cake-Collection"><a href="#B-Cake-Collection" class="headerlink" title="B. Cake Collection"></a>B. Cake Collection</h4><p>可以注意到，累积过程不因中途的取走操作而改变。因此每个烤箱至多只取一次。</p><p>越早取，该烤箱最终累积没取的蛋糕会越多。可以这样考虑：对于一个每秒生产 $x$ 个蛋糕的烤箱而言，早取一秒就使总数亏损 $x$。于是我们给出贪心的方案：按 $x$ 排序，$x$ 越大的越靠后取。</p><p>时间复杂度 $\mathcal O(n\log n)$，<a href="https://codeforces.com/contest/2139/submission/337577025">Code</a>.</p><h4 id="C-Cake-Assignment"><a href="#C-Cake-Assignment" class="headerlink" title="C. Cake Assignment"></a>C. Cake Assignment</h4><p>是一道似曾相识的找规律题（好像在牛客多校做过）。</p><p>下面记 $K &#x3D; 2 ^ k$ 。</p><p>一次操作后 Chocola 的值为 $2 ^ {k - 1}$（执行操作一）或 $3\times2^{k - 1}$ （执行操作二）。 </p><p>两次操作后为 $2^{k - 2},5\times2^{k - 2},3\times2^{k - 2}$ 或 $7\times 2^{k - 2}$。以此类推。</p><p>所以根据 $x$ 因子中 $2$ 的次数就可以判断操作次数。至于操作序列，依次模一个每次自乘 $2$ 的 $2$ 的幂次。如果余数小于模数的一半，计 $1$（操作为 Chocola 送出蛋糕），反之计 $2$（操作为 Chocola 收到蛋糕）。</p><p>然后挨个输出即可。时间复杂度 $\mathcal O(k)$。<a href="https://codeforces.com/contest/2139/submission/337602145">Code</a>.</p><h4 id="D-Antiamuny-Wants-to-Learn-Swap"><a href="#D-Antiamuny-Wants-to-Learn-Swap" class="headerlink" title="D. Antiamuny Wants to Learn Swap"></a>D. Antiamuny Wants to Learn Swap</h4><blockquote><p>此题原题面与 std 做法不符，出题组赛时对题面进行了修改，导致整场比赛UNR。区别在于能否多次执行操作二。</p><p>能多次执行的原题面我暂时没有想到解决方案。也许是不可做题。此处只讨论修改后的题面。</p></blockquote><p>先考虑什么时候操作二能减少总操作次数。</p><p>首先联想到冒泡排序。本质上交换次数就是原序列中逆序对的数量，每次交换可以减少一个逆序对。</p><p>仔细分析：长度为三的序列中逆序对的数量为 $0\sim 3$ 。操作二若减少不少于两个逆序对，则原序列中逆序对数为二或三。</p><ul><li><p>若为二，则交换后变为零。交换后的序列为正序。因而反推知原序列为倒序，逆序对数应为三。与假设矛盾。</p></li><li><p>若为三，原序列为倒序。交换后为正序，逆序对数为零。当次交换减少了三个逆序对，优于操作一。符合要求。</p></li></ul><p>因此如果存在 $a_{i} &gt; a_{i + 1} &gt; a_{i + 2}(1\leq i\leq n - 2)$ ，则 $f(b)\neq g(b)$。</p><p>再发现只要存在 $1\leq i&lt;j&lt;k\leq n$ ，使得 $a_i &gt;a_j&gt;a_k$，就可以通过几次相邻逆序对间的交换，化为上面的情况。（之所以强调逆序对间的交换是因为：如果交换了非逆序对就必须再花一次换回来，使最终代价加二，这在只允许一次操作二的前提下是不可接受的）</p><p><strong>证明显然</strong>：如果存在 $i&lt;l_1&lt;l_2&lt;\dots &lt;l_N&lt;j$ ，且 $a_{l_i}&lt;a_j(1\leq i\leq N)$，则总可以每次从中找到一个最小的往前做逆序对交换（选择了最小的所以前面的一定比他大），直到 $j$ 就是 $i$ 右侧第一个满足 $a_j&lt;a_i$ 的。此时就可以将 $j$ 往前做逆序对交换了，最终交换到原 $a_i$ 右侧紧邻的位置。同理可以把 $k$ 也换过来。</p><p>因此问题转化成了：</p><p>$Q$ 次形如 $[l, r]$ 的询问，回答是否存在 $l\leq i&lt;j&lt;k\leq r$ ，使得 $a_i&gt;a_j&gt;a_k$。</p><p>这一问题做法众多，线性的，带 $\log$ 的，在线的，离线的，都有。此处介绍笔者的高码量低效率做法。 </p><p>总体思路是对于每个 $i$ ，预处理出其对应的 $k$ 的最小值。然后就是简单的 RMQ 问题了——如果询问区间内的 $k_{\min} \leq r$，证明能找到三元递减子列，输出 <code>NO</code>。否则输出 <code>YES</code>。</p><p>预处理的过程如下：首先用单调栈预处理出每个数右边离其最近的小于其的数，记为 $b_i$。然后从右往左依次往权值线段树中加点 $(a_i, b_i)$，并询问当前 $1\sim a_i - 1$ 中最小的 $b$ 值，存下来作为预处理的结果。</p><p>总时间复杂度 $\mathcal O(n\log n+ Q)$。Code.（链接以后再加）</p><h3 id="2140-CodeForces-Round-1049（Div-2）"><a href="#2140-CodeForces-Round-1049（Div-2）" class="headerlink" title="2140. CodeForces Round 1049（Div. 2）"></a>2140. <a href="https://codeforces.com/contest/2140">CodeForces Round 1049（Div. 2）</a></h3><p><strong>过题：</strong> 2&#x2F;7<strong>排名：</strong> 6256<strong>上分：</strong> -95（1625）</p><p>纯菜。C 这种萌萌题都写不出还能说什么呢。</p><h4 id="A-Shift-Sort"><a href="#A-Shift-Sort" class="headerlink" title="A. Shift Sort"></a>A. Shift Sort</h4><p>每次操作可以把一个 $0$ 归位。统计有几个没归位的 $0$ 即可。</p><p>时间复杂度 $\mathcal O(n)$。<a href="https://codeforces.com/contest/2140/submission/337772533">Code</a>.</p><h4 id="B-Another-Divisibility-Problem"><a href="#B-Another-Divisibility-Problem" class="headerlink" title="B. Another Divisibility Problem"></a>B. Another Divisibility Problem</h4><p>输出 $y &#x3D; 2x$ 即可。因为 $\overline{xy}&#x3D;(10^k+2)x$ 有因子 $3x$ ，而 $x+y &#x3D; 3x$。所以 $\overline{xy}\mid x+y$。</p><p>同理输出 $8x$ 也可以。<a href="https://codeforces.com/contest/2140/submission/337800301">Code</a>.</p><h4 id="C-Ultimate-Value"><a href="#C-Ultimate-Value" class="headerlink" title="C. Ultimate Value"></a>C. Ultimate Value</h4><p>首先注意到轮到 B 操作时，B一定直接结束游戏。因为不管 B 怎么操作，A 只需做逆操作复原即可，而这个过程中 $cost$ 值正在增长，这是不利于 B 的。（如果拖到第 $10^{100}$ 轮，当然 A 已经没有机会做逆操作了，但 B 在这一轮创造的收益一定是无法抵消前 $10^{100} - 1$ 个回合累积的 $cost$ 的）</p><p>因此我们只需判断 A 是否操作。如果操作，怎么操作。</p><p>首先记所有操作前的 $f$ 值为 $sum$。</p><p>如果不进行奇偶位之间的交换，最优的操作为交换最左和最右奇数位上的数。若 $n$ 为奇数，答案为 $sum+n - 1$，否则为 $sum+n -2$。</p><p>如果进行奇偶位之间的交换，设选择的是 $a_i$ 和 $a_j$，其中 $i$ 为奇数，$j$ 为偶数。则答案为 $sum - 2a_i + 2a_j + |i - j|$。考虑分类讨论去掉绝对值。</p><ul><li>$i&lt;j$ ，式子为 $sum + (2a_j+j) - (2a_i+i)$；</li><li>$i &gt; j$， 式子为 $sum + (2a_j - j) - (2a_i - i)$。</li></ul><p>我们考虑预处理 ${2a_i+i}$ 的前缀最小值和 ${2a_i - i}$ 的后缀最小值。然后依次枚举 $j$ 计算。</p><p>对得到的所有答案取最大值即可。</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⌈25暑训⌋ 第7&amp;8场补题</title>
    <link href="/2025/08/08/%E6%9A%91%E8%AE%AD7&amp;8%20%E8%A1%A5%E9%A2%98/"/>
    <url>/2025/08/08/%E6%9A%91%E8%AE%AD7&amp;8%20%E8%A1%A5%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>两场全部打的依托……虽说早已出线无望，但越打状态越差还是很失望的。</p><h1 id="7A"><a href="#7A" class="headerlink" title="7A"></a>7A</h1><p><strong>题目大意：</strong> </p><p>给定 $100$ 套玩具，每套 $10$ 个，每个都是 $10\times 10$ 的矩阵。初始时矩阵均为顺序排列，总共对这些矩阵进行了 $10^6$ 次 $4\times 4$ 范围内的顺时针旋转操作。最后选取 $50$ 套玩具，将套中的每个玩具替换成随机矩阵。请找出这 $50$ 套玩具，要求达到 $90%$ 的正确率。</p><p><strong>知识点：</strong> 置换、逆序对</p><p>经过大量的旋转，看单个数字最终所在位置已经没有意义。赛时打表得知每个数出现在各位置的几率几乎完全相等。因此不能孤立地考虑某一个数，而要关注整体的性质。</p><p>赛时我们一直在试图寻找，却没能找到的不变量，其实就是逆序对数。证明如下：</p><p>将矩阵展开为一行序列，可以看出每次旋转操作相当于进行了三次长度为 $12$ 的轮换和一次长度为 $4$ 的轮换。又注意到进行偶数次轮换不改变序列中的逆序对数，因此由旋转生成的玩具中逆序对一定为偶数。</p><p>而随机矩阵逆序对数为偶数的可能性只有一半，因此若一套中 $10$ 个玩具的逆序对数均为偶数，其极大概率由旋转生成。</p><p>时间复杂度由计算逆序对的过程决定。此题暴力计数亦可通过。</p><p>更多关于置换与逆序对的例题，可以参考我的另一篇笔记。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; id &gt;&gt; m &gt;&gt; k &gt;&gt; n;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, m) &#123;<br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">FOR</span>(j, <span class="hljs-number">1</span>, k) &#123;<br>            <span class="hljs-built_in">FOR</span>(l, <span class="hljs-number">1</span>, n * n) cin &gt;&gt; a[l];<br>            <span class="hljs-type">int</span> rev = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">FOR</span>(l, <span class="hljs-number">1</span>, n * n - <span class="hljs-number">1</span>) <span class="hljs-built_in">FOR</span>(u, l + <span class="hljs-number">1</span>, n * n)<br>                <span class="hljs-keyword">if</span> (a[l] &gt; a[u]) rev++;<br>            <span class="hljs-keyword">if</span> (rev &amp; <span class="hljs-number">1</span>) flag = <span class="hljs-number">1</span>;<br>        &#125;<br>        cout &lt;&lt; flag;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7D"><a href="#7D" class="headerlink" title="7D"></a>7D</h1><p><strong>题目大意：</strong> </p><p>给定一张有向图，找到所有从 $1\to n$ 的路径中方差的下确界（边可以重复走）。其中点数 $n \leq 30$ ，边数 $m\leq 200$ ，边权 $w_i\leq 20$。</p><p><strong>知识点：</strong> dp</p><p>把方差的式子拆开。可以发现求路径方差的最小值，可以转化成固定路径内边的个数和总长度后最小化边的平方和：<br>$$<br>D&#x3D;\frac{1}{l}\sum_{i &#x3D; 1}^{l}(w_i - \overline{w})^2&#x3D;\frac{1}{l}\sum_{i &#x3D; 1}^{l}w_i^2 - (\frac{1}{l}\sum_{i&#x3D;1}^{l}{w})^2<br>$$<br>先考虑图中没有环时怎么做。</p><p>由于本题数据范围很小，这一过程支持高维dp处理。具体来说，设 $dp_{i, j, l, w}$ 表示 $i\to j$ 的所有路径中，经过 $l$ 条边，总长度为 $w$ 的情况下，边长平方和的最小值。转移只需枚举 $j$ 上的出边。不妨设有一条从 $j$ 指向 $k$ ，边长为 $w_i$ 的边，便有如下转移：<br>$$<br>dp_{i, j, l, w} + w_i^2 \to dp_{i, k, l + 1, w + w_i}<br>$$<br>注意到所有边数为 $l$ 的状态必然由边数为 $l - 1$ 的状态转移而来。因此我们可以先枚举 $l$ ，即可将这一维滚掉。时间复杂度 $\mathcal O(n^3mw)$ ，空间复杂度 $\mathcal O(n^3 w)$，均在可接受范围内。</p><p>加入环之后，意味着我们可以在环上绕无数次，无限稀释路径上其他边的作用，让最终的答案等于环上的方差。</p><p>路径上的环要么不走，要么走无数次。不严谨的证明如下：</p><ul><li>如果环的方差大于等于原路径，多在环上走一圈不会使答案更优。</li><li>如果环的方差小于原路径，在环上走有限圈的方案的方差一定大于环的方差，而走无限圈的方差等于环的方差。因此走无限圈最优。</li></ul><p>因此答案只需对无环路径方差最小值，以及能从 $1$ 到达并能到达 $n$ 的环方差最小值取 $\min$ 。</p><p>环本质上是从某节点开始和结束的路径，因此环方差也可在 $dp$ 时算出。至于 ” 能从 $1$ 到达并能到达 $n$ “ 这件事，可以通过类似 Floyd 算法的流程进行预处理。这样就做完了这道题。</p><p>**Code: **</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOR(i,j,k) for (int i = j; i &lt;= k; i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int, int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-title">dbmin</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">double</span> x, <span class="hljs-type">long</span> <span class="hljs-type">double</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x &lt; y ? x : y;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">31</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> W = <span class="hljs-number">21</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">1e9</span>;<br><br><span class="hljs-type">int</span> T;<br><br><span class="hljs-type">int</span> n, m, k;<br><br><span class="hljs-type">bool</span> ava[N][N];<br><span class="hljs-type">int</span> dp[N][N][N * W][<span class="hljs-number">2</span>];<br><br>vector&lt;pii&gt; e[N];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, m) &#123;<br>        <span class="hljs-type">int</span> x, y, w; cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;<br>        ava[x][y] = <span class="hljs-literal">true</span>;<br>        e[x].<span class="hljs-built_in">push_back</span>(&#123;y, w&#125;);<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">FOR</span>(j, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">FOR</span>(w, <span class="hljs-number">0</span>, N * W - <span class="hljs-number">1</span>) dp[i][j][w][<span class="hljs-number">0</span>] = dp[i][j][w][<span class="hljs-number">1</span>] = INF;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) dp[i][i][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>, ava[i][i] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">FOR</span>(j, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">FOR</span>(k, <span class="hljs-number">1</span>, n)<br>        <span class="hljs-keyword">if</span> (ava[j][i] &amp;&amp; ava[i][k]) ava[j][k] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (!ava[<span class="hljs-number">1</span>][n]) &#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>); <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br>    <span class="hljs-type">double</span> ans = INF;<br>    <span class="hljs-built_in">FOR</span>(l, <span class="hljs-number">1</span>, n) &#123;<br>        <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">FOR</span>(j, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">FOR</span>(w, <span class="hljs-number">0</span>, l * W) dp[i][j][w][l &amp; <span class="hljs-number">1</span>] = INF;<br>        <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">FOR</span>(j, <span class="hljs-number">1</span>, n) <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> u : e[j]) &#123;<br>            <span class="hljs-type">int</span> k = u.first, wg = u.second;<br>            <span class="hljs-built_in">FOR</span>(w, wg, l * W) <br>                dp[i][k][w][l &amp; <span class="hljs-number">1</span>] = <span class="hljs-built_in">min</span>(dp[i][k][w][l &amp; <span class="hljs-number">1</span>], dp[i][j][w - wg][(l &amp; <span class="hljs-number">1</span>) ^ <span class="hljs-number">1</span>] + wg * wg);<br>        &#125;<br>        <span class="hljs-built_in">FOR</span>(w, <span class="hljs-number">0</span>, l * W) <span class="hljs-keyword">if</span> (dp[<span class="hljs-number">1</span>][n][w][l &amp; <span class="hljs-number">1</span>] != INF) &#123;<br>            ans = <span class="hljs-built_in">dbmin</span>(ans, dp[<span class="hljs-number">1</span>][n][w][l &amp; <span class="hljs-number">1</span>] * <span class="hljs-number">1.0</span> / l - w * w * <span class="hljs-number">1.0</span> / (l * l));<br>        &#125;<br>        <span class="hljs-built_in">FOR</span>(w, <span class="hljs-number">0</span>, l * W) <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>            <span class="hljs-keyword">if</span> (dp[i][i][w][l &amp; <span class="hljs-number">1</span>] != INF &amp;&amp; ava[<span class="hljs-number">1</span>][i] &amp;&amp; ava[i][n]) &#123;<br>                ans = <span class="hljs-built_in">dbmin</span>(ans, dp[i][i][w][l &amp; <span class="hljs-number">1</span>] * <span class="hljs-number">1.0</span> / l - w * w * <span class="hljs-number">1.0</span> / (l * l));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.12lf\n&quot;</span>, ans);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>25暑训</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⌈Codeforces⌋ 八月合集</title>
    <link href="/2025/08/01/%E5%85%AB%E6%9C%88%E5%90%88%E9%9B%86/"/>
    <url>/2025/08/01/%E5%85%AB%E6%9C%88%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="2130-CodeForces-Round-1040（Div-2）"><a href="#2130-CodeForces-Round-1040（Div-2）" class="headerlink" title="2130. CodeForces Round 1040（Div. 2）"></a>2130. <a href="https://codeforces.com/contest/2130">CodeForces Round 1040（Div. 2）</a></h3><p><strong>过题：</strong> 3&#x2F;8<strong>排名：</strong> 6015<strong>上分：</strong> - 81 (1564)</p><p>状态奇差的一场，每一步都做了错误的选择。</p><p>A 没仔细写，WA了之后没有查哪里错了就慌着去开 B ，结果 B 看漏了零一二都有的条件，写了半天讨论。D 题也拿着假结论写了半天，发现样例都过不了，哈哈破防了。</p><h4 id="A-Submission-is-All-You-Need"><a href="#A-Submission-is-All-You-Need" class="headerlink" title="A. Submission is All You Need"></a>A. Submission is All You Need</h4><p>手玩发现只有选 ${0}$ 和 ${0,1}$ 时操作二更有收益。因此统计 $0$ 的个数就行了。</p><p>时间复杂度 $\mathcal O(n)$ 。<a href="https://codeforces.com/contest/2130/problem/A">Code</a>.</p><h4 id="B-Pathless"><a href="#B-Pathless" class="headerlink" title="B. Pathless"></a>B. Pathless</h4><p>注意到 $0$ 和 $1$ 不能相邻放。不然可以在这两格间随便刷。</p><p>因此如果有答案，答案应该是 <code>00..022..21..11</code> 形式（将 $2$ 放在 $0$ 或 $1$ 中不会带来本质不同的相邻组合）。接着判断是否有答案。</p><p>设 $\delta &#x3D; s - \sum_{i &#x3D; 1}^{n}a_i$ 。</p><ul><li>若 $\delta &lt; 0$ ，随便放。</li><li>若 $\delta &#x3D;0$ ，无解。</li><li>若 $\delta&#x3D;1$ ，按照上述方法放就行。</li><li>若 $\delta\geq2$ ，总能通过在 <code>02</code> 或者 <code>21</code> 之间多刷出 $\delta $。所以无解。</li></ul><p>被自己的读题习惯害惨了。赛时没看见零一二都有，讨论了好多。</p><p>时间复杂度 $\mathcal O(n)$。<a href="https://codeforces.com/contest/2130/submission/331807681">Code</a>.</p><h4 id="C-Double-Perspective"><a href="#C-Double-Perspective" class="headerlink" title="C. Double Perspective"></a>C. Double Perspective</h4><p>首先发现，如果 $a&lt;b&lt;c$ ，现有 $(a, c) $ 和 $(b, c)$ ，那么删去后者不改变 $f$ 值且有可能使 $g$ 值减小。因此删去它一定不劣于保留它。所以我们对每个数都只保留以它为右端点的线段中最长的一个。</p><p>然后发现这样的取舍方式下，图中根本就没有环了，即 $g&#x3D;0$ 。同时 $f$ 值没有改变。这就是最优方案。</p><p>时间复杂度视实现为 $\mathcal O(n)$ 或 $\mathcal O(n\log n)$ 。笔者的实现为后者。<a href="https://codeforces.com/contest/2130/submission/331827187">Code</a>.</p><h4 id="D-Stay-or-Mirror"><a href="#D-Stay-or-Mirror" class="headerlink" title="D. Stay or Mirror"></a>D. Stay or Mirror</h4><hr><h3 id="2131-CodeForces-Round-1042（Div-3）"><a href="#2131-CodeForces-Round-1042（Div-3）" class="headerlink" title="2131. CodeForces Round 1042（Div. 3）"></a>2131. <a href="https://codeforces.com/contest/2131">CodeForces Round 1042（Div. 3）</a></h3><p><strong>过题：</strong> 5&#x2F;8<strong>排名：</strong> 1396<strong>上分：</strong> + 41 (1605)</p><p>状态依旧很差，F 和 G 本应都做出来，结果双双弃掉。</p><h4 id="A-Lever"><a href="#A-Lever" class="headerlink" title="A. Lever"></a>A. Lever</h4><p>显然操作是随机序还是按照顺序并不影响答案。直接线性扫一遍，统计操作 $1$ 进行的次数即可。</p><p>时间复杂度 $\mathcal O(n)$。<a href="https://codeforces.com/contest/2131/submission/333292159">Code</a>.</p><h4 id="B-Alternating-Series"><a href="#B-Alternating-Series" class="headerlink" title="B. Alternating Series"></a>B. Alternating Series</h4><p>负数小于等于 $-1$ ，因此被夹在两负数间的正数至少为 $3$，两端的正数至少为 $2$ 。</p><p>要使绝对值序列字典序最小，答案一定是 <code>-1 3 -1 ... 3 -1（奇数）</code> 或 <code>-1 3 -1 ... 3 -1 2（偶数）</code> 的形式。</p><p>时间复杂度 $\mathcal O(n)$。<a href="https://codeforces.com/contest/2131/submission/333300394">Code</a>.</p><h4 id="C-Make-it-Equal"><a href="#C-Make-it-Equal" class="headerlink" title="C. Make it Equal"></a>C. Make it Equal</h4><p>观察易知，$a$ 能转化到 $b$ 的条件是：$a\equiv b\pmod k $ ，或者 $a + b \equiv 0 \pmod k$ 。</p><p>考虑用 <code>map</code> 记录模意义下各数对应的原数数量，挨个检查即可。</p><p>时间复杂度 $\mathcal O(n\log n)$。<a href="https://codeforces.com/contest/2131/submission/333312540">Code</a>.</p><h4 id="D-Arboris-Contractio"><a href="#D-Arboris-Contractio" class="headerlink" title="D. Arboris Contractio"></a>D. Arboris Contractio</h4><p>一般来说，菊花图一定有且仅有一个花心，考虑这个花心是谁。</p><p>先假定我们已确定了这个花心。那么最优的操作流程即：每次令该花心为路径一端，再依次选择初始度为 $1$ 的所有结点为路径另一端（若初始距离即为 $1$ ，可跳过该步）。</p><p>设初始度为 $1$ 的结点数量为 $n_0$，其中与花心距离为 $1$ 的结点数量为 $n_1$ 。则答案为：$\min{n_0 - n_1} &#x3D; n_0 - \max{n_1}$ . 统计每个结点的 $n_1$ 取 $\max$ 即可。</p><p>此外，注意特判仅两个结点的 Corner Case。</p><p>时间复杂度 $\mathcal O(n)$。<a href="https://codeforces.com/contest/2131/submission/333312540">Code</a>.</p><h4 id="E-Adjacent-XOR"><a href="#E-Adjacent-XOR" class="headerlink" title="E. Adjacent XOR"></a>E. Adjacent XOR</h4><p>首先，由于每个数只能操作一次，变了之后不能恢复。因此每个数最多 $a_i$ 和 $b_i$ 两种形态。</p><p>先趁右侧的数还未改变，按顺序将能修改的 $a_i$ 都进行修改。然后再倒序操作，在右侧的数已改变的情形下尝试修改。一旦存在修改不成的情况，判断为 <code>NO</code>，否则为 <code>YES</code>。</p><p>时间复杂度 $\mathcal O(n)$。<a href="https://codeforces.com/contest/2131/submission/333379567">Code</a>.</p><p>题外话，一开始以为这题每个数可以进行多次操作。好像比原题更有说法一些。</p><h4 id="F-Unjust-Binary-Life"><a href="#F-Unjust-Binary-Life" class="headerlink" title="*F. Unjust Binary Life"></a>*F. Unjust Binary Life</h4><p>如果存在一条从 $(1,1)\to (x, y)$ 的全 $0$ 路径，则必然产生一系列连等关系最终推得 $a_1…a_x, b_1…b_y$ 全部相等。比如下图中 $a_1 \oplus b_1 &#x3D; a_2\oplus b_1 &#x3D; a_2\oplus b_2 &#x3D; 0$ 可以推得：$a_1 &#x3D; b_1 &#x3D; a_2 &#x3D; b_2&#x3D;…$ 。  </p><p><img src="/CF%E5%90%88%E9%9B%86%5Cpic1.png"></p><p>所以可以得出：<br>$$<br>f(x, y)&#x3D;\min{\sum_{i &#x3D; 1}^x a_i +\sum_{i &#x3D; 1}^y b_i,\quad x + y -(\sum_{i &#x3D; 1}^x a_i + \sum_{i &#x3D; 1}^y b_i)}<br>$$<br>假定有：<br>$$<br>\sum_{i &#x3D; 1}^x a_i +\sum_{i &#x3D; 1}^y b_i\leq x + y -(\sum_{i &#x3D; 1}^x a_i + \sum_{i &#x3D; 1}^y b_i)<br>$$<br>分离变量可以得到：<br>$$<br>2\sum_{i &#x3D; 1}^x a_i - x\leq y - 2\sum_{i &#x3D; 1}^y b_i<br>$$<br>固定 $x$，枚举 $y$ 。上式符合时， $(x, y)$ 对答案的贡献是 $\sum_{i &#x3D; 1}^x a_i +\sum_{i &#x3D; 1}^y b_i$ ，否则为 $x + y -(\sum_{i &#x3D; 1}^x a_i + \sum_{i &#x3D; 1}^y b_i)$.</p><p>因此我们将所有 $y$ 按照 $y - 2\sum_{i &#x3D; 1}^y b_i$ 排序，对排序后的两种贡献分别做前缀和。这样在枚举 $x$ 时便可以二分找到分界点，根据前缀和快速得到这一行对答案的总贡献。</p><p>时间复杂度 $\mathcal O(n\log n)$。<a href="https://codeforces.com/contest/2131/submission/334801885">Code</a>.</p><hr><h3 id="2132-CodeForces-Round-1043（Div-3）"><a href="#2132-CodeForces-Round-1043（Div-3）" class="headerlink" title="2132. CodeForces Round 1043（Div. 3）"></a>2132. <a href="https://codeforces.com/contest/2132">CodeForces Round 1043（Div. 3）</a></h3><p><strong>过题：</strong> 4&#x2F;8<strong>排名：</strong> 3736<strong>上分：</strong> –</p><p>下次碰到这种C1C2，还是先把两者的区别看清楚再决定先写哪个……</p><h4 id="A-Homework"><a href="#A-Homework" class="headerlink" title="A. Homework"></a>A. Homework</h4><p>利用 <code>string</code> 可以加减的特性，直接写。<a href="https://codeforces.com/contest/2132/submission/334811830">Code</a>.</p><h4 id="B-The-Secret-Number"><a href="#B-The-Secret-Number" class="headerlink" title="B. The Secret Number"></a>B. The Secret Number</h4><p>直接枚举范围内的 $10^k+1$ ，找到其中是 $n$ 因子的，那么 $\frac{n}{10^k+1}$ 就是一个答案。<a href="https://codeforces.com/contest/2132/submission/334827583">Code</a>.</p><h4 id="C1-The-Cunning-Seller-easy-version"><a href="#C1-The-Cunning-Seller-easy-version" class="headerlink" title="C1. The Cunning Seller (easy version)"></a>C1. The Cunning Seller (easy version)</h4><p>由于要求交易次数最少，对 $n$ 进行三进制分解即可。<a href="https://codeforces.com/contest/2132/submission/334848096">Code</a>.</p><h4 id="C2-The-Cunning-Seller-hard-version"><a href="#C2-The-Cunning-Seller-hard-version" class="headerlink" title="C2. The Cunning Seller (hard version)"></a>C2. The Cunning Seller (hard version)</h4><p>困难版本不再要求交易次数最少，而是给定了一个上限。这意味着我们获得了一定的操作空间。</p><p>直接购买 $3^x$ 个的代价是 $3^{x+1}+x\cdot 3 ^ {x - 1}$，而进行 $3$ 次购买 $3 ^ {x - 1}$ 个的交易的代价是 $3(3^x+(x - 1)3^{x -2})$ ，也就是 $3^{x + 1}+(x - 1)3^{x - 1}$ 。比直接购买所需代价少 $3^{x - 1}$。</p><hr><h3 id="2133-CodeForces-Round-1044（Div-2）"><a href="#2133-CodeForces-Round-1044（Div-2）" class="headerlink" title="2133. CodeForces Round 1044（Div. 2）"></a>2133. <a href="https://codeforces.com/contest/2133">CodeForces Round 1044（Div. 2）</a></h3><p><strong>过题：</strong> 4&#x2F;8<strong>排名：</strong> 1139<strong>上分：</strong> + 70 (1675)</p><p>前半程直呼从未有过如此美妙的开局，丝滑地开完了ABCD。然而D瞬间WA#2，临近尾声才发现是交错代码了，太变态了。如果正常交上去了这把能上很多分。</p><h4 id="A-Redstone"><a href="#A-Redstone" class="headerlink" title="A. Redstone?"></a>A. Redstone?</h4><p>除了头尾的数都会被约掉，所以要使得乘积为 $1$，只需找到两个相等的数做头尾。</p><p>时间复杂度 $\mathcal O(n)$ 。<a href="https://codeforces.com/contest/2133/submission/335317695">Code</a>.</p><h4 id="B-Villagers"><a href="#B-Villagers" class="headerlink" title="B. Villagers"></a>B. Villagers</h4><p>揣摩样例可知，两两配对完成后再进行合并代价就是 $0$ 了，这是很优的。</p><p>要使得配对这个过程代价最小，做法就是先倒序排序，然后 $(g_1,g_2),(g_3,g_4)\dots$ 相邻的配对。</p><p>正确性似乎并不是太好说明，此处就略去了。</p><p>时间复杂度 $\mathcal O(n\log n)$ 。<a href="https://codeforces.com/contest/2133/submission/335328351">Code</a>.</p><h4 id="C-The-Nether"><a href="#C-The-Nether" class="headerlink" title="C. The Nether"></a>C. The Nether</h4><hr><h3 id="2134-CodeForces-Round-1045（Div-2）"><a href="#2134-CodeForces-Round-1045（Div-2）" class="headerlink" title="2134. CodeForces Round 1045（Div. 2）"></a>2134. <a href="https://codeforces.com/contest/2134">CodeForces Round 1045（Div. 2）</a></h3><p><strong>过题：</strong> 3&#x2F;6<strong>排名：</strong> 3829<strong>上分：</strong> - 34 (1641)</p><p>还是自己太菜了。BC若只题写写写半天，D题又死活看不出结论，活该掉分。</p><h4 id="A-Painting-With-Two-Colors"><a href="#A-Painting-With-Two-Colors" class="headerlink" title="A. Painting With Two Colors"></a>A. Painting With Two Colors</h4><h4 id="B-Add-0-or-K"><a href="#B-Add-0-or-K" class="headerlink" title="B. Add 0 or K"></a>B. Add 0 or K</h4><h4 id="C-Even-Larger"><a href="#C-Even-Larger" class="headerlink" title="C. Even Larger"></a>C. Even Larger</h4><hr><h3 id="2136-CodeForces-Round-1046（Div-2）"><a href="#2136-CodeForces-Round-1046（Div-2）" class="headerlink" title="2136. CodeForces Round 1046（Div. 2）"></a>2136. <a href="https://codeforces.com/contest/2136">CodeForces Round 1046（Div. 2）</a></h3><p><strong>过题：</strong> 5&#x2F;7<strong>排名：</strong> 537 <strong>上分：</strong> +79 (1720)</p><p>感觉是近期发挥最好的一场，除了D代码实现得太慢，其他题都在合适的时间内想到正解并码出。交互题是对的，建议CF多多的出。</p><h4 id="A-In-the-Dream"><a href="#A-In-the-Dream" class="headerlink" title="A. In the Dream"></a>A. In the Dream</h4><p>显然如果一方在半场内进了 $a$ 球，且没有被连续打进 $3$ 球，则另一方至多进了 $2(a+1)$ 球。因此只需判断上下半场是否都没有出现超出的情况。</p><p>时间复杂度 $\mathcal O(1)$。<a href="https://codeforces.com/contest/2136/submission/335948108">Code</a>.</p><h4 id="B-Like-the-Bitset"><a href="#B-Like-the-Bitset" class="headerlink" title="B. Like the Bitset"></a>B. Like the Bitset</h4><p>首先发现，挑选一个满足 $s_i&#x3D;0$ 的 $i$ 放入 $n$ ，即同时满足了区间 $\left[ i - k + 1,i + k - 1\right]$ 内所有的要求。</p><p>试着按照这个思路来让合法区间覆盖满区间 $\left[1, n\right]$。操作流程为每次从当前位置向右跳 $k$ 格，然后往回找到最近的 $s_i &#x3D; 0$ 处填入当前所剩的最大值，循环这一流程。如果直到退回上一个位置还未找到 $0$ 则判断为无解。正确性证明略。</p><p>在这一流程中，每个下标至多被访问一次。时间复杂度 $\mathcal O(n)$ 。<a href="https://codeforces.com/contest/2136/submission/335969855">Code</a>.</p><h4 id="C-Against-the-Difference"><a href="#C-Against-the-Difference" class="headerlink" title="C. Against the Difference"></a>C. Against the Difference</h4><p>首先对于每一个 $i$，设这是 $a_i$ 第 $k$ 次出现。如果 $k &gt;&#x3D; a_i$，令 $pre_i$ 为 $a_i$ 第 $k - a_i + 1$ 次出现的位置；否则设置为默认值 $-1$。这一过程可以利用二维 <code>vector</code> 实现。</p><p>用 $f_i$ 表示区间 $\left[1, i\right]$ 内，整洁序列的最大长度。于是有如下转移：<br>$$<br>f_i &#x3D; \max(f_{i - 1}, f_{pre_i - 1}+a_i)<br>$$<br>其中前者代表不选 $a_i$ 的方案，后者表示选 $a_i$ 的方案。</p><p>线性扫描一次即可。时间复杂度 $\mathcal O(n)$ 。<a href="https://codeforces.com/contest/2136/submission/335989110">Code</a>.</p><h4 id="D-For-the-Champion"><a href="#D-For-the-Champion" class="headerlink" title="D. For the Champion"></a>D. For the Champion</h4><p>首先注意到对于极大的 $X$ 和 $Y$ ，点 $(X, Y)$ 与锚点 $(x_i,y_i)$ 间的曼哈顿距离 $|X-x_i|+|Y - y_i|$ 可以直接去绝对值，写作 $(X+Y) - (x_i + y_i)$ 。</p><p>设机器人初始位置为 $(a, b)$ ，当我们将其移至足够大的 $(a+M, b+N)$ 之后发起询问，得到的 $\min _{1\leq i\leq n} (a+b+M+N - (x_i + y_i))$ 即为 $a+b+M+N - \max _{1\leq i\leq n}(x_i + y_i)$ 。$M+N$ 是已知值，而 $\max$ 下的内容可以提前处理得到。于是我们可以计算得到 $a + b$ 的值。</p><p>接着我们移动到 $(a+M, b-G)$ ，其中 $b-G \leq\min y_i$ 。便可以得到 $\min _{1\leq i\leq n} (a-b+M+G-(x_i-y_i))$ ，同理可以计算得到 $a-b$。</p><p>两相联立便解出了 $(a, b)$ 的值。</p><p>由于题目给出了步长的限制，还需要检验这些操作能否在 $10$ 步内完成。$-10^9\leq a,b\leq 10^9$ ，且 $a+M, b+N\geq 10^9$ 。可以得到 $M, N\leq 2\times 10^9$ 。因此第一阶段我们直接以 $10^9$ 的步长向上两次，再向右两次即可保证在所有锚点的右上方。</p><p>此时坐标为 $(a+2\times 10^9,b+2\times 10^9)$ ，横纵坐标的范围都是 $[10^9,3\times 10^9]$ 。再以 $10^9$ 的步长向下走四步即可保证在所有锚点的右下方。总步数 $8$ 步，符合要求。<a href="https://codeforces.com/contest/2136/submission/336018954">Code</a>.</p><h4 id="F1-From-the-Unknown-Easy-Version"><a href="#F1-From-the-Unknown-Easy-Version" class="headerlink" title="F1. From the Unknown (Easy Version)"></a>F1. From the Unknown (Easy Version)</h4><p>一共只能询问两次，所以最好每次询问都能获得有效的信息。</p><p>一个很自然的想法是直接询问一次 <code>? 100000 1 1 1...1 1</code> 来获得行长的大致范围（假设第一次的回答是 $p$ 行，可知每行长度处于 $[\frac{N}{p},\frac{N}{p - 1})$ 范围内。），再根据范围构造一个输入序列获得精确值。</p><p>之所以说这是自然的，是因为如果输入的某个单词长度超过了行长，我们将不会得到任何有效信息。这意味着第一次输入时，词长必须全部足够小。</p><p>设行长可能值最小为 $L$，最大为 $R$ 。第二次询问的构造如下：<code>? 2*(R - L) L 1 L 2 L 3...L R - L</code> 。当 $L+i\leq len$ 时， $L$ 和 $i$ 位列同一行；此后分列两行。因此，如果总行数为 $x$ ，行长就是 $2(R-L)-x+L$。</p><p>另外，特判一下 $L&#x3D;R$ 的情况，避免出现 $n&#x3D;0$ 的不合法询问。</p><p>总的来说，是道不错的构造题。<a href="https://codeforces.com/contest/2136/submission/336042071">Code</a>.</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⌈25暑训⌋ 第5&amp;6场补题</title>
    <link href="/2025/07/25/%E6%9A%91%E8%AE%AD5&amp;6%20%E8%A1%A5%E9%A2%98/"/>
    <url>/2025/07/25/%E6%9A%91%E8%AE%AD5&amp;6%20%E8%A1%A5%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="5H"><a href="#5H" class="headerlink" title="5H"></a>5H</h1><blockquote><p><strong>题目大意：</strong><br>给定 $n, m, s, t, {a_n},{k_n},{b_n},{c_n}$。<br>每次操作，选定任一非 $0$ 的 $b_i \to \max{b_i - p, 0}$ ，若此后 $b_i&#x3D;0$， $a_i\to \max{a_i - c_i, 0}$.<br>然后选择一项：</p><ul><li>使第一个非 $0$ 的 $a_i \to \max{a_i - m, 0}$。若此后 $a_i&#x3D;0$， $m\to m+k_i$.</li><li>$cnt \to cnt + m$ （$cnt$ 初始为 $0$）<br>求 $\min p$ ，使得存在一种方案使得 $t$ 次操作内可能使 $cnt\geq s$.</li></ul></blockquote><blockquote><p><strong>知识点：</strong> 二分，dp</p></blockquote><p>这题的难度相当一部分来自于冗长的题面，我费了老大劲才把原题面中 <strong>Civilization VI</strong> 的元素换成了数学语言。赛时也是被这题面吓到以为是大模拟。</p><p>首先显然可以二分答案，将问题转化成给定 $p$ ，判定方案存在性。</p><p>考虑 $dp$ 来做。令 $dp_{i,j,l}$ 表示前 $i$ 次操作中，已经使 $a_j&#x3D;0$，选择了 $l$ 次 $b_NaN$ 中元素的情况下 $cnt$ 的最大值。</p><p>设 $sum_i &#x3D; m+\sum_{j&#x3D;1}^{i}k_j$ ，有如下三种转移：</p><ul><li><p>第 $i$ 次操作选择增加 $cnt$：<br>$$<br>dp_{i,j,l}+sum_j\to dp_{i+1,j,l+1}<br>$$</p></li><li><p>通过若干次操作使 $a_{j+1}\to0$（未触发 $a_i\to \max{a_i - c_i, 0}$）：<br>$$<br>dp_{i,j,l}\to dp_{i+\left \lceil \frac{a_{j+1}}{sum_j} \right \rceil,j+1, l+\left \lceil \frac{a_{j+1}}{sum_j} \right \rceil}<br>$$</p></li><li><p>通过若干次操作使 $a_{j+1}\to0$（触发 $a_i\to \max{a_i - c_i, 0}$）：<br>$$<br>dp_{i,j,l}\to dp_{i+ \left \lceil \frac{a_{j+1} - c_{j+1}}{sum_j} \right \rceil,j+1,l-\left \lceil \frac{b_{j+1}}{p} \right \rceil + \left \lceil \frac{a_{j+1} - c_{j+1}}{sum_j} \right \rceil}<br>$$<br>其中 $l-\left \lceil \frac{b_{j+1}}{p} \right \rceil + \left \lceil \frac{a_{j+1} - c_{j+1}}{sum_j} \right \rceil \geq 0$ 。</p></li></ul><p>存在某 $dp_{i,j,l}\geq s$ 则方案存在。</p><p>注意写好转移时的边界条件，并特判 $p&#x3D;0$ 的情况即可。</p><p>时间复杂度 $\mathcal O(t^2n\log b)$ ，可以通过本题。</p><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOR(i,a,b) for (int i = a; i &lt;= b; i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ceiL(x, y) ((x - 1) / y + 1)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">105</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = LONG_LONG_MAX;<br><br><span class="hljs-type">int</span> n, m, s, t;<br><span class="hljs-type">int</span> sumk[N];<br><br><span class="hljs-type">int</span> a[N], k[N], b[N], c[N];<br><br><span class="hljs-type">int</span> dp[N][N][N];<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, t) <span class="hljs-built_in">FOR</span>(j, <span class="hljs-number">0</span>, n) <span class="hljs-built_in">FOR</span>(l, <span class="hljs-number">0</span>, t) dp[i][j][l] = -INF;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, t) &#123;<br>        <span class="hljs-built_in">FOR</span>(j, <span class="hljs-number">0</span>, n) &#123;<br>            <span class="hljs-built_in">FOR</span>(l, <span class="hljs-number">0</span>, i) &#123;<br>                <span class="hljs-keyword">if</span> (dp[i][j][l] == -INF) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (dp[i][j][l] &gt;= s) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; N &amp;&amp; l + <span class="hljs-number">1</span> &lt; N) dp[i + <span class="hljs-number">1</span>][j][l + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-number">1</span>][j][l + <span class="hljs-number">1</span>], dp[i][j][l] + sumk[j]);<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j]) &lt; N &amp;&amp; j + <span class="hljs-number">1</span> &lt; N &amp;&amp; l + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j]) &lt; N)<br>                    dp[i + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j])][j + <span class="hljs-number">1</span>][l + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j])] <br>                    = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j])][j + <span class="hljs-number">1</span>][l + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j])], dp[i][j][l]);<br>                <span class="hljs-type">int</span> newl = l - <span class="hljs-built_in">ceiL</span>(b[j + <span class="hljs-number">1</span>], x) + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>] - c[j + <span class="hljs-number">1</span>], sumk[j]);<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>] - c[j + <span class="hljs-number">1</span>], sumk[j]) &lt; N &amp;&amp; j + <span class="hljs-number">1</span> &lt; N &amp;&amp; newl &gt;= <span class="hljs-number">0</span> &amp;&amp; newl &lt; N) <br>                    dp[i + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>] - c[j + <span class="hljs-number">1</span>], sumk[j])][j + <span class="hljs-number">1</span>][newl]<br>                    = <span class="hljs-built_in">max</span>(dp[i][j][l], dp[i + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>] - c[j + <span class="hljs-number">1</span>], sumk[j])][j + <span class="hljs-number">1</span>][newl]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; m &gt;&gt; s &gt;&gt; t;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; a[i] &gt;&gt; k[i] &gt;&gt; b[i] &gt;&gt; c[i];<br>    sumk[<span class="hljs-number">0</span>] = m;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) sumk[i] = sumk[i - <span class="hljs-number">1</span>] + k[i];<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, N - <span class="hljs-number">1</span>) <span class="hljs-built_in">FOR</span>(j, <span class="hljs-number">0</span>, N - <span class="hljs-number">1</span>) <span class="hljs-built_in">FOR</span>(k, <span class="hljs-number">0</span>, N - <span class="hljs-number">1</span>) dp[i][j][k] = -INF;<br>    <span class="hljs-comment">// 先判断 p = 0 行不行，只有前两种转移</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, t) &#123;<br>        <span class="hljs-built_in">FOR</span>(j, <span class="hljs-number">0</span>, n) &#123;<br>            <span class="hljs-built_in">FOR</span>(l, <span class="hljs-number">0</span>, i) &#123;<br>                <span class="hljs-keyword">if</span> (dp[i][j][l] == -INF) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">if</span> (dp[i][j][l] &gt;= s) &#123; cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; N &amp;&amp; l + <span class="hljs-number">1</span> &lt; N) dp[i + <span class="hljs-number">1</span>][j][l + <span class="hljs-number">1</span>] = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-number">1</span>][j][l + <span class="hljs-number">1</span>], dp[i][j][l] + sumk[j]);<br>                <span class="hljs-keyword">if</span> (i + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j]) &lt; N &amp;&amp; j + <span class="hljs-number">1</span> &lt; N &amp;&amp; l + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j]) &lt; N)<br>                    dp[i + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j])][j + <span class="hljs-number">1</span>][l + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j])] <br>                    = <span class="hljs-built_in">max</span>(dp[i + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j])][j + <span class="hljs-number">1</span>][l + <span class="hljs-built_in">ceiL</span>(a[j + <span class="hljs-number">1</span>], sumk[j])], dp[i][j][l]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> L = <span class="hljs-number">1</span>, R = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (L &lt; R) &#123;<br>        <span class="hljs-type">int</span> mid = (L + R) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) R = mid;<br>        <span class="hljs-keyword">else</span> L = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check</span>(L)) cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; L &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5L"><a href="#5L" class="headerlink" title="5L"></a>5L</h1><blockquote><p><strong>题目大意：</strong><br>现有 $a&#x3D;0$ 和 $b&#x3D;z$，目标为使 $a&#x3D;n$。你每次尝试有 $p$ 的概率成功使 $a\to a + 1$ ，另有 $1−p$ 的概率失败。<br>失败时，若 $b&gt;0,b\to b-1$，否则 $a\to 0$。对于每个 $z \in[0,m]$，求期望尝试次数。</p></blockquote><blockquote><p><strong>知识点：</strong> 期望dp</p></blockquote><p>将总期望尝试次数拆成 $b &gt; 0$ 和 $b &#x3D; 0$ 两部分（可能在第一部分中已经达成目标，那么第二部分就没有被经过）</p><p>先考虑 $b &gt; 0$ 的情形。考虑二维状态 $(i, j)$ ，表示当前 $a &#x3D; i$，$b &#x3D; z - j$。初始状态为 $(0,0)$ ，目标状态为 $(n,?)$ 。状态转移为：有 $p$ 的概率 $(i,j)\to (i+1,j)$ ，$(1 - p)$ 的概率 $(i,j) \to (i, j + 1)$。由于不会走回头路，第一部分的期望步数就是所有状态的概率之和。</p><p>假设 $P_{i,j}$ 表示经过某状态的概率，可得方程：<br>$$<br>P_{i,j}&#x3D;\begin{cases}<br>1 &amp;\text {if } i, j &#x3D; 0<br>\<br>p P_{i - 1, j} &amp;\text{if } j &#x3D; 0<br>\<br>(1-p)P_{i, j - 1} &amp; \text{if } i &#x3D; 0<br>\<br>pP_{i - 1,j}+(1 - p)P_{i,j - 1} &amp; \text{if } i, j\neq 0<br>\end{cases}<br>$$<br>设 $S_j &#x3D; \sum_{i &#x3D; 0}^{n - 1}P_{i, j}$，由于 $P_{i, j} &#x3D; pP_{i - 1, j} + (1 - p)P_{i, j - 1}$ ， 累加可得：<br>$$<br>\sum_{i &#x3D; 0} ^ {n - 1} P_{i, j} &#x3D; p\sum_{i &#x3D; 0} ^{n - 1}P_{i - 1, j} + (1 - p) \sum_{i &#x3D; 0}^{n - 1} P_{i, j - 1}<br>$$<br>整理之后可得：<br>$$<br>S_j &#x3D; p(S_j - P_{n - 1, j} + P_{-1, j})+(1 - p)S_{j - 1}<br>\<br>S_j &#x3D; S_{j - 1}-\frac p {1 - p} P_{n - 1, j}<br>\<br>S_0 &#x3D; \frac{1 - p^n}{1 - p}<br>$$<br>再结合 $P_{n - 1, j}$ 的递推式：<br>$$<br>P_{n - 1, j} &#x3D; C_{n - 1 + j}^{j}p^{n - 1}(1 - p)^{j} &#x3D; \frac{(n - 1 + j)(1 - p)}{j} P_{n - 1, j - 1}<br>$$<br>就可以通过递推得到 $S_j$ ，而对于每个 $z$ ，这一部分的答案就是 $\sum_{j &#x3D; 0}^{z}S_j$。</p><p>再考虑 $b &#x3D; 0$ 的情形。这一部分的期望尝试次数是好计算的。</p><p>设从 $a$ 从 $0$ 到 $i$ 期望尝试次数为 $D_i$ ，从 $i - 1$ 到 $i$ 的期望尝试次数为 $d_i$ ，则可以得到以下式子：<br>$$<br>\begin{align}<br>\begin{cases}<br>d_i &#x3D; p + (1 - p) (D_i+1)<br> \<br>d_i &#x3D; D_i - D_{i - 1}<br>\end{cases}<br>\end{align}<br>$$<br>可以解得：<br>$$<br>pD_i &#x3D; D_{i - 1} + 1<br>\<br>p(D_i + \frac{1}{1-p}) &#x3D; D_{i - 1} +\frac{1}{1 - p}<br>\<br>D_i &#x3D; \frac{1 - p^i}{(1 - p)p^i}<br>$$<br>而进入第二部分的概率就是是简单的 $S_z(1-p)$ ，将概率和期望尝试次数相乘即为第二部分的答案。</p><p>总体上时间复杂度为 $\mathcal O (m\log m)$ ，可通过预处理逆元优化为线性。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++">cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;<br><span class="hljs-keyword">if</span> (p == <span class="hljs-number">1</span>) &#123;<br><span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, m) cout &lt;&lt; n % MOD &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>pbex = <span class="hljs-built_in">qp</span>(<span class="hljs-built_in">inv</span>(p), n) - <span class="hljs-number">1ll</span>;<br>pp = <span class="hljs-built_in">qp</span>(p, n - <span class="hljs-number">1ll</span>);<br>ans = sum = (<span class="hljs-built_in">qp</span>(p, n) + MOD - <span class="hljs-number">1ll</span>) * <span class="hljs-built_in">inv</span>(p + MOD - <span class="hljs-number">1ll</span>) % MOD;<br>cout &lt;&lt; (ans + pbex * sum % MOD) % MOD &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, m) &#123;<br>    pp = pp * (n - <span class="hljs-number">1ll</span> + i) % MOD * <span class="hljs-built_in">inv</span>(i) % MOD * (MOD + <span class="hljs-number">1ll</span> - p) % MOD;<br>    sum = (sum + pp * (MOD - p) % MOD * <span class="hljs-built_in">inv</span>(MOD + <span class="hljs-number">1ll</span> - p) % MOD) % MOD;<br>    ans = (ans + sum) % MOD;<br>    cout &lt;&lt; (ans + pbex * sum % MOD) % MOD &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="6E"><a href="#6E" class="headerlink" title="6E"></a>6E</h1><blockquote><p><strong>题目大意：</strong><br>给定 $a$ 和 $p$ 两个数组，在线处理 $q$ 个操作，操作有两种类型：</p><ul><li>给定 $l$ ， $r$ ，$x$。使 $a_i \to a_i + x (i\in [l, r])$</li><li>给定 $l$， $r$。 计算 $\sum_{i &#x3D; l} ^r a_{p_i}$ 。</li></ul></blockquote><blockquote><p><strong>知识点：</strong> 分块</p></blockquote><p>考虑朴素的分块。记块长为 $L$ ，$a$ 的第 $i$ 个块为 $A_i$ ，$a_p$ 的第 $i$ 个块是 $B_i$ 。</p><p>再记 $A_i$ 整块加一后 $B_j$ 的增量为 $f_{i, j}$ 。并对 $f_i$ 做前缀和 $S_{i, j}$ 。（可以在预处理时 $\mathcal O(n + (\frac{n}{L})^2)$ 求得）</p><p>修改涉及整块时，对 $A_i$ 维护一个懒标记 $tag_i$ ，则其对 $B_{l..r}$ 的影响之和为 $tag_i \sum_{j &#x3D; l}^{r}f_{i,j}$ ，即 $tag_i (S_{i, r} - S_{i, l - 1})$ 。至于不成整块的部分，直接暴力修改。单次修改时间复杂度为 $\mathcal O(\frac nL + L)$  。</p><p>查询时类似。整块用懒标记统计增量，不成整块的部分直接暴力统计。单次修改时间复杂度也为 $\mathcal O(\frac n L + L)$ 。</p><p>取 $L &#x3D; \sqrt n$，则总时间复杂度为 $\mathcal O(n + q\sqrt n)$ ，可以通过本题。</p><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOR(i,j,k) for (int i = j; i &lt;= k; i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int, int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb(x) push_back(x)</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> B = <span class="hljs-number">320</span>;<br><br><span class="hljs-type">int</span> n, m, k, q;<br><span class="hljs-type">int</span> op, l, r, x, ans;<br><br><span class="hljs-type">int</span> a[N], ap[N], c[N], p[N], bg[N], ed[N];<br><span class="hljs-type">int</span> lz[B + <span class="hljs-number">10</span>], f[B + <span class="hljs-number">10</span>][B + <span class="hljs-number">10</span>], sum[B + <span class="hljs-number">10</span>][B + <span class="hljs-number">10</span>];<br><br>vector&lt;<span class="hljs-type">int</span>&gt; vc[N];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; q;<br>    m = (n - <span class="hljs-number">1</span>) / B + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        cin &gt;&gt; p[i];<br>        vc[p[i]].<span class="hljs-built_in">pb</span>(i);<br>        c[i] = (i - <span class="hljs-number">1</span>) / B + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (i % B == <span class="hljs-number">1</span>) bg[c[i]] = i;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i % B == <span class="hljs-number">0</span> || i == n) ed[c[i]] = i;<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) f[c[p[i]]][c[i]] += <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, m) <span class="hljs-built_in">FOR</span>(j, <span class="hljs-number">1</span>, m) sum[i][j] = sum[i][j - <span class="hljs-number">1</span>] + f[i][j];<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        cin &gt;&gt; op &gt;&gt; l &gt;&gt; r; l ^= ans; r ^= ans;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>            cin &gt;&gt; x; x ^= ans;<br>            <span class="hljs-keyword">if</span> (c[l] == c[r]) &#123;<br>                <span class="hljs-built_in">FOR</span>(i, l, r) &#123;<br>                    a[i] += x;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : vc[i]) ap[c[j]] += x;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">FOR</span>(i, c[l] + <span class="hljs-number">1</span>, c[r] - <span class="hljs-number">1</span>) lz[i] += x;<br>                <span class="hljs-built_in">FOR</span>(i, l, ed[c[l]]) &#123;<br>                    a[i] += x;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : vc[i]) ap[c[j]] += x;<br>                &#125;<br>                <span class="hljs-built_in">FOR</span>(i, bg[c[r]], r) &#123;<br>                    a[i] += x;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : vc[i]) ap[c[j]] += x;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (c[l] == c[r]) <span class="hljs-built_in">FOR</span>(i, l, r) ret += a[p[i]] + lz[c[p[i]]];<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">FOR</span>(i, c[l] + <span class="hljs-number">1</span>, c[r] - <span class="hljs-number">1</span>) ret += ap[i];<br>                <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, m) ret += lz[i] * (sum[i][c[r] - <span class="hljs-number">1</span>] - sum[i][c[l]]);<br>                <span class="hljs-built_in">FOR</span>(i, l, ed[c[l]]) ret += a[p[i]] + lz[c[p[i]]];<br>                <span class="hljs-built_in">FOR</span>(i, bg[c[r]], r) ret += a[p[i]] + lz[c[p[i]]];<br>            &#125;<br>            cout &lt;&lt; ret &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>            ans = ret;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>25暑训</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⌈25暑训⌋ 第3&amp;4场补题</title>
    <link href="/2025/07/25/%E6%9A%91%E8%AE%AD3&amp;4%20%E8%A1%A5%E9%A2%98/"/>
    <url>/2025/07/25/%E6%9A%91%E8%AE%AD3&amp;4%20%E8%A1%A5%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p><strong>题目大意：</strong><br>给定一个由小写字母构成的字符串和若干次修改操作。在每次修改后，求其符合以下要求的最大子串长度：出现奇数次的字母有奇数个，出现非零偶数次的字母有偶数个。</p><p><strong>难度：</strong> ~2000<br><strong>知识点：</strong> 线段树，分类讨论</p><p>观察可以得到，要求等价于：串长和字符集大小都为奇数。这一点可以通过枚举串长和字符集大小各自的奇偶性来验证。</p><p>然后进行分类讨论。</p><ul><li><p>当字符集大小为奇数时：</p><ul><li><p>如果串长为奇数：直接取原串即可。</p></li><li><p>如果串长为偶数：</p><ul><li><p>如果首或尾字母出现了超过一次，那么删去它不改变字符集大小，但让串长变为奇数，符合了要求。</p></li><li><p>如果首尾字母都只出现了一次，我们正序和倒序分别找到第一个出现多次的字母。为了方便下文叙述，我们不妨设原串形如 <code>[abcd X ... Y uvw]</code>，其中小&#x2F;大写字母分别代表出现一&#x2F;多次的字母。</p><p>那么如果我们只删去头尾的若干字母，字符集大小和串长的奇偶性一定同时改变，不可能同时变为奇数。因此，我们至少需要删到串中的 <code>X</code> 或 <code>Y</code> 。</p><ul><li>如果删去的串长为奇数（如 <code>[abcdX]</code>），则剩下的串长和字符集大小都为奇数，符合了要求。</li><li>如果删去的串长为偶数（如 <code>[Yuvw]</code>），则剩下的串长和字符集大小都为偶数，我们再删去另一端的一个字母即可符合要求。</li></ul><p>分别求解删除两端的情形后，对答案取较大值即可。</p></li></ul></li></ul></li><li><p>当字符集大小为偶数时：</p><p>我们可以这样做：对于每种字符，求不含它的极大子串。可以证明，所有极长子串中最长的一个的字符集大小一定就是原串字符集大小减一，是一个奇数。</p><p>证明很显然。记原串形如 <code>...A[...]A..</code> ，<code>[...]</code> 是最大极长子串，不包含的字母是 <code>A</code>。</p><p>使用反证法，假设该子串字符集大小不为原串字符集大小减一，说明一定存在某不为 <code>A</code> 的字母不在该子串中，记为 <code>B</code>。无论原串的形式为 <code>..B...A[...]A..</code> 还是 <code>..B..A[...]A..B..</code> ，不含 <code>B</code> 的极大子串一定比不含 <code>A</code> 的极大子串更长，这与 <code>[...]</code> 是最大极长子串相矛盾。因此假设不成立，证明完成。</p><p>由于至少需要删去一种字符，最终的答案一定不长于最大极长子串，此处设该最大极长子串长度为 $L$。</p><ul><li><p>如果最大极长子串串长为奇数，直接取，答案就是 $L$。</p></li><li><p>如果最大极长子串串长为偶数，与第一类讨论类似地：</p><ul><li><p>如果子串首或尾字母在串内出现了超过一次，那么删去它不改变字符集大小，但让串长变为奇数，符合了要求。答案是 $L - 1$。</p></li><li><p>如果首尾字母都只出现了一次，记原串形如 <code>...A [abc X ... Y uvw] A...</code>，其中小&#x2F;大写字母分别代表在子串内出现一&#x2F;多次的字母，<code>[]</code> 内为最大极长子串。</p><p>观察后可知，<code>A</code> 右侧为 <code>a</code> 或右边界。否则 <code>a</code> 分割成的子串将长于最大极长子串。该性质可以向左右推广，也就是说原串一定是 <code>...uvw A [abc X ... Y uvw] A abc...</code> 的子串。</p><p>我们考虑 <code>...A(abc X ... Y uvw A)...</code> 括号内的串，初始字符集大小为偶数，串长为奇数。</p><p>试着往右侧移动括号范围。括号内最左侧仍为单次出现的字母时，括号内子串奇偶性质保持不变。</p><p>当最左侧为多次出现字母时（如 <code>...A abc (X ... Y uvw A abc)...</code> 所示）我们直接删去最左侧的 <code>X</code> 和最右侧的 <code>c</code>，剩下的串长和字符集大小都为奇数。这个奇数是不大于最大极长子串长度的最大奇数，是最优值。向左侧移动同理。只要有一侧能移到，答案就是 $L - 1$。这个过程中移动不超过 $26$ 次。</p><p>移不到的情况形如 <code>vw A ab(c X ... Y uvw A ab)</code>，子串两侧的部分长度很短。</p><p>由于初始时 <code>()</code> 内字符集大小为偶数，串长为奇数。而删单次出现字符会使字符集大小和串长的奇偶性同时改变，不能使两者同时变为奇数。必须删多次出现的字母。</p><p>以上串为例，再删去括号内的 <code>cX</code> 后，剩下部分的字符集大小和串长的奇偶性就相同了。如果是偶数就再删去另一侧的一个单次出现字母即可。求解只需要找到 <code>X</code> 和 <code>Y</code> 的位置，根据其到另一侧的距离计算即可。</p></li></ul></li></ul><p>可以看见，解决问题的关键就是维护当前最大极长子串。</p><p>我们开 $26$ 个线段树，维护各字母对应的极长子串。将当前字母视为 $1$，其他字母视为 $0$，则问题转化为求最长的连续零段。</p><p>线段树内每个节点维护以下信息：【1】区间内最长连续零段的长度；【2】区间内最长连续零段的起始位置【3】从区间最左端起的连续零段的长度；【4】在区间最右端止的连续零段的长度。【5】区间和。</p><p>其中维护【5】是为了快速得到某区间内某字母是否多次出现。</p></li></ul><p>Code：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int, int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOR(i, a, b) for (int i = a; i &lt;= b; i++)</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> n, q, cnt;<br><span class="hljs-type">int</span> Ans;<br>string ss, s;<br><br>map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; mp;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">seg_tree</span> &#123;<br><br>    <span class="hljs-type">char</span> id;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>        <span class="hljs-type">int</span> mx, lmx, rmx, pos, val;<br>    &#125; t[N &lt;&lt; <span class="hljs-number">2</span>];<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        t[u].val = t[u &lt;&lt; <span class="hljs-number">1</span>].val + t[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].val;<br>        <span class="hljs-type">int</span> mmx = t[u &lt;&lt; <span class="hljs-number">1</span>].rmx + t[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].lmx;<br>        t[u].mx = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(t[u &lt;&lt; <span class="hljs-number">1</span>].mx, t[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].mx), mmx);<br>        t[u].lmx = t[u &lt;&lt; <span class="hljs-number">1</span>].lmx;<br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (t[u &lt;&lt; <span class="hljs-number">1</span>].lmx == mid - l + <span class="hljs-number">1</span>) t[u].lmx += t[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].lmx;<br>        t[u].rmx = t[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].rmx;<br>        <span class="hljs-keyword">if</span> (t[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].rmx == r - mid) t[u].rmx += t[u &lt;&lt; <span class="hljs-number">1</span>].rmx;<br>        <span class="hljs-keyword">if</span> (t[u].mx == mmx) t[u].pos = mid - t[u &lt;&lt; <span class="hljs-number">1</span>].rmx + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t[u].mx == t[u &lt;&lt; <span class="hljs-number">1</span>].mx) t[u].pos = t[u &lt;&lt; <span class="hljs-number">1</span>].pos;<br>        <span class="hljs-keyword">else</span> t[u].pos = t[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].pos;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            <span class="hljs-keyword">if</span> (id == s[l]) &#123;<br>                t[u].val = <span class="hljs-number">1</span>;<br>                t[u].mx = t[u].lmx = t[u].rmx = <span class="hljs-number">0</span>;<br>                t[u].pos = <span class="hljs-number">0</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                t[u].val = <span class="hljs-number">0</span>;<br>                t[u].mx = t[u].lmx = t[u].rmx = <span class="hljs-number">1</span>;<br>                t[u].pos = l;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid);<br>        <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-built_in">pushup</span>(u, l, r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> op)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r &amp;&amp; l == x) &#123;<br>            <span class="hljs-keyword">if</span> (op) &#123;<br>                t[u].val = <span class="hljs-number">0</span>;<br>                t[u].mx = t[u].lmx = t[u].rmx = <span class="hljs-number">1</span>;<br>                t[u].pos = l;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                t[u].val = <span class="hljs-number">1</span>;<br>                t[u].mx = t[u].lmx = t[u].rmx = <span class="hljs-number">0</span>;<br>                t[u].pos = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid, x, op);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, x, op);<br>        <span class="hljs-built_in">pushup</span>(u, l, r);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> t[u].val;<br>        <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>, mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (L &lt;= mid) ret += <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R);<br>        <span class="hljs-keyword">if</span> (R &gt; mid) ret += <span class="hljs-built_in">query</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R);<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>&#125; tree[<span class="hljs-number">26</span>];<br><br><span class="hljs-function">pii <span class="hljs-title">fnd</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> mxl = <span class="hljs-number">0</span>, mxr = <span class="hljs-number">-1</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, <span class="hljs-number">25</span>) &#123;<br>        <span class="hljs-type">int</span> mxi = tree[i].t[<span class="hljs-number">1</span>].mx, p = tree[i].t[<span class="hljs-number">1</span>].pos;<br>        <span class="hljs-keyword">if</span> (p == <span class="hljs-number">1</span> &amp;&amp; p + mxi - <span class="hljs-number">1</span> == n) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (mxi &gt; mxr - mxl + <span class="hljs-number">1</span>) &#123;<br>            mxl = p; mxr = p + mxi - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(mxl, mxr);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cnt &amp; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (mp[s[<span class="hljs-number">1</span>]] &gt; <span class="hljs-number">1</span> || mp[s[n]] &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> ix = <span class="hljs-number">0</span>, iy = <span class="hljs-number">0</span>, ans1, ans2;<br>                <span class="hljs-keyword">while</span> (ix + <span class="hljs-number">1</span> &lt;= n &amp;&amp; mp[s[ix + <span class="hljs-number">1</span>]] == <span class="hljs-number">1</span>) ix++;<br>                <span class="hljs-keyword">while</span> (n - iy &gt;= <span class="hljs-number">1</span> &amp;&amp; mp[s[n - iy]] == <span class="hljs-number">1</span>) iy++;<br>                <span class="hljs-keyword">if</span> (ix &amp; <span class="hljs-number">1</span>) ans1 = n - ix - <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">else</span> ans1 = n - ix - <span class="hljs-number">1</span>; <br>                <span class="hljs-keyword">if</span> (iy &amp; <span class="hljs-number">1</span>) ans2 = n - iy - <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">else</span> ans2 = n - iy - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(ans1, ans2);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        pii tt = <span class="hljs-built_in">fnd</span>();<br>        <span class="hljs-type">int</span> len = tt.second - tt.first + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (len &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> len;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> l = tt.first, r = tt.second;<br>            <span class="hljs-keyword">if</span> (tree[s[l] - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r) &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> len - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (tree[s[r] - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r) &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> len - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> cntl = <span class="hljs-number">0</span>, cntr = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (l + cntl &lt;= r &amp;&amp; tree[s[l + cntl] - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r) == <span class="hljs-number">1</span>) cntl++;<br>            <span class="hljs-keyword">while</span> (r - cntr &gt;= l &amp;&amp; tree[s[r - cntr] - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r) == <span class="hljs-number">1</span>) cntr++;<br>            <span class="hljs-keyword">if</span> (l - <span class="hljs-number">2</span> &gt;= cntr) <span class="hljs-keyword">return</span> len - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (n - r - <span class="hljs-number">1</span> &gt;= cntl) <span class="hljs-keyword">return</span> len - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> ans1 = n - (cntl + l);<br>            <span class="hljs-keyword">if</span> (ans1 % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) ans1 -= <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> ans2 = r - cntr - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (ans2 % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) ans2 -= <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(ans1, ans2);<br>        &#125; <br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; q &gt;&gt; ss;<br>    s = <span class="hljs-string">&#x27; &#x27;</span> + ss;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, <span class="hljs-number">25</span>) &#123;<br>        tree[i].id = i + <span class="hljs-string">&#x27;a&#x27;</span>;<br>        tree[i].<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        <span class="hljs-keyword">if</span> (mp[s[i]] == <span class="hljs-number">0</span>) cnt += <span class="hljs-number">1</span>;<br>        mp[s[i]] += <span class="hljs-number">1</span>;<br>    &#125;<br>    Ans = <span class="hljs-built_in">solve</span>();<br>    cout &lt;&lt; Ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">int</span> x; <span class="hljs-type">char</span> c; cin &gt;&gt; x &gt;&gt; c;<br>        <span class="hljs-keyword">if</span> (s[x] == c) &#123; cout &lt;&lt; Ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-keyword">continue</span>; &#125;<br>        tree[c - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, x, <span class="hljs-number">0</span>);<br>        tree[s[x] - <span class="hljs-string">&#x27;a&#x27;</span>].<span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, x, <span class="hljs-number">1</span>);<br>        mp[s[x]] -= <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (mp[s[x]] == <span class="hljs-number">0</span>) cnt -= <span class="hljs-number">1</span>;<br>        s[x] = c;<br>        mp[s[x]] += <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (mp[s[x]] == <span class="hljs-number">1</span>) cnt += <span class="hljs-number">1</span>;<br>        Ans = <span class="hljs-built_in">solve</span>();<br>        cout &lt;&lt; Ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>25暑训</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⌈25暑训⌋ 第1&amp;2场补题</title>
    <link href="/2025/07/16/%E6%9A%91%E8%AE%AD1&amp;2%20%E8%A1%A5%E9%A2%98/"/>
    <url>/2025/07/16/%E6%9A%91%E8%AE%AD1&amp;2%20%E8%A1%A5%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>我承认开训前确实摆了太久，第一场训练赛根本没有进入状态。那么就从今天开始抑制惰性，好好训练吧！</p><h1 id="L"><a href="#L" class="headerlink" title="L"></a>L</h1><p><strong>题目大意：</strong><br>给定 $n$ 个正整数 $a_i$ 和 $q$ 次询问。每次询问给定 $i$, $j$，修改：$a_i\leftarrow a_i + j$，（修改在后续询问中也生效）然后你需要统计此时有多少 $a_i$ 满足：大于 $a_i$ 的数的数目不小于 $\left \lfloor \frac n 2 \right \rfloor $。<br><strong>难度：</strong> ~2000<br><strong>知识点：</strong> 权值线段树 &#x2F; 平衡树</p><p>为了方便叙述，我们重新定义中位数为升序排序后的 $a_{\left \lceil \frac n 2 \right \rceil }$。（也就是说在 $n$ 为偶数时不取均值）</p><p>容易发现，小于中位数的元素一定符合统计要求，大于中位数的元素一定不符合统计要求。等于中位数的元素满足以下要求时符合：升序排序后， $a_{\left \lceil \frac n 2 \right \rceil } \ne a_{ \left \lceil \frac n 2 \right \rceil + 1}$ 。</p><p>因此我们只需寻找一种数据结构支持以下操作：单点修改、查询给定下标的元素、查询小于某数的元素个数。各种数据结构都可以，这里就写一个权值线段树吧。</p><p>先离线对所有可能出现的数进行离散化，作为线段树的值域。线段树维护值域上各数的出现次数，各操作如下。</p><p><strong>单点修改</strong> ：原数出现次数–，新数出现次数++；<br><strong>查询给定下标的元素</strong> ：线段树上二分即可；<br><strong>查询小于某数的元素个数</strong> ：其实就是做区间查询；</p><p>好像确实什么难度。但为什么赛时没切？有点无语。</p><h5 id="Code"><a href="#Code" class="headerlink" title="Code:"></a>Code:</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOR(i,j,k) for (int i = j; i &lt;= k; i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb(x) push_back(x)</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> T;<br><span class="hljs-type">int</span> n, Q;<br><br><span class="hljs-type">int</span> a[N], b[N], q[N][<span class="hljs-number">2</span>];<br><span class="hljs-type">int</span> t[N &lt;&lt; <span class="hljs-number">4</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>        t[u] = <span class="hljs-number">0</span>; <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid);<br>    <span class="hljs-built_in">build</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>    t[u] = t[u &lt;&lt; <span class="hljs-number">1</span>] + t[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> d)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>        t[u] += d; <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid, x, d);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">modify</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, x, d);<br>    t[u] = t[u &lt;&lt; <span class="hljs-number">1</span>] + t[u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qry</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> l;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (x &lt;= t[u &lt;&lt; <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid, x);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">qry</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, x - t[u &lt;&lt; <span class="hljs-number">1</span>]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (L &gt; R) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> t[u];<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>, mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (mid &gt;= L) ret += <span class="hljs-built_in">ask</span>(u &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R);<br>    <span class="hljs-keyword">if</span> (mid &lt; R) ret += <span class="hljs-built_in">ask</span>(u &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; Q;<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; arr;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; ump;<br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; id;<br><br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        cin &gt;&gt; a[i]; b[i] = a[i];<br>        <span class="hljs-keyword">if</span> (ump[a[i]]) <span class="hljs-keyword">continue</span>;<br>        ump[a[i]] = <span class="hljs-literal">true</span>;<br>        arr.<span class="hljs-built_in">pb</span>(a[i]);<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, Q) &#123;<br>        cin &gt;&gt; q[i][<span class="hljs-number">0</span>] &gt;&gt; q[i][<span class="hljs-number">1</span>];<br>        b[q[i][<span class="hljs-number">0</span>]] += q[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (ump[b[q[i][<span class="hljs-number">0</span>]]]) <span class="hljs-keyword">continue</span>;<br>        ump[b[q[i][<span class="hljs-number">0</span>]]] = <span class="hljs-literal">true</span>;<br>        arr.<span class="hljs-built_in">pb</span>(b[q[i][<span class="hljs-number">0</span>]]);<br>    &#125;<br>    <span class="hljs-type">int</span> m = arr.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-built_in">sort</span> (arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, m - <span class="hljs-number">1</span>) id[arr[i]] = i + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m);<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, id[a[i]], <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, Q) &#123;<br>        <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, id[a[q[i][<span class="hljs-number">0</span>]]], <span class="hljs-number">-1</span>);<br>        a[q[i][<span class="hljs-number">0</span>]] += q[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, id[a[q[i][<span class="hljs-number">0</span>]]], <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> k1 = <span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>), k2 = <span class="hljs-built_in">qry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (k1 == k2) ans = <span class="hljs-built_in">ask</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, <span class="hljs-number">1</span>, k1 - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span> ans = <span class="hljs-built_in">ask</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, m, <span class="hljs-number">1</span>, k1);<br>        cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><p><strong>题目大意：</strong><br>给定区间内 $n - 1$ 个点的位置，每次操作选择一个不同点将其左右分割成两个区间。假设操作后两个新子区间的长度为 $l_1, l_2$ ，则当次操作代价为 $\min \left { l_1, l_2 \right } \times \left \lceil \log_2 (l_1 + l _2) \right \rceil$，不平衡度为 $\left | l_1 - l_2 \right |$。要求 $n-1$ 次分割操作不平衡度单调不增，代价之和最小。<br><strong>难度：</strong> ~2200<br><strong>知识点：</strong> 区间DP，空间卡常</p><p>以为是小清新区间DP，但发现并非如此啊，原来是神人卡常题。</p><p>首先我们注意到子区间转移至父区间需要满足不平衡度的要求，所以我们设计的状态需要包含不平衡度的信息，方便转移。</p><p>此处我们设 $dp_{l, r, m}$ 表示区间 $[l,r]$ ，若第一步割 $m$​ ，最终完全分割至少需要付出的代价。那么我们可以做出以下转移：<br>$$<br>dp_{l, r, m}&#x3D;\min_i dp_{l,m,i} +\min_j dp_{m + 1, r, j}+w<br>$$<br>其中 $w$ 表示该次转移产生的代价，也就是 $\min \left { l_1, l_2 \right } \times \left \lceil \log_2 (l_1 + l _2) \right \rceil$ ，$l_1,l_2$ 可以通过预处理前缀和 $\mathcal O(1)$  求出。</p><p>同时 $i$ 和 $j$ 的取值有范围要求，必须在 $dp_{l,m,i}$ 和 $dp_{m+1,r,j}$ 的不平衡度小于等于父区间的范围内。此处若枚举 $i,j$ 取值，时间复杂度 $\mathcal O(n^4)$ ，无法通过本题。</p><p>考虑根据 $dp_{l,r,m}$ 的不平衡度对 $dp_{l,r}$ 序列进行排序，并做前缀最小值。由父状态得到不平衡度限制，便可在新的 $dp_{l,r}$ 上进行二分，以得到最优转移。时间复杂度 $\mathcal O(n^3\log n)$ ，可以通过此题。</p><p>但此题对空间的限制很严格。即使优化代码实现方法，只留两个 $420 \times 420 \times 420 $ 级别的 <code>long long</code> 数组依旧无法通过。必须再对空间常数做优化。</p><p>注意到 $dp_{i,j,k}$ 只在 $i \leq k &lt; j$ 时有意义，也就是说当前的 $dp$ 数组占据了大量的无效空间。</p><p>因此我们考虑对满足 $i\leq k &lt; j$ 的三元组 $(i, j, k)$ 按照字典序进行编号。这个编号可以以一个多项式的形式表示。通过演算可知，这样做可以将空间压缩至原来的六分之一。于是艰难通过本题。</p><h5 id="Code-1"><a href="#Code-1" class="headerlink" title="Code:"></a>Code:</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOR(i,j,k) for (int i = j; i &lt;= k; i++)</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">422</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">1e16</span>;<br><br><span class="hljs-type">int</span> T;<br><span class="hljs-type">int</span> n, cnt;<br><span class="hljs-type">int</span> a[N], sum[N], pre[N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sta</span> &#123;<br>    <span class="hljs-type">int</span> imb, mn;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> sta &amp; x) &amp; &#123;<br>        <span class="hljs-keyword">return</span> imb &lt; x.imb;<br>    &#125;<br>&#125; g[(N - <span class="hljs-number">1</span>) * N * (N + <span class="hljs-number">1</span>) / <span class="hljs-number">6</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> pre[i - <span class="hljs-number">1</span>] + (j - i) * (j - i + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - (j - <span class="hljs-number">1</span> - k);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Qry</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> D)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> L = l, R = r - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> ans = INF;<br>    <span class="hljs-keyword">while</span> (L &lt;= R) &#123;<br>        <span class="hljs-type">int</span> mid = (L + R) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (g[<span class="hljs-built_in">calc</span>(l, r, mid)].imb &lt;= D) &#123;<br>            L = mid + <span class="hljs-number">1</span>;<br>            ans = <span class="hljs-built_in">min</span>(ans, g[<span class="hljs-built_in">calc</span>(l, r, mid)].mn);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            R = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ans == INF) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) pre[i] = pre[i - <span class="hljs-number">1</span>] + (n - i + <span class="hljs-number">1</span>) * (n - i) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-built_in">FOR</span>(j, i + <span class="hljs-number">1</span>, n) <span class="hljs-built_in">FOR</span>(k, i, j - <span class="hljs-number">1</span>) g[++cnt].mn = INF;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; a[i], sum[i] = sum[i - <span class="hljs-number">1</span>] + a[i];<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>) &#123;<br>        g[<span class="hljs-built_in">calc</span>(i, i + <span class="hljs-number">1</span>, i)].mn = <span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">log2</span>(a[i] + a[i + <span class="hljs-number">1</span>])) * <span class="hljs-built_in">min</span>(a[i], a[i + <span class="hljs-number">1</span>]);;<br>        g[<span class="hljs-built_in">calc</span>(i, i + <span class="hljs-number">1</span>, i)].imb = <span class="hljs-built_in">abs</span>(a[i] - a[i + <span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>        cout &lt;&lt; g[<span class="hljs-built_in">calc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)].mn &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(len, <span class="hljs-number">3</span>, n) &#123;<br>        <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n - len + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> j = i + len - <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">FOR</span>(m, i, j - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-type">int</span> Lsz = sum[m] - sum[i - <span class="hljs-number">1</span>];<br>                <span class="hljs-type">int</span> Rsz = sum[j] - sum[m];<br>                <span class="hljs-type">int</span> D = <span class="hljs-built_in">abs</span>(Lsz - Rsz);<br>                <span class="hljs-type">int</span> ans1 = <span class="hljs-built_in">Qry</span>(i, m, D), ans2 = <span class="hljs-built_in">Qry</span>(m + <span class="hljs-number">1</span>, j, D);<br>                <span class="hljs-type">int</span> pos = <span class="hljs-built_in">calc</span>(i, j, m);<br>                <span class="hljs-keyword">if</span> (ans1 == <span class="hljs-number">-1</span> || ans2 == <span class="hljs-number">-1</span>) g[pos].mn = INF;<br>                <span class="hljs-keyword">else</span> g[pos].mn = ans1 + ans2 + <span class="hljs-built_in">ceil</span>(<span class="hljs-built_in">log2</span>(Lsz + Rsz)) * <span class="hljs-built_in">min</span>(Lsz, Rsz);<br>                g[pos].imb = D;<br>                <span class="hljs-keyword">if</span> (len == n) &#123;<br>                    <span class="hljs-keyword">if</span> (g[pos].mn == INF) cout &lt;&lt; <span class="hljs-string">&quot;-1 &quot;</span>; <br>                    <span class="hljs-keyword">else</span> cout &lt;&lt; g[pos].mn &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">int</span> bg = <span class="hljs-built_in">calc</span>(i, j, i), ed = <span class="hljs-built_in">calc</span>(i, j, j - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">sort</span>(g + bg, g + ed);<br>            <span class="hljs-built_in">FOR</span>(m, i + <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>) &#123;<br>                g[<span class="hljs-built_in">calc</span>(i, j, m)].mn = <span class="hljs-built_in">min</span>(g[<span class="hljs-built_in">calc</span>(i, j, m)].mn, g[<span class="hljs-built_in">calc</span>(i, j, m - <span class="hljs-number">1</span>)].mn);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--) <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>25暑训</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FM23利兹联崛起之路</title>
    <link href="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/"/>
    <url>/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>听说下半年 FM26 要出了，到时候我可能也就会弃坑这玩了很久的 FM23 了。正好下半年利兹联升超，我决定最后为白玫瑰开个长线的档纪念一下。</p><p>众所周知，FM23 中游戏是从 22 年夏窗开始的。那个夏天前的赛季，利兹联最终仅以三分的优势领先于降级区的伯恩利，免于重新落回英冠的命运。</p><p>这让许多人感到失望，毕竟一年前的 20-21 赛季，他们还以升班马的身份拿下了一个中游的名次。人们都在说，在英超站稳脚跟好像也没那么难。球迷们已经在幻想俱乐部在英超光明的未来。只是梦碎得太快。</p><p>后来的事情我们都知道了。22-23 赛季（也就是我存档的起点）末，利兹联位居 19，重新掉回英冠。上赛季堪堪保级的 17 名和这次的 19 名本身差得就并不多，在崇尚 “逆水行舟，不进则退” 的英超更是如此。</p><p>FM的世界线里利兹联的命运会是怎样呢？且看本文。</p><hr><h3 id="初始阵容"><a href="#初始阵容" class="headerlink" title="初始阵容"></a>初始阵容</h3><p>先给大伙看看这套阵容班底吧。整体CA不算高，绝大部分球员的CA在130-140左右，但在关键位置有许多不错的球员。</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(8).png"></p><p>主力中锋 <strong>巴姆弗德</strong> 把握机会能力不佳，CA139，得分不稳定。</p><p>边锋位置的候选主要是 <strong>哈里森</strong> 和 <strong>西尼斯特拉</strong>。后者是队内数据最漂亮的球员。</p><p>队内顶薪 <strong>罗德里戈</strong> 是前场多面手，曾经是球队的绝对主力，但随着年龄增长（31岁），伤病越来越频繁，状态起伏严重。在与前三位竞争首发时没有明显优势。</p><p>中锋位置还有一位20岁的年轻备选 <strong>格尔哈特</strong>，两年前从维冈竞技手中签下。这位球员非常玄学，CA仅仅120，各项关键数据也不够出彩，但是效率极高，替补登场时总能进球。夏窗时我差点将他外租，还好当时没有这么做。现在他的表现足以将巴姆弗德挤下首发。</p><p>中场位置的常规先发是 <strong>泰勒·亚当斯</strong> 和 <strong>罗卡</strong> 两人。前者主打扫荡型中前卫职责，是这支队伍当前的CA最高者之一（CA144），但除了禁区弧顶处的一脚远射之外，似乎没有多少亮眼表现。后者一般承担拖后组织核心职责，表现平庸。</p><p>除这两人之外，中场还有这几个定位轮换的球员，包括：<strong>克里奇</strong>，<strong>亚当·福肖</strong>， <strong>阿伦森</strong> 和 太子 <strong>阿奇·格雷</strong>。克里奇和福肖分别是亚当斯和罗卡的替补，除了前者工投与体力高到爆炸外，能力也比较平庸。重点介绍一下两位未来之星，也都是小帅哥。（如图）</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(106).png"></p><p>阿伦森PA155，既可以打中场，又可以打右边锋。承担前场组织核心职责时表现还行。练满后完全可以搭档格雷，取代上文几位工兵中场出任先发。现实中亚伦森曾短暂租借加盟柏林联，现在已回归利兹。不知道下赛季英超能不能看到他。</p><p>阿奇格雷是根正苗红的利兹联青训出品。本作中随潜-9，这个存档中PA随到了164。虽然隐藏属性不算顶级，但开档时年仅16岁，练满的难度很低。此时CA不到110的格雷已经被我转到了一线队，且我会在大部分压力不大的比赛中给他替补登场的机会。现实中他已经转会热刺，天天踢后场各种位置，可能就这么泯然众人了。但这个存档中我会让他成为利兹联的传奇。</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(9).png"></p><p>中卫的位置上目前的先发是 <strong>斯特卢吉克</strong> 和 <strong>科奇</strong> 二人，并不缺乏天赋，身高达到190，PA也都在150+。</p><p>斯特卢吉克现实中仍在利兹联效力，由于迟迟没有得到荷兰的征召，他已在寻求规划至印尼，日后定将成为国足大敌。</p><p>科奇我们更熟悉的译名应该为科赫，近年在法鹰表现不错，已经入选了德国国家队。一开始我都没有意识到这一点，在网上查了半天谁是科奇……说句题外话，我一直很困惑为什么翻译中会大量出现不合原文的“奇”字——哈利波特中的獾院时而译作赫奇帕奇，时而译作赫夫帕夫。FM里的格雷文贝尔齐现实中译作格拉芬贝赫……如果说两位足球运动员的不同译法源自 <code>ch</code> 在不同语言中不同的发音，那以 <code>ff</code> 结尾的赫夫帕夫为何又被大量译作赫奇帕奇呢？令人困惑。</p><p>实在是扯远了。接下来看后卫线上的其他选择。主要是 <strong>洛兰迪</strong> 和 <strong>库珀</strong> ，前者伤病多得吓人，年纪不大CA就已开始负增长。后者年纪大了，都只能作为轮换球员，难堪大用。</p><p>边后卫位置上，球场万金油 <strong>达拉斯</strong> 开档便遭遇严重伤病，休战八个月。队中仅有的边后卫德拉梅赫CA低下，因此我用夏窗仅剩的预算从瓦伦西亚购入了 <strong>科雷亚</strong> 出任主力左后卫，表现可圈可点，能送出大量关键传球。</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(10).png"></p><p>右边后卫主要的人选就是 <strong>克里斯滕森</strong>，各项能力值够用，也没有出现过大的伤病。除他之外只有一位老登 <strong>艾林</strong>，同样在病床一躺就是半年。夏窗时想及时清洗但显然找不到人接盘。因此克里斯滕森赛季中几乎场场首发打满全场，但这也是没有办法的事情。</p><p>门将位置是FM的毕业卡之一 <strong>梅斯里尔</strong>，PA高达161，屡献神扑，表现比现实中的梅利耶稳定若干个档次。有他在，单线作战肯定是足够应付了，因此我也没有物色一个潜力高的二门。</p><p>以上大概就是夏窗结束后我的阵容。初定目标在冬窗补强后尽量能够争六吧。</p><hr><h3 id="关于战术"><a href="#关于战术" class="headerlink" title="关于战术"></a><strong>关于战术</strong></h3><p>可以看到，我的阵中没有并没有一个强力的十号位，但有大量工兵中场。因此我的战术采用一个很激进的双八站位4-3-3阵型。</p><p>我期待的实战效果是这样：一侧边后卫多下底与肋部的内切型边锋进行配合，前场组织核心在阵地战阶段站在对方弧顶位置进行调度。八号位全能中场则适时前插进入禁区，与内锋和中锋一同抢点。与此同时后腰位置的球员沉回后卫线，与双中卫一同拦截对方的反击。</p><p>但实际上展现出的效果并不好。多次观看全场录像后我得出的结论是，问题出在边锋能力和全能中场的能力太差。</p><p>常常会出现这样的情形：边后卫下底回传弧顶，交由组织核心调度至另一侧。但另一侧边锋紧接着就是一脚飞机或者被封堵。全能中场前插得分效率同样不高。</p><p>所以我最近在物色一些低价格高质量的边锋跟全能中场。边锋位置的妖人非常多，比如艾斯派拿，再比如我前几个档玩过的居莱尔和谢尔德鲁普。其中前两个小妖其实是打十号的料，但从我的建队思路来看，签下他们大概率还是从边路踢起。</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(13).png"></p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(27).png"></p><p>至于全能中场，市场上确实很难找到好的选择。高CA的熟男往往价格溢出，有潜力的小妖又解不了燃眉之急。</p><p>不管怎样补强至少得是冬窗的事了，先用手上的牌把上半个赛季打好吧。</p><hr><h3 id="第一赛季"><a href="#第一赛季" class="headerlink" title="第一赛季"></a>第一赛季</h3><p>赛季前十场忘记截图了，从这场客场挑战曼城开始吧。众所周知英超客场非常难打，尤其这场打曼城，我本来都少输当赢了。没想到开场不久，太子格雷就助攻巴姆弗德首开纪录。</p><p>比赛快结束时，关键镜头给到准备罚任意球的德布劳内，我忽然就有不详的预感。果然德布劳内任意球直接破门，扳平了比分。这个游戏里任意球数值高的球员还是太bug了，之前玩的曼城档，劳内一个赛季能进十个任意球。</p><p>虽说没赢，但对手是平均CA比我们高几十的曼城，能够打平已经很惊喜了。</p><p>目前联赛十一场积21分，位列第四。联赛杯点球大战淘汰狼队晋级。形势一片向好。开赛至今阵容内多点开花，未尝一败。难道这就是所说的新教练蜜月期？</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(6).png"></p><p>严峻的考验很快就到来了。主场迎战蓝狐的比赛上，哈里森、巴姆弗德、罗德里戈相继伤退……本就不富裕的锋线一下子捉襟见肘起来。主力中锋巴姆弗德伤停一个月，这让我不得不把年轻的格尔哈特推上首发，这时候就要感谢自己夏窗没有把他外租了。另外阿伦森也被迫顶上锋线，不知道适应得如何。</p><p>客场打森林，本以为是手拿把掐的比赛，结果开局不久，林皇就在禁区前沿游龙轻松助攻队友破门。可能是队内大哥受伤，球队整体的士气明显低落。最终格尔哈特破门难救主，利兹联十二场不败金身告破。</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(25).png"></p><p>接下来的几场联赛，格尔哈特连场爆发。面对曼联，打进全场唯一进球，还是一脚精彩的天外飞仙。面对热刺，两度打入让球队取得领先的关键进球。面对布伦特福德，再次打入制胜球，把个人赛季总进球数提升到五粒。</p><p>我完全没有想到一位替补前锋能迸发出如此惊人的能量，或许格尔哈特将完全把握住这主力伤停的机会，彻底上位。</p><p>联赛杯方面对阵德比郡，阿奇格雷助攻克里斯滕森打入全场唯一进球。</p><p>补强迫在眉睫。还没到冬窗，我就和北西兰开启了谢尔德鲁普的转会谈判。个人条款很容易达成一致，毕竟这么优秀的球员只要求4.25万的周薪。强制的解约金条款一度让我有些犹豫，但考虑到续约时能修改条款，最终我通过了这份合同。</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(36).png"></p><p>谢尔德鲁普基本是FM23性价比最高的球员了，只要725w欧，几乎是必买的水平。开档就有140的CA，技术和精神一片高亮，隐藏也不错，只要着重练身体即可。由于年龄只有18岁，练满应该是轻轻松松。签下他，球队锋线实力将获得大幅加强。</p><p>现实中，在本菲卡练级的小谢仍未登陆传统豪门，但应该也快了。前阵子刷到过马竞有意他的传闻。</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(12).png"></p><p>回归联赛杯赛场，被我们压制了一整场的热刺居然在最后阶段由孙哥连入两球，将我们淘汰出局了。哎不过这也是好事，少了些多线作战的压力。</p><p>这个存档里三喵世界杯决赛1-0击败荷兰，居然真的让足球回家了，泪目。赛事MVP给到了格拉利什……想到现实中摇子的处境，不禁有些唏嘘。</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(42).png"></p><p>接下来的两场1-0富勒姆，1-3利物浦的过程只能说是乏善可陈。这游戏里的利物浦是真的打不过，反击起来拦都拦不住。</p><p>很不错的是，冬窗开启后，谢尔德鲁普迅速到队。随即在首秀中大放异彩，为格尔哈特送上两次助攻，助球队有惊无险地击败圣徒。</p><p>十九轮战罢，我们仍排在联赛第四，领先身后的热刺5分，这完全超乎我的预期。（另外，这一轮曼城和利物浦双双打出7-0，活久见。</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(54).png"></p><p>让我没想到的是拜仁居然为我们的后防核心斯特卢吉克进行三千万欧的报价。球员也迅速因为我不放人开始闹情绪，我只好选择放行。只是不知道拿这三千万能不能买到合适的中卫。</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(58).png"></p><p>接下来球队曾在击败狼队后短暂上升至积分榜第三的位置，但紧接着连负于曼城和伯恩茅斯，又掉了回去。</p><p>足总杯对阵布拉德福德的比赛，格雷16次激进传球，8次关键传球，居然没有转化出一个进球，尝试助攻王了属于是。闷平过后，还要重赛，真是麻烦。</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(75).png"></p><p>冬窗的最后阶段，我用卖斯特卢吉克的钱压哨签下了前腰艾斯派拿（1100w）和中卫埃拉科维奇（925w）</p><p>前者上文已经贴出面板，是FM系列成名已久的小妖，本档居然随到了逆天的177PA，这我不得不拿下。后者则是为填补斯特卢吉克离去的空缺，随便挑选的一个潜力尚可的中卫，尚且不知能不能拿出上佳的表现。</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(80).png"> </p><p>总体上这个转会窗甚至赚钱了。我们来看看其他球队的动向——利物浦7100w签下米林，曼城6000w签下麦迪逊。狼队6000w将内维斯卖给皇马后转手5100w砸下乌加特，都是FM里很经典的操作了。</p><p>冬窗之后的第一场比赛又是一场大胜，6-2血洗圣徒。格尔哈特帽子戏法，谢尔德鲁普和埃拉科维奇收获首球，酣畅淋漓。这场胜利让周最佳阵容中直接出现了四位利兹联球员……说句不好听的，利兹联真王朝了^w^</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(90).png"></p><p>对阵布拉德福德的重赛上，中场休息之前我方获得点球。考虑了一会我决定让格雷罚，毕竟他早晚是要接过利兹联核心的大旗的，不如趁早让他体验一下点球主罚权。最终格雷不负众望，稳稳罚进。我方也在下半场连入五球，7-1狂胜对手。</p><p>西尼斯特拉两球一助，格雷一球两助，格尔哈特双响。其他中前场球员也人人都收获进球或助攻，皆大欢喜。</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(96).png"></p><p>谔谔，还沉浸在狂胜的喜悦中，又被利物浦教育了。法老失点+帽子戏法球+一条龙助攻，一个人把比赛的话题占完了。只害怕这场比赛把我们高昂的士气打没了。</p><p>隔壁曼联热刺再次打出4-4的逆天比分，C罗圆神双响，伟大无需多言。没让热刺追上来。</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(98).png"></p><p>接下来是一段魔鬼赛程，球队连战阿森纳切尔西纽卡。我都选择了跳过比赛过程直接看结果……没想到打枪手这种关键战沉寂许久的巴姆弗德上演大四喜，4-2完胜。随后2-2切尔西，都是能接受的结果。</p><p>对阵纽卡一战，对方全场少打一人，再次3-0完胜。</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(99).png"></p><p>国际比赛日中，谢尔德鲁普在挪威7-2战胜安道尔的比赛中收获4球1助。此时世界五十大神童名单发布，名单前列自然全是佩德里、穆夏拉、维尔茨这种成名已久的少年巨星。但咱们的太子、小谢、艾斯派拿也赫然在列。</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(124).png"></p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(125).png"></p><p>怎么到这个阶段了还有人说利兹联目标是保级…也不看看积分榜阿森纳和利兹联谁在上面…</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(130).png"></p><p>没想到的是接下来一段看似难度不大的赛程让球队一胜难求。连负维拉、利物浦、蜜蜂。随后的四个客场全部打平，仅在主场战胜降级区的森林，险些惨遭七轮不胜。这也让球队的排名从先前的稳坐前三一路跌出了欧冠区，因净胜球劣于曼联位列第五，同时身后还有少赛一轮仅落后两分的纽卡。</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(137).png"></p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(144).png"></p><p>第35轮，双红会率先开打。曼联 0-2 负于利物浦，不禁让我窃喜。没想到自己的球队紧接着1-3不敌埃弗顿…这波是曼彻斯特完全败于默西塞德了。于是近五轮利兹联怒丢八分，曼联更是喜提三连败，二者即将在第36轮的玫瑰德比中一决生死！</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(147).png"></p><p>然后出乎预料的，德比战一败涂地，1-4输球。几乎是亲手将曼联送上欧冠席位。</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(152).png"></p><p>英足总是懂得排赛程的，球队第37轮将在主场迎战另一位直接竞争对手纽卡斯尔联。本来我是不太抱有希望的，没想到最终居然拿下了。随后的补赛中，纽卡斯尔再以0-5惨败于曼城。至此纽卡和我们的分差已经彻底被拉开了。最后一轮我们既不可能冲到前四，也不可能掉到第六。基本可以提前宣告赛季以第五名结束了。欧战我来啦！（最后一轮球队输给了铁锤帮，不过已经无所谓了）</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(154).png"></p><p>一起来看看这赛季的球员的成绩单吧。巴姆弗德和格尔哈特两位竞争上岗的中锋共享了队内金靴。主力边锋西尼斯特拉则是交出了9球15助的答卷。冬窗刚刚到队的谢尔德鲁普效率同样不错。阿奇格雷在后腰位置上能送出六次助攻也是超出我的预期的，希望他能进一步成长。</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(161).png"></p><p>看得出来球队董事对我很满意了，赛季一结束就开始跟我商讨续约的事宜。哦吼吼那当然是欣然同意了，毕竟我是立志成为利兹联教父的男人。</p><p><img src="/2025/06/29/FM23%E5%88%A9%E5%85%B9%E8%81%94%E5%B4%9B%E8%B5%B7%E4%B9%8B%E8%B7%AF/(171).png"></p><p>球队给了8000w的转会预算。想在下赛季欧战中有所表现，必须得在转会市场上运作一番。</p>]]></content>
    
    
    <categories>
      
      <category>游戏记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⌈蓝桥杯⌋ 2025省赛A组游记&amp;题解</title>
    <link href="/2025/04/28/%E8%93%9D%E6%A1%A5%E6%9D%AF2025%E7%9C%81%E8%B5%9BA%E7%BB%84%E6%B8%B8%E8%AE%B0&amp;%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/04/28/%E8%93%9D%E6%A1%A5%E6%9D%AF2025%E7%9C%81%E8%B5%9BA%E7%BB%84%E6%B8%B8%E8%AE%B0&amp;%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>说起来这届蓝桥杯参赛过程还挺波折的。原定的时间恰好碰到北京大风（一直呆在室内，没有体验一下大风有多大）推迟后的时间又和你航的数分期中撞了……</p><p>一个周末内前后脚比赛和考试，怎么想都很痛苦吧。此外这周内还塞满了许多琐事，导致根本没有大块的空闲时间进行复习。直到周五晚上十点多排练结束回到寝室才想起来第二天就要比赛了，把一些基础的数据结构和算法过了一遍，心里稍微有了点底。</p><p>众所周知，备用卷总是容易出现难度或区分度方面的问题。这届也是如此，总体上难度偏低，区分度也不足。</p><p>不同于2024年A组真题E&#x2F;F&#x2F;G&#x2F;H有层次的难度设计与全面的知识面考察，这套题在G题之前几乎没有给到任何强度。而G题又是一个显而易见的线段树模板题，于是区分度等于是全部由H题的差分约束提供了（很不幸我被区分了）</p><p>在此写一篇个人向题解，赛时心路历程会穿插其中。</p><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p>**题目大意：**大盒尺寸 $200\times 250\times 240$，小盒尺寸 $30\times 40\times 50$，问大盒里能放几个小盒。</p><p>**标签：**小学数学</p><p>我认为将小学二年级数学题放在大学生竞赛里是不妥的。所以我认真思考了很久哪里有坑。</p><p>但事实上这就是一道小学二年级数学题，无语了家人们。</p><p>注意到有 $30|240$，$40|200$，$50|250$ ，所以答案就是大体积除以小体积。</p><p>哎哎，出题人的苦心。</p><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p>**题目大意：**求符合要求的正整数 $n$ 的数量：$n+20255202$ 和 $n+10244201$ 都是完全平方数。</p><p>**标签：**枚举&#x2F;初中数学</p><p>赛时我先考虑了直接枚举 $n$。分别设 $a^2&#x3D;n+20255202$，$b^2&#x3D;n+10244201$。由于 $a^2&gt;b^2$，因此也有 $a^2\geq (b+1)^2$ ，稍加变形可得：$b\leq\frac{a^2-b^2-1}{2}$ ，其中 $a^2-b^2$ 是定值 $10011001$ 。那么 $b$ 的枚举范围就不超过 $5005500$ ，在计算机的承受范围之内。枚举时判断 $b^2+10011001$ 是不是完全平方数即可。</p><p>不过我最终选择的并非此解法。注意到 $(a+b)(a-b)&#x3D;10011001$ ，可以考虑对 $10011001$ 进行因数分解。由于这是个奇数，所以因数一定同为奇数，解出来的 $a$ 和 $b$ 一定是整数。去掉那些 $a^2\leq20255202$ 的情形后，$10011001$ 剩下的因数对的数量便是最终答案。</p><p>比较幽默的是，我枚举因数的时候是从 $2$ 开始的，因此最终答案少了一种，痛失五分。</p><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>**题目大意：**用循环的字符串填充矩阵的每一行。每一行的字符串是 <code>LANQIAO</code>  循环左移对应次数后形成的串。求矩阵上 <code>A</code> 的个数。 </p><p>**标签：**模拟</p><p>既然数据范围这么小的话，先把矩阵填满，再取数 <code>A</code> 的数量就行了。没什么好讲的。</p><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p>**题目大意：**给定AB串，重复执行操作，每次删去一个AB子列直至不能操作。问串最终长度可能的最大值。</p><p>**标签：**贪心，双指针</p><p>显然串最终形态一定形如 <code>BB...BBAAA...A</code>，否则就还能继续操作。我们应尽量删去所有靠左的A，所有靠右的B。</p><p>那么贪心地去做，用一个双指针维护这个过程。每次删去串中第一个 A 和最后一个 B 。直到双指针相遇。</p><p>贪心的正确性是显然的。因为靠左的 B 与靠右的 B 相比，不被删去从而留在最终串中对答案做出贡献的机会更大。</p><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p>**题目大意：**给定一棵树，每次出发走至多 $k$ 步，步长为 $1$ 或 $2$ ，然后获得路径终点的权值。你可以从 $1$ 号节点出发无数次。问最终获得的权值。</p><p>**标签：**树的遍历</p><p>注意到 $2k$ 以内的所有数字都可以写成不超过 $k$ 个 $1$ 或 $2$ 的和，我们求出所有深度不大于 $2k$ 节点的权值和即可。（初读题的时候还以为只能出发一次，以为是个树形DP类似物，但实际上……）</p><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p>**题目大意：**给定 01 串，问有多少对不重叠的子串互为反串（每个对应位置均相反）</p><p>**标签：**计数</p><p>不太记得思路从何而来了，这里直接给出我的做法吧：</p><p>记所给 01 串 $s$ 的长度为 $n$ 。</p><p>枚举两串首间的距离 $j$ ，记 $t_i&#x3D;s_i+s_{i+j}$ $(i+j\leq n)$ ，那么 $t_i&#x3D;1$ 说明： $s_i$ 与 $s_{i+j}$ 相反，$s_i$ 可成为前串的一部分。</p><p>如果 $t_{L…R}$ 都等于 $1$ ，那么我们从这些能成为前串一部分的字符中任取一段 $s_{l…r}\left(L\leq l \leq r\leq R\right)$ ，都会有 $s_i&#x3D;1-s_{i+j}\left(l\leq i\leq r\right)$ 恒成立。  </p><p>也就是说：如果 $t_{L…R}$ 与 $t_{L+j…R+j}$ 没有重叠部分 $(R&lt;L+j)$ ，这一段对答案的贡献就是段内的子串数。对于段内每个字符 $s_i$，以它开头的子串数就是 $R-i+1$，整段的贡献为 $\sum_{i&#x3D;1}^{R-L+1}i.$</p><p>那如果有重叠部分怎么办呢？其实也不难想。不论起点的位置，长度大于 $j$ 的子串一定和后串重叠，不大于 $j$ 的一定合法。所以我们只需对上面的计算方式稍作调整，改为 $\sum_{i&#x3D;1}^{R-L+1}\min(i,j).$ 可以和上式合并。</p><p>计算所有 $j$ 下贡献的和即可。</p><p>时间复杂度 $O(n^2)$，可以通过此题。</p><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p>**题目大意：**维护一个支持入栈、出栈、以及查询栈顶前若干数乘积操作的栈。</p><p>**标签：**线段树</p><p>单点修改，区间乘积查询，线段树的暗示已经给得很明显了。</p><p>考虑到栈内的数不超过 $Q$ 个，线段树的容量开到 $4e5$ 级别已经足够。</p><p>入栈操作就是把栈当前容量加一处的数修改为目标数；出栈操作只需让记录栈当前容量的变量自减；查询操作只需调用线段树区间乘积查询函数即可。</p><p>为了让超过 $2^{32}$ 的数输出为 <code>OVERFLOW</code>，我们可以修改区间合并的函数。对每个节点以 $-1$ 值记录乘积超出 $2^{32}$ 的情况。区间合并时分以下情况（按从上往下的优先级判断）：</p><ul><li>左右子区间节点值有 $0$，则父区间节点值为 $0$。</li><li>左右子区间节点值有 $-1$ ，则父区间节点值为 $-1$。</li><li>左右子区间节点值乘积大于等于 $2^{32}$ ，则父区间节点值为 $-1$。</li><li>左右子区间节点值乘积小于 $2^{32}$ ，则父区间节点值为左右子区间节点值乘积。</li></ul><p>剩下就是线段树的常规写法了。算是一道很好调的DS题了。</p><h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><p> **题目大意：**给定序列 $a$ 以及若干约束 $(l,r,p,q)$，求解序列内最大最小差值的可能最小值。约束的意义是：<br>$$<br>\min_{l\leq x\leq r}a_x - \max_{p\leq y\leq q}a_y\geq ans<br>$$<br>**标签：**差分约束</p>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⌈蓝桥杯⌋ 2024省赛A组题解</title>
    <link href="/2025/04/08/%E8%93%9D%E6%A1%A5%E6%9D%AF2024%E7%9C%81%E8%B5%9BA%E7%BB%84%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/04/08/%E8%93%9D%E6%A1%A5%E6%9D%AF2024%E7%9C%81%E8%B5%9BA%E7%BB%84%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>做下来的体感是，涉及的知识点比较基础，但需要写的细节并不少。难度略高于 CSP-J，低于 NOIP&#x2F;CSP-S。</p><p>我给出的难度排序大致是：A&lt;C&lt;B&#x3D;D&lt;G&lt;E&lt;F&lt;H，比较令人恶心的是E和F会爆 long long，考场上我肯定无情挂分。</p><p>H题初见没有明确的思路，写的玄学复杂度做法只有 20pts。不是一道好做的题。</p><p>只剩一个礼拜了，很难针对蓝桥杯的风格做专项复习了，稍微复习复习图论&#x2F;数据结构的板子吧，再切几道推柿子题找找感觉，剩下的听天由命辽。</p><h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p><strong>标签：</strong> 枚举</p><p>枚举区间内所有日期，统计笔画数大于 $50$ 的天数即可。</p><p>Code: 略。</p><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p><strong>标签：</strong> DFS</p><p>笔者一开始考虑的错误做法是：枚举 $13$ 个白子的位置，再判断是否为平局。复杂度是阶乘级别，难以在短时间内得到结果。</p><p>于是转变思路，考虑到平局要求棋盘被填满，那么最终状态一共只有 $2^{25} &#x3D; 33,554,432$ 种，时间可以接受。 直接枚举并判断每种情形是否符合平局标准（白子数目为 $13$，且不存在横、竖、斜连成一线）</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">26</span>) &#123;<br>        <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>) &#123;<br>            <span class="hljs-keyword">if</span> (sumx[i] == <span class="hljs-number">0</span> || sumx[i] == <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span> (sumy[i] == <span class="hljs-number">0</span> || sumy[i] == <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (sec == <span class="hljs-number">0</span> || sec == <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (fir == <span class="hljs-number">0</span> || fir == <span class="hljs-number">5</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (tot != <span class="hljs-number">13</span>) <span class="hljs-keyword">return</span>;<br>        cnt++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125; <br>    <span class="hljs-type">int</span> i = (k - <span class="hljs-number">1</span>) / <span class="hljs-number">5</span> + <span class="hljs-number">1</span>, j;<br>    <span class="hljs-keyword">if</span> (k % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>) j = <span class="hljs-number">5</span>; <span class="hljs-keyword">else</span> j = k % <span class="hljs-number">5</span>;<br>    sumx[i] += <span class="hljs-number">1</span>; <span class="hljs-comment">// sumx[i] 为第 i 行中白子的个数</span><br>    sumy[j] += <span class="hljs-number">1</span>; <span class="hljs-comment">// sumy[j] 为第 j 列中白子的个数</span><br>    <span class="hljs-keyword">if</span> (i == j) fir += <span class="hljs-number">1</span>; <span class="hljs-comment">// fir 为主对角线上白子个数</span><br>    <span class="hljs-keyword">if</span> (i + j == <span class="hljs-number">6</span>) sec += <span class="hljs-number">1</span>; <span class="hljs-comment">// sec 为副对角线上白子个数</span><br>    tot += <span class="hljs-number">1</span>; <span class="hljs-comment">// tot 为白子总个数</span><br>    <span class="hljs-built_in">dfs</span>(k + <span class="hljs-number">1</span>);<br>    tot -= <span class="hljs-number">1</span>;<br>    sumx[i] -= <span class="hljs-number">1</span>;<br>    sumy[j] -= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (i == j) fir -= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span> (i + j == <span class="hljs-number">6</span>) sec -= <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">dfs</span>(k + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p><strong>标签：</strong> 前缀和，贪心</p><p>当训练进行到一定程度时，训练未完成的士兵一次训练所需的金币数可能会变得小于 $S$ 。在这个时刻之前，选择组团训练，之后则仅对未完成的士兵训练。下面我们需要找到这个时刻。</p><p>根据需要的训练次数，对士兵进行升序排序。对其做后缀和，判断何时后缀和首次小于 $S$。然后根据上述的策略模拟即可。另外注意对 $S$ 小于最后一位的情况进行判断。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">person</span> &#123;<br>    <span class="hljs-type">int</span> p, c;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> person &amp;x) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> c &lt; x.c;<br>    &#125;<br>&#125; y[N];<br><br><span class="hljs-type">int</span> sum[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>(); m = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) cin &gt;&gt; y[i].p &gt;&gt; y[i].c;<br>    <span class="hljs-built_in">sort</span>(y + <span class="hljs-number">1</span>, y + n + <span class="hljs-number">1</span>);<br>    sum[n] = y[n].p;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        sum[i] = sum[i + <span class="hljs-number">1</span>] + y[i].p;<br>    &#125;<br>    <span class="hljs-type">int</span> pos = n + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (m &gt; sum[i]) &#123;<br>            pos = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (pos == n + <span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; y[n].c * m &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = y[pos - <span class="hljs-number">1</span>].c * m;<br>    <span class="hljs-built_in">FOR</span>(i, pos, n) &#123;<br>        ans += (y[i].c - y[i - <span class="hljs-number">1</span>].c) * sum[i];<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p><strong>标签：</strong> DFS</p><p>在第一棵树上进行搜索，再设置一个指向第二棵树的指针。搜索过程中，先判断第二棵树上下一步能不能到达同样权值的点（使用 $map$ 进行预处理），不能则跳过，能则继续搜索，并在搜索完成后回溯指针的位置。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m, k, pos, ans;<br><br><span class="hljs-type">int</span> a[N], b[N], dep[N];<br><br>vector&lt;<span class="hljs-type">int</span>&gt; e1[N], e2[N];<br><br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    dep[u] = dep[fa] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : e2[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;<br>        mp[u][b[v]] = v;<br>        <span class="hljs-built_in">pre</span>(v, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : e1[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span> (mp[pos][a[v]]) &#123;<br>            <span class="hljs-type">int</span> tmp = pos;<br>            pos = mp[pos][a[v]];<br>            <span class="hljs-built_in">dfs</span>(v, u);<br>            pos = tmp;<br>        &#125;<br>    &#125;<br>    ans = <span class="hljs-built_in">max</span>(ans, dep[u]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>(); m = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) a[i] = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, m) b[i] = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-built_in">read</span>(), v = <span class="hljs-built_in">read</span>();<br>        e1[u].<span class="hljs-built_in">push_back</span>(v);<br>        e1[v].<span class="hljs-built_in">push_back</span>(u);<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, m - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-built_in">read</span>(), v = <span class="hljs-built_in">read</span>();<br>        e2[u].<span class="hljs-built_in">push_back</span>(v);<br>        e2[v].<span class="hljs-built_in">push_back</span>(u);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a[<span class="hljs-number">1</span>] != b[<span class="hljs-number">1</span>]) &#123;<br>        cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    pos = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">pre</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><h1 id="E"><a href="#E" class="headerlink" title="E"></a>E</h1><p><strong>标签：</strong> 二分</p><p>显然选出的最小方差随 $x$ 的增大单调不增，考虑二分答案，将最优化问题转化为判定性问题。</p><p>对前 $x$ 名同学的成绩进行排序，可以证明方差最小时选出的 $k$ 名同学一定是连续的。</p><p>将方差的式子转化为在转移中便于维护的形式：<br>$$<br>{\sigma^2}&#x3D;\frac{1}{k}\sum_{i&#x3D;1}^{k}{v_i}^2 - \frac{1}{k^2}(\sum_{i&#x3D;1}^{k}v_i)^2<br>$$<br>转移时执行类似滑动窗口的操作修改 $\sum_{i&#x3D;1}^{k}v_i^2$ 和 $\sum_{i &#x3D; 1}^{k} v_i$ 的值，找出方差值的最小值，判断是否小于给定的 $T$ 即可。</p><p>但此题似乎对浮点数的精度要求偏高，因此令上式两端同乘 $k^2$ 转化为整数进行操作规避精度问题。注意到这样做过程中可能超出 <strong>long long 的范围</strong>，还需开 <strong>unsigned long long</strong>。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; vc;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, x) vc.<span class="hljs-built_in">push_back</span>(a[i]);<br>    <span class="hljs-built_in">sort</span>(vc.<span class="hljs-built_in">begin</span>(), vc.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-type">int</span> sumsq = <span class="hljs-number">0</span>, sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, k) &#123;<br>        sumsq += vc[i - <span class="hljs-number">1</span>] * vc[i - <span class="hljs-number">1</span>];<br>        sum += vc[i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-type">int</span> mn = sumsq * k - sum * sum;<br>    <span class="hljs-type">int</span> pos = k;<br>    <span class="hljs-built_in">FOR</span>(i, k + <span class="hljs-number">1</span>, x) &#123;<br>        sumsq += vc[i - <span class="hljs-number">1</span>] * vc[i - <span class="hljs-number">1</span>];<br>        sumsq -= vc[i - <span class="hljs-number">1</span> - k] * vc[i - <span class="hljs-number">1</span> - k];<br>        sum += vc[i - <span class="hljs-number">1</span>];<br>        sum -= vc[i - <span class="hljs-number">1</span> - k];<br>        <span class="hljs-type">int</span> newans = sumsq * k - sum * sum;<br>        <span class="hljs-keyword">if</span> (newans &lt; mn) pos = i;<br>        mn = <span class="hljs-built_in">min</span>(mn, newans);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mn &lt; T * k * k) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>(); k = <span class="hljs-built_in">read</span>(); T = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">FOR</span>(i,<span class="hljs-number">1</span>,n) a[i] = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-type">int</span> L = k, R = n;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">check</span>(R)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;-1\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (L &lt; R) &#123;<br>        <span class="hljs-type">int</span> mid = (L + R) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) R = mid;<br>        <span class="hljs-keyword">else</span> L = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    cout &lt;&lt; L &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="F"><a href="#F" class="headerlink" title="F"></a>F</h1><p><strong>标签：</strong> 容斥原理</p><p>先考虑前置问题：满足 $a_j|a_i$ 的有序二元组 $(i,j)$ 有多少个。</p><p>由于 $a_i$ 的数据范围并不大，我们先预处理出每个数的出现次数，然后用根号筛得到 $a_i$ 的全部因数，对他们的出现次数求和，就可以得到对于当前的 $i$ ，有多少满足条件的 $(i,j)$ 。注意，由于 $i\ne j$ ，应将次数减一。</p><p>下面我们利用容斥原理，计算有序四元组 $(i,j,k,l)$ 的数量，其中 $i,j,k,l$ 互异。</p><p>为了方便说明，下设：</p><p>满足条件且 $i\ne j$ 的有序二元组数量是 $N_0$ ；</p><p>满足条件但不限制互异性的有序四元组数量是 $N_1$ ；</p><p>满足条件但 $(i&#x3D;j) \wedge(k\ne l)$ 的有序四元组数量是 $N_2$；</p><p>满足条件但 $(i\ne j) \wedge(k&#x3D;l)$ 的有序四元组数量是 $N_3$；</p><p>满足条件但 $(i&#x3D;j) \wedge(k&#x3D; l)$ 的有序四元组数量是 $N_4$；</p><p>满足条件但 $(i&#x3D;l)\wedge(j\ne k)$ 的有序四元组数量是 $N_5$；</p><p>满足条件但 $(i\ne l)\wedge (j&#x3D;k)$ 的有序四元组数量是 $N_6$；</p><p>满足条件但 $(i&#x3D;l)\wedge(j&#x3D;k)$ 的有序四元组数量是 $N_7$；</p><p>满足条件且满足互异性的有序四元组数量（也就是最终答案）是 $N$ 。</p><p>那么根据容斥原理，有： $N&#x3D;N_1-N_2-N_3+N_4-N_5-N_6+N_7$ 。</p><p>由于未限制互异性，根据乘法原理，显然 $N_1 &#x3D; N_0^2$ 。另外可以注意到 $N_4&#x3D;N_0$。</p><p>下面考虑怎样求 $N_2$ 与 $N_3$ ：</p><p>先说 $N_2$：假设除 $a_i$ 自身之外，数列中 $a_i$ 倍数的个数为 $x_i$。对于有序四元组而言，只需 $a_k$ 和 $a_l$ 互异且都为 $a_i$ 倍数即可。易得 $N_2&#x3D;\sum x_i(x_i-1)$ 。</p><p>$N_3$ 的求解方式同理：假设除 $a_i$ 自身之外，数列中 $a_i$ 因数的个数为 $y_i$，那么有 $N_3&#x3D;\sum y_i(y_i-1)$。</p><p>$x_1$ 和 $x_2$ 都可以通过预处理获得。</p><p>下面求解 $N_5$ 和 $N_6$：</p><p>根据对称性，显然两个值是相等的。以 $(i&#x3D;l)\wedge (j \ne k)$ 的情形为例，则 $a_j|a_i$ 且 $a_i | a_k$ ，我们枚举这个作为 $a_i$ 的数。沿用上文中的 $x_i$ 与 $y_i$ ，可以导出 $N_5&#x3D;N_6&#x3D;\sum x_i y_i$ 。</p><p>至于 $N_7$ 有且仅有一种情形：两个相等的数互为对方的倍数和因数。枚举 $a_i$ 的取值，假设数列中共有 $z_i$ 个取该值的数，那么有 $N_7&#x3D;\sum z_i(z_i - 1)$ 。</p><p>需要注意的是，在极端情况下（如数列中全是 $1$ ）答案可能会超过 <strong>unsigned long long</strong> 的范围，因此需要用 <strong>__int128</strong>。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n0, n1, n2, n3, n4, n5, n6, n7;<br><span class="hljs-type">int</span> cnt[N], times[N], res[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        a[i] = <span class="hljs-built_in">read</span>();<br>        cnt[a[i]]++;<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j * j &lt;= a[i]; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j * j == a[i]) &#123;<br>                res[i] += cnt[j];<br>                times[j] += <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (a[i] % j == <span class="hljs-number">0</span>) &#123;<br>                    res[i] += cnt[j];<br>                    res[i] += cnt[a[i] / j];<br>                    times[j] += <span class="hljs-number">1</span>;<br>                    times[a[i] / j] += <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        n0 += (res[i] - <span class="hljs-number">1</span>);<br>    &#125;<br>    n1 = n0 * n0;<br>    n4 = n0;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        n2 += (times[a[i]] - <span class="hljs-number">1</span>) * (times[a[i]] - <span class="hljs-number">1</span>);<br>        n3 += (res[i] - <span class="hljs-number">1</span>) * (res[i] - <span class="hljs-number">1</span>);<br>        n5 += (times[a[i]] - <span class="hljs-number">1</span>) * (res[i] - <span class="hljs-number">1</span>);<br>        n6 += (times[a[i]] - <span class="hljs-number">1</span>) * (res[i] - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, N - <span class="hljs-number">5</span>) n7 += cnt[i] * (cnt[i] - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">print</span>(n1 - n2 - n3 + n4 - n5 - n6 + n7);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="G"><a href="#G" class="headerlink" title="G"></a>G</h1><p><strong>标签：</strong> LCA，树上差分</p><p>注意到零食的种类非常少，考虑对每种零食分别做树上前缀和。再以起点与终点的 $lca$ 为分界点，将所求路径拆成两条链，借助前缀和求出路径上每种零食的数量，从而求得路径上零食的种类数。</p><p>Code：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> n, m, k, q;<br><br><span class="hljs-type">int</span> a[N], b[N], c[N], dep[N];<br><br><span class="hljs-type">int</span> sum[N][<span class="hljs-number">30</span>], f[N][<span class="hljs-number">30</span>];<br><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    dep[u] = dep[fa] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : e[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>) sum[v][i] = sum[u][i];<br>        sum[v][c[v]]++;<br>        <span class="hljs-built_in">dfs1</span>(v, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    f[u][<span class="hljs-number">0</span>] = fa;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; i) &lt;= dep[u]; i++) &#123;<br>        f[u][i] = f[f[u][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : e[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs2</span>(v, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dep[u] &lt; dep[v]) <span class="hljs-built_in">swap</span>(u, v);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">20</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-keyword">if</span> (dep[u] - (<span class="hljs-number">1</span> &lt;&lt; i) &gt;= dep[v])<br>            u = f[u][i];<br>    <span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> u;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">20</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (f[u][i] != f[v][i]) &#123;<br>            u = f[u][i];<br>            v = f[v][i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[u][<span class="hljs-number">0</span>]; <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>(); q = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) c[i] = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-built_in">read</span>(), v = <span class="hljs-built_in">read</span>();<br>        e[u].<span class="hljs-built_in">push_back</span>(v);<br>        e[v].<span class="hljs-built_in">push_back</span>(u);<br>    &#125;<br>    sum[<span class="hljs-number">1</span>][c[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-built_in">read</span>(), v = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-type">int</span> fa = <span class="hljs-built_in">lca</span>(u, v), ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">25</span>)</span></span>;<br>        <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">20</span>) &#123;<br>            t[i] += sum[u][i] - sum[fa][i];<br>            t[i] += sum[v][i] - sum[f[fa][<span class="hljs-number">0</span>]][i];<br>            <span class="hljs-keyword">if</span> (t[i] != <span class="hljs-number">0</span>) ans += <span class="hljs-number">1</span>;<br>        &#125;<br>        cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><p><strong>标签：</strong> 贪心，线段树</p><p>所求为字典序最大的序列，那么每一步都应该选择能选的中最大的。当且仅当没有能放的宝石时，这一步放 $-1$。</p><p>体力值本质上是对选取范围做了限制。假设当前体力为 $k$ ，当前位置是 $i$ ，那么宝石的选取范围就是 $\left[ i, i + k \right]$ 。当有多个宝石值相等时，显然我们应该选取位置最靠前的，因为越靠后越可能在后续过程中有机会被选取到。选取完成后我们将其修改为 $0$ ，示意已经被选取过。</p><p>因而我们需要维护的是区间内的第一个最大值及其所在位置，并支持单点修改的操作，考虑用线段树维护。</p><p>在此基础上题目又增加了限制，相邻位置不能选取等大的数。那么当我们查询到的区间内最大值与上一位的取值相等时，应改为查询区间内的第一个严格次大值。这也可以使用线段树维护，只需修改一下线段树的信息结构和合并方式即可。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">seg</span> &#123;<br>    <span class="hljs-type">int</span> mx, mx2, mxpos, mx2pos;<br>&#125; t[N &lt;&lt; <span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>    pii tmp[<span class="hljs-number">5</span>];<br>    tmp[<span class="hljs-number">0</span>] = <span class="hljs-built_in">make_pair</span>(t[p &lt;&lt; <span class="hljs-number">1</span>].mx, -t[p &lt;&lt; <span class="hljs-number">1</span>].mxpos);<br>    tmp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">make_pair</span>(t[p &lt;&lt; <span class="hljs-number">1</span>].mx2, -t[p &lt;&lt; <span class="hljs-number">1</span>].mx2pos);<br>    tmp[<span class="hljs-number">2</span>] = <span class="hljs-built_in">make_pair</span>(t[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].mx, -t[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].mxpos); <br>    tmp[<span class="hljs-number">3</span>] = <span class="hljs-built_in">make_pair</span>(t[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].mx2, -t[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].mx2pos);<br>    <span class="hljs-built_in">sort</span>(tmp, tmp + <span class="hljs-number">4</span>);<br>    t[p].mx = tmp[<span class="hljs-number">3</span>].first; t[p].mxpos = -tmp[<span class="hljs-number">3</span>].second;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (tmp[i].first != tmp[<span class="hljs-number">3</span>].first) &#123;<br>            t[p].mx2 = tmp[i].first;<br>            t[p].mx2pos = -tmp[i].second;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r) &#123;<br>        t[p].mx = a[l];<br>        t[p].mxpos = l;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid);<br>    <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (l == r &amp;&amp; l == x) &#123;<br>        t[p].mx = y;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, x, y);<br>    <span class="hljs-keyword">if</span> (x &gt; mid) <span class="hljs-built_in">modify</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, x, y);<br>    <span class="hljs-built_in">pushup</span>(p);<br>&#125;<br><br><span class="hljs-function">seg <span class="hljs-title">querymx2</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> t[p];<br>    <span class="hljs-keyword">if</span> (L &gt; r || R &lt; l) <span class="hljs-keyword">return</span> (seg)&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>    seg mxl = <span class="hljs-built_in">querymx2</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R);<br>    seg mxr = <span class="hljs-built_in">querymx2</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R);<br>    pii tmp[<span class="hljs-number">5</span>];<br>    tmp[<span class="hljs-number">0</span>] = <span class="hljs-built_in">make_pair</span>(mxl.mx, -mxl.mxpos);<br>    tmp[<span class="hljs-number">1</span>] = <span class="hljs-built_in">make_pair</span>(mxl.mx2, -mxl.mx2pos);<br>    tmp[<span class="hljs-number">2</span>] = <span class="hljs-built_in">make_pair</span>(mxr.mx, -mxr.mxpos); <br>    tmp[<span class="hljs-number">3</span>] = <span class="hljs-built_in">make_pair</span>(mxr.mx2, -mxr.mx2pos);<br>    <span class="hljs-built_in">sort</span>(tmp, tmp + <span class="hljs-number">4</span>);<br>    seg ans = (seg)&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br>    ans.mx = tmp[<span class="hljs-number">3</span>].first; ans.mxpos = -tmp[<span class="hljs-number">3</span>].second;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (tmp[i].first != tmp[<span class="hljs-number">3</span>].first) &#123;<br>            ans.mx2 = tmp[i].first;<br>            ans.mx2pos = -tmp[i].second;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>(); k = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) a[i] = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        seg now = <span class="hljs-built_in">querymx2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, i, <span class="hljs-built_in">min</span>(i + k, n));<br>        <span class="hljs-keyword">if</span> (now.mx == <span class="hljs-number">0</span>) &#123;<br>            ans[i] = <span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">1</span> &amp;&amp; now.mx == ans[i - <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-keyword">if</span> (now.mx2 == <span class="hljs-number">0</span>) &#123;<br>                ans[i] = <span class="hljs-number">-1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ans[i] = now.mx2;<br>                <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, now.mx2pos, <span class="hljs-number">0</span>);<br>                k -= now.mx2pos - i;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans[i] = now.mx;<br>            <span class="hljs-built_in">modify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, now.mxpos, <span class="hljs-number">0</span>);<br>            k -= now.mxpos - i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⌈25春训⌋ 第二场题解</title>
    <link href="/2025/04/01/25%E6%98%A5%E8%AE%AD2%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/04/01/25%E6%98%A5%E8%AE%AD2%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p><strong>题目大意：</strong> 规定每一位采用的进制。求十进制数在该进制下的表示。</p><p><strong>难度：</strong> ~900</p><p>按照题意，模拟进位的过程即可。（注意要求输出前导零）</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    string s; <br>    cin &gt;&gt; n &gt;&gt; m;<br>    cin &gt;&gt; s &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-type">int</span> cur = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>        ans[i] = m % cur;<br>        m /= cur;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cout &lt;&lt; ans[i];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p><strong>题目大意：</strong> 构造含 $1$ 至 $n$ 各两次的排列，以最小化 $\sum_{i&#x3D;1}^{n}(n-i)\left|d_i+i-n\right|$ 的值，其中 $d_i$ 是排列中两个 $i$ 之间的距离。</p><p><strong>难度：</strong> 1900</p><p>显然 $i&#x3D;n$ 放的位置不改变答案。因此考虑最后放。</p><p>考虑构造 $d_i&#x3D;n-i$ $(1\leq i \leq n-1)$ 的方案，$n$ 为奇数和偶数时，分别如下（以 $n&#x3D;5,6$ 为例）。</p><p><img src="/pic1.png"></p><p><img src="/pic2.png"></p><p>将奇数偶数聚在一起放置，最后空出的位置放 $n$ 。这样可保证目标式的值为 $0$ ，达到最小。</p><p>Code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i += <span class="hljs-number">2</span>) &#123;<br>        a[(i + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>] = i;<br>        a[(i + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + n - i] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i += <span class="hljs-number">2</span>) &#123;<br>        a[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span> - i / <span class="hljs-number">2</span>] = i;<br>        a[<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span> - i / <span class="hljs-number">2</span> - n + i] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">2</span> * n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!a[i]) a[i] = n;<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> * n) cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p><strong>题目大意：</strong> 给定一棵有向树型图，此外每个节点有一个指回根节点的边。要求维护两种操作：修改边权以及查询两点之间的最短路径。</p><p><strong>难度：</strong> 2100</p><p>为了方便叙述，下面设树的根节点是 $r$ ，询问中起点是 $u$ ，终点是 $v$ ，修改中的终点是 $x$ .</p><p>此外，将节点 $i$ 与根节点的距离记为 $sum_i$ .</p><p>观察后不难发现，最短路径有两种情形。</p><p>一、$v$ 在 $u$ 的子树内。那么无论选择何时返回 $r$ 再前往 $v$ ，路径都包含从 $u$ 到 $v$ 的简单路径。所以这种情形下答案就是简单路径的长度，也就是 $sum_v-sum_u$ .</p><p>二、$v$ 不在 $u$ 的子树内。那么路径一定如下构成：$u\rightarrow t \rightarrow r \rightarrow v$ ，其中的 $t$ 是 $u$ 子树中的节点。<br>$$<br>\begin{align*}<br>w_{u\rightarrow v}&amp;&#x3D;w_{u\rightarrow t} + w_{t\rightarrow r}+w_{r\rightarrow v}\<br>&amp;&#x3D;sum_t - sum_u+w_{t\rightarrow r}+sum_v<br>\end{align*}<br>$$<br>由于询问中 $u$ 和 $v$ 确定，我们只需维护每一个节点的 $sum_t + w_{t\rightarrow r}$ 值，然后在 $u$ 的子树中找出最小值即可。</p><p>修改操作同样有两种情形。</p><p>一、修改的是树边。那么 $x$ 的子树内所有节点对应的 $sum$ 值会改变相同的值。结合查询的要求，这似乎可以用线段树维护，但同子树内的节点编号不一定连续，难以维护。为了解决这个问题，我们将节点按照其 $dfs$ 序重新编号，这样就可以保证同子树内节点的编号是一个连续的区间，从而可以用线段树的区间修改来维护。</p><p>二、修改的不是树边。只需对 $sum_t+v_{t\rightarrow r}$ 做单点修改即可。</p><p>总的来说，我们根据 $dfs$ 序重排后建立两棵线段树。第一棵维护 $sum$ 值，支持区间修改和单点查询；第二棵维护 $sum_i + w_{i\rightarrow r} $ 值，支持区间修改和区间最值查询。在修改和查询时根据上文所说执行对应操作即可。</p><p>赛时思路完全正确，也完成了代码。但调试能力太差，未能场切。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOR(i,j,k) for (int i = j; i &lt;= k; i++)</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">4e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">1e16</span>;<br><br><span class="hljs-type">int</span> T;<br><br><span class="hljs-type">int</span> n, m, k, q;<br><br><span class="hljs-type">int</span> a[N], b[N];<br><br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; e[N &lt;&lt; <span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>(); <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> ((ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>) &amp;&amp; ch != <span class="hljs-string">&#x27;-&#x27;</span>) ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) &#123; ch = <span class="hljs-built_in">getchar</span>(); f = - <span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123; x = x * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span>; ch = <span class="hljs-built_in">getchar</span>(); &#125;<br>    <span class="hljs-keyword">return</span> x * f;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sgt</span> &#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> mid (l + r) / 2</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;<br>        <span class="hljs-type">int</span> val, len, mn, tag;<br>    &#125; info[N &lt;&lt; <span class="hljs-number">2</span>];<br><br>    <span class="hljs-type">int</span> a[N];<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123;<br>        info[p].val = info[p &lt;&lt; <span class="hljs-number">1</span>].val + info[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].val;<br>        info[p].len = info[p &lt;&lt; <span class="hljs-number">1</span>].len + info[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].len;<br>        info[p].mn = <span class="hljs-built_in">min</span>(info[p &lt;&lt; <span class="hljs-number">1</span>].mn, info[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].mn);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (info[p].tag) &#123;<br>            info[p &lt;&lt; <span class="hljs-number">1</span>].tag += info[p].tag;<br>            info[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].tag += info[p].tag;<br>            info[p &lt;&lt; <span class="hljs-number">1</span>].mn += info[p].tag;<br>            info[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].mn += info[p].tag;<br>            info[p &lt;&lt; <span class="hljs-number">1</span>].val += info[p].tag * (mid - l + <span class="hljs-number">1</span>);<br>            info[p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>].val += info[p].tag * (r - mid);<br>            info[p].tag = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) &#123;<br>            info[p].val = a[l];<br>            info[p].len = <span class="hljs-number">1</span>;<br>            info[p].mn = a[l];<br>            info[p].tag = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid);<br>        <span class="hljs-built_in">build</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r);<br>        <span class="hljs-built_in">pushup</span>(p);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pmodify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r &amp;&amp; l == x) &#123;<br>            info[p].val = v;<br>            info[p].mn = v;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">pushdown</span>(p, l, r);<br>        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">pmodify</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, x, v);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">pmodify</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, x, v);<br>        <span class="hljs-built_in">pushup</span>(p);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rmodify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;<br>            info[p].val += (r - l + <span class="hljs-number">1</span>) * v;<br>            info[p].tag += v;<br>            info[p].mn += v;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (R &lt; l || L &gt; r) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">pushdown</span>(p, l, r);<br>        <span class="hljs-built_in">rmodify</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R, v);<br>        <span class="hljs-built_in">rmodify</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R, v);<br>        <span class="hljs-built_in">pushup</span>(p);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> info[p].val;<br>        <span class="hljs-keyword">if</span> (R &lt; l || L &gt; r) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">pushdown</span>(p, l, r);<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        res += <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R);<br>        res += <span class="hljs-built_in">query</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R);<br>        <span class="hljs-built_in">pushup</span>(p);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">querymin</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) <span class="hljs-keyword">return</span> info[p].mn;<br>        <span class="hljs-keyword">if</span> (R &lt; l || L &gt; r) <span class="hljs-keyword">return</span> INF;<br>        <span class="hljs-built_in">pushdown</span>(p, l, r);<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        res = <span class="hljs-built_in">querymin</span>(p &lt;&lt; <span class="hljs-number">1</span>, l, mid, L, R);<br>        res =  <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">querymin</span>(p &lt;&lt; <span class="hljs-number">1</span> | <span class="hljs-number">1</span>, mid + <span class="hljs-number">1</span>, r, L, R));<br>        <span class="hljs-built_in">pushup</span>(p);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125; t, tt;<br><br><span class="hljs-type">int</span> nowmax = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> idx[N], nd[N], rg[N][<span class="hljs-number">2</span>], dep[N], f[N][<span class="hljs-number">30</span>];<br><br>vector&lt;<span class="hljs-type">int</span>&gt; sum;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>    dep[u] = dep[fa] + <span class="hljs-number">1</span>;<br>    nowmax++;<br>    idx[u] = nowmax;<br>    nd[nowmax] = u;<br>    rg[idx[u]][<span class="hljs-number">0</span>] = nowmax;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v.first == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs1</span>(u, v.first);<br>    &#125;<br>    rg[idx[u]][<span class="hljs-number">1</span>] = nowmax;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> u)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v.first == fa) <span class="hljs-keyword">continue</span>;<br>        sum[idx[v.first]] = sum[idx[u]] + v.second;<br>        <span class="hljs-built_in">dfs2</span>(u, v.first);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (dep[u] &lt; dep[v]) <span class="hljs-built_in">swap</span>(u, v);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">20</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br><span class="hljs-keyword">if</span> ((dep[u] - (<span class="hljs-number">1</span> &lt;&lt; i)) &gt;= dep[v])<br>u = f[u][i];<br><span class="hljs-keyword">if</span> (u == v) <span class="hljs-keyword">return</span> u;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">20</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br><span class="hljs-keyword">if</span> (f[u][i] == f[v][i]) <span class="hljs-keyword">continue</span>;<br>u = f[u][i]; v = f[v][i];<br>&#125;<br><span class="hljs-keyword">return</span> f[u][<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs3</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>f[u][<span class="hljs-number">0</span>] = fa;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; (<span class="hljs-number">1</span> &lt;&lt; i) &lt;= dep[u]; i++) <br>f[u][i] = f[f[u][i - <span class="hljs-number">1</span>]][i - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : e[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v.first == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs3</span>(v.first, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> rec[N][<span class="hljs-number">5</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>(); q = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) b[i] = INF;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>) &#123;<br>        rec[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">read</span>();<br>        rec[i][<span class="hljs-number">2</span>] = <span class="hljs-built_in">read</span>();<br>        rec[i][<span class="hljs-number">3</span>] = <span class="hljs-built_in">read</span>();<br>        e[rec[i][<span class="hljs-number">1</span>]].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(rec[i][<span class="hljs-number">2</span>], rec[i][<span class="hljs-number">3</span>]));<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, n, <span class="hljs-number">2</span> * n - <span class="hljs-number">2</span>) &#123;<br>        rec[i][<span class="hljs-number">1</span>] = <span class="hljs-built_in">read</span>();<br>        rec[i][<span class="hljs-number">2</span>] = <span class="hljs-built_in">read</span>();<br>        rec[i][<span class="hljs-number">3</span>] = <span class="hljs-built_in">read</span>();<br>        b[rec[i][<span class="hljs-number">1</span>]] = rec[i][<span class="hljs-number">3</span>];<br>    &#125;<br>    <br>    sum.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dfs3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) t.a[i] = sum[i];<br>    t.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) tt.a[i] = b[nd[i]] + sum[i];<br>    tt.<span class="hljs-built_in">build</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">int</span> op = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-type">int</span> u = <span class="hljs-built_in">read</span>(), v = <span class="hljs-built_in">read</span>();<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (u &gt;= n) &#123;<br>                <span class="hljs-type">int</span> tsum = t.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, idx[rec[u][<span class="hljs-number">1</span>]], idx[rec[u][<span class="hljs-number">1</span>]]);<br>                tt.<span class="hljs-built_in">pmodify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, idx[rec[u][<span class="hljs-number">1</span>]], v + tsum);<br>                b[rec[u][<span class="hljs-number">1</span>]] = v;<br>                rec[u][<span class="hljs-number">3</span>] = v;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> root = idx[rec[u][<span class="hljs-number">2</span>]];<br>                t.<span class="hljs-built_in">rmodify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, rg[root][<span class="hljs-number">0</span>], rg[root][<span class="hljs-number">1</span>], v - rec[u][<span class="hljs-number">3</span>]);<br>                tt.<span class="hljs-built_in">rmodify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, rg[root][<span class="hljs-number">0</span>], rg[root][<span class="hljs-number">1</span>], v - rec[u][<span class="hljs-number">3</span>]);<br>                rec[u][<span class="hljs-number">3</span>] = v;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">lca</span>(u, v) == u) &#123;<br>                <span class="hljs-type">int</span> s1 = t.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, idx[u], idx[u]);<br>                <span class="hljs-type">int</span> s2 = t.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, idx[v], idx[v]);<br>                cout &lt;&lt; s2 - s1 &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> ans = t.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, idx[v], idx[v]);<br>                <span class="hljs-type">int</span> ans2 = tt.<span class="hljs-built_in">querymin</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, rg[idx[u]][<span class="hljs-number">0</span>], rg[idx[u]][<span class="hljs-number">1</span>]);<br>                <span class="hljs-type">int</span> ans3 = t.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, idx[u], idx[u]);<br>                cout &lt;&lt; ans + ans2 - ans3 &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">solve</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>25春训</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>⌈25春训⌋ 第一场题解</title>
    <link href="/2025/03/17/25%E6%98%A5%E8%AE%AD1%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/03/17/25%E6%98%A5%E8%AE%AD1%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="A"><a href="#A" class="headerlink" title="A"></a>A</h1><p><strong>难度：</strong> 900</p><p>合法的数字最高位一定不为 $0$ ，这也就意味着低位只能全部为 $0$ （如果有低位的话）。因此只需将最高位加一，其余位归零即可。</p><p>Code：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n / res &gt;= <span class="hljs-number">10</span>) res *= <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> ans = ( n / res + <span class="hljs-number">1</span> ) * res - n;<br>    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="B"><a href="#B" class="headerlink" title="B"></a>B</h1><p><strong>题目大意：</strong> 现有 $n$ 个取值 $1$，$2$ 或 $3$ 的三元组。存在和不为 $6$ 的三元组的方案被视为合法方案。求合法方案数。</p><p><strong>难度：</strong> 1500</p><p>要求的方案数就是：全部的方案数 $-$ 所有三元组和均为 $6$ 的方案数。</p><p>由于对于每个三元组而言，总方案数是 $27$ ，和为 $6$ 的方案数是 $7$ ，故最终答案为 $27^n - 7^n$。</p><p>Code：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-type">int</span> ans1 = <span class="hljs-number">1</span>, ans2 = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) ans1 = ans1 * <span class="hljs-number">7</span> % MOD;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n * <span class="hljs-number">3</span>) ans2 = ans2 * <span class="hljs-number">3</span> % MOD;<br>    cout &lt;&lt; (ans2 - ans1 + MOD) % MOD;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C"></a>C</h1><p><strong>题目大意：</strong> 给定出入会记录的一部分。判断哪些人可能满足：会中有人时始终在会中。</p><p><strong>难度：</strong> 1800</p><p>首先，显然全程未出现记录的人一定符合要求，且不影响其他人的判断。我们在分析过程中无视他们即可。</p><p>第一条记录是出会的人在片段开始前就在会中。因此只要有这样的球员存在，第一条记录是入会的人一定不符合要求。而如果这样的人不存在，可能符合要求的只剩第一个入会的人。</p><p>接着我们模拟出会入会的情况。以下两种情况会被取消资格：</p><ol><li>出会时还有其他人在会中。</li><li>出会时会中没人，但紧接着有其他人入会。</li></ol><p>模拟结束后仍然未被取消资格的人，或全程无记录的人是符合要求的人。</p><p>Code: </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, m) &#123;<br>        cin &gt;&gt; c[i] &gt;&gt; a[i];<br>        mp[a[i]] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, m) &#123;<br>        <span class="hljs-keyword">if</span> (c[i] == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>            b[a[i]] = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (!b[a[i]]) &#123;<br>                d[a[i]] = <span class="hljs-number">1</span>;<br>                ans[a[i]] = <span class="hljs-number">1</span>;<br>                cnt++;<br>                b[a[i]] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (cnt == <span class="hljs-number">0</span>) &#123;<br>        ans[a[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;<br>        d[a[<span class="hljs-number">1</span>]] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, m) &#123;<br>        <span class="hljs-keyword">if</span> (c[i] == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>            cnt++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (c[i] == <span class="hljs-string">&#x27;-&#x27;</span>) &#123;<br>            cnt--;<br>            <span class="hljs-keyword">if</span> (cnt &gt; <span class="hljs-number">0</span>) ans[a[i]] = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (i != m) &#123;<br>                <span class="hljs-keyword">if</span> (a[i + <span class="hljs-number">1</span>] != a[i]) &#123;<br>                    ans[a[i]] = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-keyword">if</span> (mp[i] == <span class="hljs-number">0</span>) ans[i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-keyword">if</span> (ans[i]) tot++;<br>    cout &lt;&lt; tot &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) <span class="hljs-keyword">if</span> (ans[i]) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="D"><a href="#D" class="headerlink" title="D"></a>D</h1><p><strong>题目大意：</strong> 定义一个排列的值是其字典序排名，排列求和的结果是，两排列值之和模排列总数的结果对应的排列。求指定两排列的和。</p><p><strong>难度：</strong> 2000</p><p>这似乎是康托展开的板子题，不过在听讲评之前我并不知道。</p><p>注意到一个排列的排名可如下计算：<br>$$<br>R_p &#x3D; \sum _{i &#x3D; 1} ^{n} (r_i - 1) (n - i)!<br>$$<br>其中 $r_i$ 代表 $p_i$ 在 $p_k(k \geq i)$ 中的排名。因此也可知 $r_i\leq n - i.$</p><p>我们使用权值线段树记录到当前位置为止 $x$ 是否还能选，则 $x$ 的前缀和（不含 $x$ ）即为 $x$ 在剩下的数中的排名。</p><p>题目所求为两排列的排名之和，我们考虑以”各位分别相加+进位”的方法处理排名相加的过程。若进位至第零位，则正好满足了模 $n!$ 的要求，无需处理。</p><p>进位完成后，只需再根据每一位在剩下数中的排名复原其值即可。这一操作赛时我通过二分查找+线段树来实现，时间复杂度 $O(n\log^2n)$ ，未能通过此题。使用线段树上二分可将复杂度降至 $O(n\log n)$ ，可以通过此题。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOR(i,j,k) for (int i = j; i &lt;= k; i++)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ROF(i,j,k) for (int i = j; i &gt;= k; i--)</span><br><br><span class="hljs-type">int</span> n, m, k;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> ch = <span class="hljs-built_in">getchar</span>(); <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> ((ch &gt; <span class="hljs-string">&#x27;9&#x27;</span> || ch &lt; <span class="hljs-string">&#x27;0&#x27;</span>) &amp;&amp; ch != <span class="hljs-string">&#x27;-&#x27;</span>) ch = <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;-&#x27;</span>) &#123; ch = <span class="hljs-built_in">getchar</span>(); f = - <span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-keyword">while</span> (ch &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123; x = x * <span class="hljs-number">10</span> + ch - <span class="hljs-string">&#x27;0&#x27;</span>; ch = <span class="hljs-built_in">getchar</span>(); &#125;<br>    <span class="hljs-keyword">return</span> x * f;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Info</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tag</span>&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">SGT</span> &#123;<br><br><span class="hljs-keyword">private</span>:<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> l(p) (p &lt;&lt; 1)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> r(p) (p &lt;&lt; 1 | 1)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> mid (l + r) / 2</span><br><br>    <span class="hljs-type">int</span> n;<br>    vector&lt;Info&gt; info;<br>    vector&lt;Tag&gt; tag;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-type">int</span> p)</span> </span>&#123; info[p] = info[<span class="hljs-built_in">l</span>(p)] + info[<span class="hljs-built_in">r</span>(p)]; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushdown</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-built_in">addTag</span>(<span class="hljs-built_in">l</span>(p), l, mid, tag[p]);<br>        <span class="hljs-built_in">addTag</span>(<span class="hljs-built_in">r</span>(p), mid + <span class="hljs-number">1</span>, r, tag[p]);<br>        tag[p] = <span class="hljs-built_in">Tag</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addTag</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">const</span> Tag &amp;v)</span> </span>&#123;<br>        info[p].<span class="hljs-built_in">apply</span>(v); tag[p].<span class="hljs-built_in">apply</span>(v);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rmodify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">const</span> Tag &amp;v)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt; y || r &lt; x) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (r &lt;= y &amp;&amp; l &gt;= x) &#123; <span class="hljs-built_in">addTag</span>(p, l, r, v); <span class="hljs-keyword">return</span>; &#125;<br>        <span class="hljs-built_in">pushdown</span>(p, l, r);<br>        <span class="hljs-built_in">rmodify</span>(<span class="hljs-built_in">l</span>(p), l, mid, x, y, v);<br>        <span class="hljs-built_in">rmodify</span>(<span class="hljs-built_in">r</span>(p), mid + <span class="hljs-number">1</span>, r, x, y, v);<br>        <span class="hljs-built_in">pushup</span>(p);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pmodify</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">const</span> Info &amp;v)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) &#123; info[p] = v; <span class="hljs-keyword">return</span>; &#125;<br>        <span class="hljs-built_in">pushdown</span>(p, l, r);<br>        <span class="hljs-keyword">if</span> (x &lt;= mid) <span class="hljs-built_in">pmodify</span>(<span class="hljs-built_in">l</span>(p), l, mid, x, v);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">pmodify</span>(<span class="hljs-built_in">r</span>(p), mid + <span class="hljs-number">1</span>, r, x, v);<br>        <span class="hljs-built_in">pushup</span>(p);<br>    &#125;<br><br>    <span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l &gt; y || r &lt; x) <span class="hljs-keyword">return</span> <span class="hljs-built_in">Info</span>();<br>        <span class="hljs-keyword">if</span> (r &lt;= y &amp;&amp; l &gt;= x) <span class="hljs-keyword">return</span> info[p];<br>        <span class="hljs-built_in">pushdown</span>(p, l, r);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-built_in">l</span>(p), l, mid, x, y) + <span class="hljs-built_in">query</span>(<span class="hljs-built_in">r</span>(p), mid + <span class="hljs-number">1</span>, r, x, y);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findkth</span><span class="hljs-params">(<span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> l;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">pushdown</span>(p, l, r);<br>            <span class="hljs-keyword">if</span> (info[<span class="hljs-built_in">l</span>(p)].sum &gt;= k) <span class="hljs-keyword">return</span> <span class="hljs-built_in">findkth</span>(<span class="hljs-built_in">l</span>(p), l, mid, k);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">findkth</span>(<span class="hljs-built_in">r</span>(p), mid + <span class="hljs-number">1</span>, r, k - info[<span class="hljs-built_in">l</span>(p)].sum);<br>            <span class="hljs-built_in">pushup</span>(p);<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">SGT</span>(<span class="hljs-type">int</span> _n) : <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">info</span>(_n &lt;&lt; <span class="hljs-number">2</span>), <span class="hljs-built_in">tag</span>(_n &lt;&lt; <span class="hljs-number">2</span>) &#123;&#125;;<br>    <br>    <span class="hljs-built_in">SGT</span>(vector&lt;Info&gt; vc) : <span class="hljs-built_in">SGT</span>(vc.<span class="hljs-built_in">size</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> build = [&amp;](<span class="hljs-keyword">auto</span> self, <span class="hljs-type">int</span> p, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r) &#123;<br>            <span class="hljs-keyword">if</span> (l == r) &#123;<br>                info[p] = vc[l];<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-built_in">self</span>(self, <span class="hljs-built_in">l</span>(p), l, mid);<br>            <span class="hljs-built_in">self</span>(self, <span class="hljs-built_in">r</span>(p), mid + <span class="hljs-number">1</span>, r);<br>            <span class="hljs-built_in">pushup</span>(p);<br>        &#125;;<br>        <span class="hljs-built_in">build</span>(build, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rmodify</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">const</span> Tag &amp;v)</span> </span>&#123; <span class="hljs-built_in">rmodify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, x, y, v); &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pmodify</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">const</span> Info &amp;v)</span> </span>&#123; <span class="hljs-built_in">pmodify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, x, v); &#125;<br><br>    <span class="hljs-function">Info <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, x, y); &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findkth</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">findkth</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, k); &#125;<br><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tag</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> add;<br>    <span class="hljs-built_in">Tag</span>(): <span class="hljs-built_in">add</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-built_in">Tag</span>(<span class="hljs-type">int</span> val): <span class="hljs-built_in">add</span>(val) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(Tag v)</span> </span>&#123; add += v.add; &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Info</span> &#123;<br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum;<br>    <span class="hljs-built_in">Info</span>(): <span class="hljs-built_in">len</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">sum</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-built_in">Info</span>(<span class="hljs-type">int</span> val): <span class="hljs-built_in">len</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">sum</span>(val) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(Tag v)</span> </span>&#123; sum += v.add * len; &#125;<br>&#125;;<br><br>Info <span class="hljs-keyword">operator</span>+(Info a, Info b) &#123;<br>    Info c;<br>    c.len = a.len + b.len;<br>    c.sum = a.sum + b.sum;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    n = <span class="hljs-built_in">read</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">p</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">q</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rp</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">rq</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">rk</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) p[i] = <span class="hljs-built_in">read</span>() + <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) q[i] = <span class="hljs-built_in">read</span>() + <span class="hljs-number">1</span>;<br>    <span class="hljs-function">SGT&lt;Info, Tag&gt; <span class="hljs-title">tp</span><span class="hljs-params">(n)</span>, <span class="hljs-title">tq</span><span class="hljs-params">(n)</span>, <span class="hljs-title">tt</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        tp.<span class="hljs-built_in">pmodify</span>(p[i], <span class="hljs-built_in">Info</span>(<span class="hljs-number">1</span>));<br>        rp[i] = p[i] - tp.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, p[i]).sum;<br>        tq.<span class="hljs-built_in">pmodify</span>(q[i], <span class="hljs-built_in">Info</span>(<span class="hljs-number">1</span>));<br>        rq[i] = q[i] - tq.<span class="hljs-built_in">query</span>(<span class="hljs-number">1</span>, q[i]).sum;<br>        rk[i] = rp[i] + rq[i];<br>    &#125;<br>    <span class="hljs-built_in">ROF</span>(i, n - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) &#123;<br>        rk[i - <span class="hljs-number">1</span>] += rk[i] / (n - i + <span class="hljs-number">1</span>);<br>        rk[i] %= (n - i + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) tt.<span class="hljs-built_in">pmodify</span>(i, <span class="hljs-built_in">Info</span>(<span class="hljs-number">1</span>));<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">1</span>, n) &#123;<br>        <span class="hljs-type">int</span> u = tt.<span class="hljs-built_in">findkth</span>(rk[i] + <span class="hljs-number">1</span>);<br>        tt.<span class="hljs-built_in">pmodify</span>(u, <span class="hljs-built_in">Info</span>(<span class="hljs-number">0</span>));<br>        cout &lt;&lt; u - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法竞赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>25春训</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
